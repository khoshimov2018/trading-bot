# coding: utf-8
# Automatically generated code.
# Do not edit manually.
# Generated by running: __main__pydevd_gen_debug_adapter_protocol.py
from .pydevd_base_schema import BaseSchema, register, register_request, register_response, register_event


@register
class ProtocolMessage(BaseSchema):
    """
    Base class of requests, responses, and events.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "description": "Message type.", "_enum": ["request", "response", "event"]},
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, type, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type: Message type.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = type
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        seq = self.seq
        dct = {
            "type": type,
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class Request(BaseSchema):
    """
    A client or debug adapter initiated request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "description": "The command to execute."},
        "arguments": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Object containing arguments for the command.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, command, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command: The command to execute.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] arguments: Object containing arguments for the command.
        """
        self.type = "request"
        self.command = command
        self.seq = seq
        self.arguments = arguments
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments
        dct.update(self.kwargs)
        return dct


@register
class Event(BaseSchema):
    """
    A debug adapter initiated event.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "description": "Type of event."},
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Event-specific information.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, event, seq=-1, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event: Type of event.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Event-specific information.
        """
        self.type = "event"
        self.event = event
        self.seq = seq
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        seq = self.seq
        body = self.body
        dct = {
            "type": type,
            "event": event,
            "seq": seq,
        }
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register
class Response(BaseSchema):
    """
    Response for a request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_response("error")
@register
class ErrorResponse(BaseSchema):
    """
    On error (whenever `success` is false), the body can provide more details.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {"error": {"$ref": "#/definitions/Message", "description": "A structured error message."}},
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param ErrorResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = ErrorResponseBody()
        else:
            self.body = ErrorResponseBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ErrorResponseBody else body
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("cancel")
@register
class CancelRequest(BaseSchema):
    """
    The `cancel` request is used by the client in two situations:

    - to indicate that it is no longer interested in the result produced by a specific request issued
    earlier

    - to cancel a progress sequence.

    Clients should only call this request if the corresponding capability `supportsCancelRequest` is
    true.

    This request has a hint characteristic: a debug adapter can only be expected to make a 'best effort'
    in honoring this request but there are no guarantees.

    The `cancel` request may return an error if it could not cancel an operation but a client should
    refrain from presenting this error to end users.

    The request that got cancelled still needs to send a response back. This can either be a normal
    result (`success` attribute true) or an error response (`success` attribute false and the `message`
    set to `cancelled`).

    Returning partial results from a cancelled request is possible but please note that a client has no
    generic way for detecting that a response is partial or not.

    The progress that got cancelled still needs to send a `progressEnd` event back.

    A client should not assume that progress just got cancelled after sending the `cancel` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["cancel"]},
        "arguments": {"type": "CancelArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param CancelArguments arguments:
        """
        self.type = "request"
        self.command = "cancel"
        self.seq = seq
        if arguments is None:
            self.arguments = CancelArguments()
        else:
            self.arguments = (
                CancelArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != CancelArguments
                else arguments
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register
class CancelArguments(BaseSchema):
    """
    Arguments for `cancel` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "requestId": {
            "type": "integer",
            "description": "The ID (attribute `seq`) of the request to cancel. If missing no request is cancelled.\nBoth a `requestId` and a `progressId` can be specified in one request.",
        },
        "progressId": {
            "type": "string",
            "description": "The ID (attribute `progressId`) of the progress to cancel. If missing no progress is cancelled.\nBoth a `requestId` and a `progressId` can be specified in one request.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, requestId=None, progressId=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param integer requestId: The ID (attribute `seq`) of the request to cancel. If missing no request is cancelled.
        Both a `requestId` and a `progressId` can be specified in one request.
        :param string progressId: The ID (attribute `progressId`) of the progress to cancel. If missing no progress is cancelled.
        Both a `requestId` and a `progressId` can be specified in one request.
        """
        self.requestId = requestId
        self.progressId = progressId
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        requestId = self.requestId
        progressId = self.progressId
        dct = {}
        if requestId is not None:
            dct["requestId"] = requestId
        if progressId is not None:
            dct["progressId"] = progressId
        dct.update(self.kwargs)
        return dct


@register_response("cancel")
@register
class CancelResponse(BaseSchema):
    """
    Response to `cancel` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_event("initialized")
@register
class InitializedEvent(BaseSchema):
    """
    This event indicates that the debug adapter is ready to accept configuration requests (e.g.
    `setBreakpoints`, `setExceptionBreakpoints`).

    A debug adapter is expected to send this event when it is ready to accept configuration requests
    (but not before the `initialize` request has finished).

    The sequence of events/requests is as follows:

    - adapters sends `initialized` event (after the `initialize` request has returned)

    - client sends zero or more `setBreakpoints` requests

    - client sends one `setFunctionBreakpoints` request (if corresponding capability
    `supportsFunctionBreakpoints` is true)

    - client sends a `setExceptionBreakpoints` request if one or more `exceptionBreakpointFilters` have
    been defined (or if `supportsConfigurationDoneRequest` is not true)

    - client sends other future configuration requests

    - client sends one `configurationDone` request to indicate the end of the configuration.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["initialized"]},
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Event-specific information.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Event-specific information.
        """
        self.type = "event"
        self.event = "initialized"
        self.seq = seq
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        seq = self.seq
        body = self.body
        dct = {
            "type": type,
            "event": event,
            "seq": seq,
        }
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_event("stopped")
@register
class StoppedEvent(BaseSchema):
    """
    The event indicates that the execution of the debuggee has stopped due to some condition.

    This can be caused by a breakpoint previously set, a stepping request has completed, by executing a
    debugger statement etc.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["stopped"]},
        "body": {
            "type": "object",
            "properties": {
                "reason": {
                    "type": "string",
                    "description": "The reason for the event.\nFor backward compatibility this string is shown in the UI if the `description` attribute is missing (but it must not be translated).",
                    "_enum": [
                        "step",
                        "breakpoint",
                        "exception",
                        "pause",
                        "entry",
                        "goto",
                        "function breakpoint",
                        "data breakpoint",
                        "instruction breakpoint",
                    ],
                },
                "description": {
                    "type": "string",
                    "description": "The full reason for the event, e.g. 'Paused on exception'. This string is shown in the UI as is and can be translated.",
                },
                "threadId": {"type": "integer", "description": "The thread which was stopped."},
                "preserveFocusHint": {
                    "type": "boolean",
                    "description": "A value of True hints to the client that this event should not change the focus.",
                },
                "text": {
                    "type": "string",
                    "description": "Additional information. E.g. if reason is `exception`, text contains the exception name. This string is shown in the UI.",
                },
                "allThreadsStopped": {
                    "type": "boolean",
                    "description": "If `allThreadsStopped` is True, a debug adapter can announce that all threads have stopped.\n- The client should use this information to enable that all threads can be expanded to access their stacktraces.\n- If the attribute is missing or false, only the thread with the given `threadId` can be expanded.",
                },
                "hitBreakpointIds": {
                    "type": "array",
                    "items": {"type": "integer"},
                    "description": "Ids of the breakpoints that triggered the event. In most cases there is only a single breakpoint but here are some examples for multiple breakpoints:\n- Different types of breakpoints map to the same location.\n- Multiple source breakpoints get collapsed to the same instruction by the compiler/runtime.\n- Multiple function breakpoints with different function names map to the same location.",
                },
            },
            "required": ["reason"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param StoppedEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "stopped"
        if body is None:
            self.body = StoppedEventBody()
        else:
            self.body = StoppedEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != StoppedEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("continued")
@register
class ContinuedEvent(BaseSchema):
    """
    The event indicates that the execution of the debuggee has continued.

    Please note: a debug adapter is not expected to send this event in response to a request that
    implies that execution continues, e.g. `launch` or `continue`.

    It is only necessary to send a `continued` event if there was no previous request that implied this.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["continued"]},
        "body": {
            "type": "object",
            "properties": {
                "threadId": {"type": "integer", "description": "The thread which was continued."},
                "allThreadsContinued": {
                    "type": "boolean",
                    "description": "If `allThreadsContinued` is True, a debug adapter can announce that all threads have continued.",
                },
            },
            "required": ["threadId"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ContinuedEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "continued"
        if body is None:
            self.body = ContinuedEventBody()
        else:
            self.body = (
                ContinuedEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ContinuedEventBody else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("exited")
@register
class ExitedEvent(BaseSchema):
    """
    The event indicates that the debuggee has exited and returns its exit code.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["exited"]},
        "body": {
            "type": "object",
            "properties": {"exitCode": {"type": "integer", "description": "The exit code returned from the debuggee."}},
            "required": ["exitCode"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ExitedEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "exited"
        if body is None:
            self.body = ExitedEventBody()
        else:
            self.body = ExitedEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ExitedEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("terminated")
@register
class TerminatedEvent(BaseSchema):
    """
    The event indicates that debugging of the debuggee has terminated. This does **not** mean that the
    debuggee itself has exited.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["terminated"]},
        "body": {
            "type": "object",
            "properties": {
                "restart": {
                    "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
                    "description": "A debug adapter may set `restart` to True (or to an arbitrary object) to request that the client restarts the session.\nThe value is not interpreted by the client and passed unmodified as an attribute `__restart` to the `launch` and `attach` requests.",
                }
            },
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param TerminatedEventBody body:
        """
        self.type = "event"
        self.event = "terminated"
        self.seq = seq
        if body is None:
            self.body = TerminatedEventBody()
        else:
            self.body = (
                TerminatedEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != TerminatedEventBody else body
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        seq = self.seq
        body = self.body
        dct = {
            "type": type,
            "event": event,
            "seq": seq,
        }
        if body is not None:
            dct["body"] = body.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register_event("thread")
@register
class ThreadEvent(BaseSchema):
    """
    The event indicates that a thread has started or exited.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["thread"]},
        "body": {
            "type": "object",
            "properties": {
                "reason": {"type": "string", "description": "The reason for the event.", "_enum": ["started", "exited"]},
                "threadId": {"type": "integer", "description": "The identifier of the thread."},
            },
            "required": ["reason", "threadId"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ThreadEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "thread"
        if body is None:
            self.body = ThreadEventBody()
        else:
            self.body = ThreadEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ThreadEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("output")
@register
class OutputEvent(BaseSchema):
    """
    The event indicates that the target has produced some output.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["output"]},
        "body": {
            "type": "object",
            "properties": {
                "category": {
                    "type": "string",
                    "description": "The output category. If not specified or if the category is not understood by the client, `console` is assumed.",
                    "_enum": ["console", "important", "stdout", "stderr", "telemetry"],
                    "enumDescriptions": [
                        "Show the output in the client's default message UI, e.g. a 'debug console'. This category should only be used for informational output from the debugger (as opposed to the debuggee).",
                        "A hint for the client to show the output in the client's UI for important and highly visible information, e.g. as a popup notification. This category should only be used for important messages from the debugger (as opposed to the debuggee). Since this category value is a hint, clients might ignore the hint and assume the `console` category.",
                        "Show the output as normal program output from the debuggee.",
                        "Show the output as error program output from the debuggee.",
                        "Send the output to telemetry instead of showing it to the user.",
                    ],
                },
                "output": {"type": "string", "description": "The output to report."},
                "group": {
                    "type": "string",
                    "description": "Support for keeping an output log organized by grouping related messages.",
                    "enum": ["start", "startCollapsed", "end"],
                    "enumDescriptions": [
                        "Start a new group in expanded mode. Subsequent output events are members of the group and should be shown indented.\nThe `output` attribute becomes the name of the group and is not indented.",
                        "Start a new group in collapsed mode. Subsequent output events are members of the group and should be shown indented (as soon as the group is expanded).\nThe `output` attribute becomes the name of the group and is not indented.",
                        "End the current group and decrease the indentation of subsequent output events.\nA non-empty `output` attribute is shown as the unindented end of the group.",
                    ],
                },
                "variablesReference": {
                    "type": "integer",
                    "description": "If an attribute `variablesReference` exists and its value is > 0, the output contains objects which can be retrieved by passing `variablesReference` to the `variables` request as long as execution remains suspended. See 'Lifetime of Object References' in the Overview section for details.",
                },
                "source": {"$ref": "#/definitions/Source", "description": "The source location where the output was produced."},
                "line": {"type": "integer", "description": "The source location's line where the output was produced."},
                "column": {
                    "type": "integer",
                    "description": "The position in `line` where the output was produced. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based.",
                },
                "data": {
                    "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
                    "description": "Additional data to report. For the `telemetry` category the data is sent to telemetry, for the other categories the data is shown in JSON format.",
                },
            },
            "required": ["output"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param OutputEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "output"
        if body is None:
            self.body = OutputEventBody()
        else:
            self.body = OutputEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != OutputEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("breakpoint")
@register
class BreakpointEvent(BaseSchema):
    """
    The event indicates that some information about a breakpoint has changed.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["breakpoint"]},
        "body": {
            "type": "object",
            "properties": {
                "reason": {"type": "string", "description": "The reason for the event.", "_enum": ["changed", "new", "removed"]},
                "breakpoint": {
                    "$ref": "#/definitions/Breakpoint",
                    "description": "The `id` attribute is used to find the target breakpoint, the other attributes are used as the new values.",
                },
            },
            "required": ["reason", "breakpoint"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param BreakpointEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "breakpoint"
        if body is None:
            self.body = BreakpointEventBody()
        else:
            self.body = (
                BreakpointEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != BreakpointEventBody else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("module")
@register
class ModuleEvent(BaseSchema):
    """
    The event indicates that some information about a module has changed.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["module"]},
        "body": {
            "type": "object",
            "properties": {
                "reason": {"type": "string", "description": "The reason for the event.", "enum": ["new", "changed", "removed"]},
                "module": {
                    "$ref": "#/definitions/Module",
                    "description": "The new, changed, or removed module. In case of `removed` only the module id is used.",
                },
            },
            "required": ["reason", "module"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ModuleEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "module"
        if body is None:
            self.body = ModuleEventBody()
        else:
            self.body = ModuleEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ModuleEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("loadedSource")
@register
class LoadedSourceEvent(BaseSchema):
    """
    The event indicates that some source has been added, changed, or removed from the set of all loaded
    sources.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["loadedSource"]},
        "body": {
            "type": "object",
            "properties": {
                "reason": {"type": "string", "description": "The reason for the event.", "enum": ["new", "changed", "removed"]},
                "source": {"$ref": "#/definitions/Source", "description": "The new, changed, or removed source."},
            },
            "required": ["reason", "source"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param LoadedSourceEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "loadedSource"
        if body is None:
            self.body = LoadedSourceEventBody()
        else:
            self.body = (
                LoadedSourceEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != LoadedSourceEventBody else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("process")
@register
class ProcessEvent(BaseSchema):
    """
    The event indicates that the debugger has begun debugging a new process. Either one that it has
    launched, or one that it has attached to.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["process"]},
        "body": {
            "type": "object",
            "properties": {
                "name": {
                    "type": "string",
                    "description": "The logical name of the process. This is usually the full path to process's executable file. Example: /home/example/myproj/program.js.",
                },
                "systemProcessId": {
                    "type": "integer",
                    "description": "The system process id of the debugged process. This property is missing for non-system processes.",
                },
                "isLocalProcess": {
                    "type": "boolean",
                    "description": "If True, the process is running on the same computer as the debug adapter.",
                },
                "startMethod": {
                    "type": "string",
                    "enum": ["launch", "attach", "attachForSuspendedLaunch"],
                    "description": "Describes how the debug engine started debugging this process.",
                    "enumDescriptions": [
                        "Process was launched under the debugger.",
                        "Debugger attached to an existing process.",
                        "A project launcher component has launched a new process in a suspended state and then asked the debugger to attach.",
                    ],
                },
                "pointerSize": {
                    "type": "integer",
                    "description": "The size of a pointer or address for this process, in bits. This value may be used by clients when formatting addresses for display.",
                },
            },
            "required": ["name"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ProcessEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "process"
        if body is None:
            self.body = ProcessEventBody()
        else:
            self.body = ProcessEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ProcessEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("capabilities")
@register
class CapabilitiesEvent(BaseSchema):
    """
    The event indicates that one or more capabilities have changed.

    Since the capabilities are dependent on the client and its UI, it might not be possible to change
    that at random times (or too late).

    Consequently this event has a hint characteristic: a client can only be expected to make a 'best
    effort' in honoring individual capabilities but there are no guarantees.

    Only changed capabilities need to be included, all other capabilities keep their values.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["capabilities"]},
        "body": {
            "type": "object",
            "properties": {"capabilities": {"$ref": "#/definitions/Capabilities", "description": "The set of updated capabilities."}},
            "required": ["capabilities"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param CapabilitiesEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "capabilities"
        if body is None:
            self.body = CapabilitiesEventBody()
        else:
            self.body = (
                CapabilitiesEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != CapabilitiesEventBody else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("progressStart")
@register
class ProgressStartEvent(BaseSchema):
    """
    The event signals that a long running operation is about to start and provides additional
    information for the client to set up a corresponding progress and cancellation UI.

    The client is free to delay the showing of the UI in order to reduce flicker.

    This event should only be sent if the corresponding capability `supportsProgressReporting` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["progressStart"]},
        "body": {
            "type": "object",
            "properties": {
                "progressId": {
                    "type": "string",
                    "description": "An ID that can be used in subsequent `progressUpdate` and `progressEnd` events to make them refer to the same progress reporting.\nIDs must be unique within a debug session.",
                },
                "title": {
                    "type": "string",
                    "description": "Short title of the progress reporting. Shown in the UI to describe the long running operation.",
                },
                "requestId": {
                    "type": "integer",
                    "description": "The request ID that this progress report is related to. If specified a debug adapter is expected to emit progress events for the long running request until the request has been either completed or cancelled.\nIf the request ID is omitted, the progress report is assumed to be related to some general activity of the debug adapter.",
                },
                "cancellable": {
                    "type": "boolean",
                    "description": "If True, the request that reports progress may be cancelled with a `cancel` request.\nSo this property basically controls whether the client should use UX that supports cancellation.\nClients that don't support cancellation are allowed to ignore the setting.",
                },
                "message": {"type": "string", "description": "More detailed progress message."},
                "percentage": {
                    "type": "number",
                    "description": "Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.",
                },
            },
            "required": ["progressId", "title"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ProgressStartEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "progressStart"
        if body is None:
            self.body = ProgressStartEventBody()
        else:
            self.body = (
                ProgressStartEventBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != ProgressStartEventBody
                else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("progressUpdate")
@register
class ProgressUpdateEvent(BaseSchema):
    """
    The event signals that the progress reporting needs to be updated with a new message and/or
    percentage.

    The client does not have to update the UI immediately, but the clients needs to keep track of the
    message and/or percentage values.

    This event should only be sent if the corresponding capability `supportsProgressReporting` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["progressUpdate"]},
        "body": {
            "type": "object",
            "properties": {
                "progressId": {"type": "string", "description": "The ID that was introduced in the initial `progressStart` event."},
                "message": {
                    "type": "string",
                    "description": "More detailed progress message. If omitted, the previous message (if any) is used.",
                },
                "percentage": {
                    "type": "number",
                    "description": "Progress percentage to display (value range: 0 to 100). If omitted no percentage is shown.",
                },
            },
            "required": ["progressId"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ProgressUpdateEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "progressUpdate"
        if body is None:
            self.body = ProgressUpdateEventBody()
        else:
            self.body = (
                ProgressUpdateEventBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != ProgressUpdateEventBody
                else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("progressEnd")
@register
class ProgressEndEvent(BaseSchema):
    """
    The event signals the end of the progress reporting with a final message.

    This event should only be sent if the corresponding capability `supportsProgressReporting` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["progressEnd"]},
        "body": {
            "type": "object",
            "properties": {
                "progressId": {"type": "string", "description": "The ID that was introduced in the initial `ProgressStartEvent`."},
                "message": {
                    "type": "string",
                    "description": "More detailed progress message. If omitted, the previous message (if any) is used.",
                },
            },
            "required": ["progressId"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param ProgressEndEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "progressEnd"
        if body is None:
            self.body = ProgressEndEventBody()
        else:
            self.body = (
                ProgressEndEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != ProgressEndEventBody else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("invalidated")
@register
class InvalidatedEvent(BaseSchema):
    """
    This event signals that some state in the debug adapter has changed and requires that the client
    needs to re-render the data snapshot previously requested.

    Debug adapters do not have to emit this event for runtime changes like stopped or thread events
    because in that case the client refetches the new state anyway. But the event can be used for
    example to refresh the UI after rendering formatting has changed in the debug adapter.

    This event should only be sent if the corresponding capability `supportsInvalidatedEvent` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["invalidated"]},
        "body": {
            "type": "object",
            "properties": {
                "areas": {
                    "type": "array",
                    "description": "Set of logical areas that got invalidated. This property has a hint characteristic: a client can only be expected to make a 'best effort' in honoring the areas but there are no guarantees. If this property is missing, empty, or if values are not understood, the client should assume a single value `all`.",
                    "items": {"$ref": "#/definitions/InvalidatedAreas"},
                },
                "threadId": {
                    "type": "integer",
                    "description": "If specified, the client only needs to refetch data related to this thread.",
                },
                "stackFrameId": {
                    "type": "integer",
                    "description": "If specified, the client only needs to refetch data related to this stack frame (and the `threadId` is ignored).",
                },
            },
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param InvalidatedEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "invalidated"
        if body is None:
            self.body = InvalidatedEventBody()
        else:
            self.body = (
                InvalidatedEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != InvalidatedEventBody else body
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_event("memory")
@register
class MemoryEvent(BaseSchema):
    """
    This event indicates that some memory range has been updated. It should only be sent if the
    corresponding capability `supportsMemoryEvent` is true.

    Clients typically react to the event by re-issuing a `readMemory` request if they show the memory
    identified by the `memoryReference` and if the updated memory range overlaps the displayed range.
    Clients should not make assumptions how individual memory references relate to each other, so they
    should not assume that they are part of a single continuous address range and might overlap.

    Debug adapters can use this event to indicate that the contents of a memory range has changed due to
    some other request like `setVariable` or `setExpression`. Debug adapters are not expected to emit
    this event for each and every memory change of a running program, because that information is
    typically not available from debuggers and it would flood clients with too many events.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["event"]},
        "event": {"type": "string", "enum": ["memory"]},
        "body": {
            "type": "object",
            "properties": {
                "memoryReference": {"type": "string", "description": "Memory reference of a memory range that has been updated."},
                "offset": {"type": "integer", "description": "Starting offset in bytes where memory has been updated. Can be negative."},
                "count": {"type": "integer", "description": "Number of bytes updated."},
            },
            "required": ["memoryReference", "offset", "count"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, body, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string event:
        :param MemoryEventBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "event"
        self.event = "memory"
        if body is None:
            self.body = MemoryEventBody()
        else:
            self.body = MemoryEventBody(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != MemoryEventBody else body
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        event = self.event
        body = self.body
        seq = self.seq
        dct = {
            "type": type,
            "event": event,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register_request("runInTerminal")
@register
class RunInTerminalRequest(BaseSchema):
    """
    This request is sent from the debug adapter to the client to run a command in a terminal.

    This is typically used to launch the debuggee in a terminal provided by the client.

    This request should only be called if the corresponding client capability
    `supportsRunInTerminalRequest` is true.

    Client implementations of `runInTerminal` are free to run the command however they choose including
    issuing the command to a command line interpreter (aka 'shell'). Argument strings passed to the
    `runInTerminal` request must arrive verbatim in the command to be run. As a consequence, clients
    which use a shell are responsible for escaping any special shell characters in the argument strings
    to prevent them from being interpreted (and modified) by the shell.

    Some users may wish to take advantage of shell processing in the argument strings. For clients which
    implement `runInTerminal` using an intermediary shell, the `argsCanBeInterpretedByShell` property
    can be set to true. In this case the client is requested not to escape any special shell characters
    in the argument strings.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["runInTerminal"]},
        "arguments": {"type": "RunInTerminalRequestArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param RunInTerminalRequestArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "runInTerminal"
        if arguments is None:
            self.arguments = RunInTerminalRequestArguments()
        else:
            self.arguments = (
                RunInTerminalRequestArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != RunInTerminalRequestArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class RunInTerminalRequestArguments(BaseSchema):
    """
    Arguments for `runInTerminal` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "kind": {
            "type": "string",
            "enum": ["integrated", "external"],
            "description": "What kind of terminal to launch. Defaults to `integrated` if not specified.",
        },
        "title": {"type": "string", "description": "Title of the terminal."},
        "cwd": {
            "type": "string",
            "description": "Working directory for the command. For non-empty, valid paths this typically results in execution of a change directory command.",
        },
        "args": {
            "type": "array",
            "items": {"type": "string"},
            "description": "List of arguments. The first argument is the command to run.",
        },
        "env": {
            "type": "object",
            "description": "Environment key-value pairs that are added to or removed from the default environment.",
            "additionalProperties": {
                "type": ["string", "null"],
                "description": "A string is a proper value for an environment variable. The value `null` removes the variable from the environment.",
            },
        },
        "argsCanBeInterpretedByShell": {
            "type": "boolean",
            "description": "This property should only be set if the corresponding capability `supportsArgsCanBeInterpretedByShell` is True. If the client uses an intermediary shell to launch the application, then the client must not attempt to escape characters with special meanings for the shell. The user is fully responsible for escaping as needed and that arguments using special characters may not be portable across shells.",
        },
    }
    __refs__ = set(["env"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, cwd, args, kind=None, title=None, env=None, argsCanBeInterpretedByShell=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string cwd: Working directory for the command. For non-empty, valid paths this typically results in execution of a change directory command.
        :param array args: List of arguments. The first argument is the command to run.
        :param string kind: What kind of terminal to launch. Defaults to `integrated` if not specified.
        :param string title: Title of the terminal.
        :param RunInTerminalRequestArgumentsEnv env: Environment key-value pairs that are added to or removed from the default environment.
        :param boolean argsCanBeInterpretedByShell: This property should only be set if the corresponding capability `supportsArgsCanBeInterpretedByShell` is true. If the client uses an intermediary shell to launch the application, then the client must not attempt to escape characters with special meanings for the shell. The user is fully responsible for escaping as needed and that arguments using special characters may not be portable across shells.
        """
        self.cwd = cwd
        self.args = args
        self.kind = kind
        self.title = title
        if env is None:
            self.env = RunInTerminalRequestArgumentsEnv()
        else:
            self.env = (
                RunInTerminalRequestArgumentsEnv(update_ids_from_dap=update_ids_from_dap, **env)
                if env.__class__ != RunInTerminalRequestArgumentsEnv
                else env
            )
        self.argsCanBeInterpretedByShell = argsCanBeInterpretedByShell
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        cwd = self.cwd
        args = self.args
        if args and hasattr(args[0], "to_dict"):
            args = [x.to_dict() for x in args]
        kind = self.kind
        title = self.title
        env = self.env
        argsCanBeInterpretedByShell = self.argsCanBeInterpretedByShell
        dct = {
            "cwd": cwd,
            "args": args,
        }
        if kind is not None:
            dct["kind"] = kind
        if title is not None:
            dct["title"] = title
        if env is not None:
            dct["env"] = env.to_dict(update_ids_to_dap=update_ids_to_dap)
        if argsCanBeInterpretedByShell is not None:
            dct["argsCanBeInterpretedByShell"] = argsCanBeInterpretedByShell
        dct.update(self.kwargs)
        return dct


@register_response("runInTerminal")
@register
class RunInTerminalResponse(BaseSchema):
    """
    Response to `runInTerminal` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "processId": {
                    "type": "integer",
                    "description": "The process ID. The value should be less than or equal to 2147483647 (2^31-1).",
                },
                "shellProcessId": {
                    "type": "integer",
                    "description": "The process ID of the terminal shell. The value should be less than or equal to 2147483647 (2^31-1).",
                },
            },
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param RunInTerminalResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = RunInTerminalResponseBody()
        else:
            self.body = (
                RunInTerminalResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != RunInTerminalResponseBody
                else body
            )
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("startDebugging")
@register
class StartDebuggingRequest(BaseSchema):
    """
    This request is sent from the debug adapter to the client to start a new debug session of the same
    type as the caller.

    This request should only be sent if the corresponding client capability
    `supportsStartDebuggingRequest` is true.

    A client implementation of `startDebugging` should start a new debug session (of the same type as
    the caller) in the same way that the caller's session was started. If the client supports
    hierarchical debug sessions, the newly created session can be treated as a child of the caller
    session.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["startDebugging"]},
        "arguments": {"type": "StartDebuggingRequestArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param StartDebuggingRequestArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "startDebugging"
        if arguments is None:
            self.arguments = StartDebuggingRequestArguments()
        else:
            self.arguments = (
                StartDebuggingRequestArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != StartDebuggingRequestArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class StartDebuggingRequestArguments(BaseSchema):
    """
    Arguments for `startDebugging` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "configuration": {
            "type": "object",
            "additionalProperties": True,
            "description": "Arguments passed to the new debug session. The arguments must only contain properties understood by the `launch` or `attach` requests of the debug adapter and they must not contain any client-specific properties (e.g. `type`) or client-specific features (e.g. substitutable 'variables').",
        },
        "request": {
            "type": "string",
            "enum": ["launch", "attach"],
            "description": "Indicates whether the new debug session should be started with a `launch` or `attach` request.",
        },
    }
    __refs__ = set(["configuration"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, configuration, request, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param StartDebuggingRequestArgumentsConfiguration configuration: Arguments passed to the new debug session. The arguments must only contain properties understood by the `launch` or `attach` requests of the debug adapter and they must not contain any client-specific properties (e.g. `type`) or client-specific features (e.g. substitutable 'variables').
        :param string request: Indicates whether the new debug session should be started with a `launch` or `attach` request.
        """
        if configuration is None:
            self.configuration = StartDebuggingRequestArgumentsConfiguration()
        else:
            self.configuration = (
                StartDebuggingRequestArgumentsConfiguration(update_ids_from_dap=update_ids_from_dap, **configuration)
                if configuration.__class__ != StartDebuggingRequestArgumentsConfiguration
                else configuration
            )
        self.request = request
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        configuration = self.configuration
        request = self.request
        dct = {
            "configuration": configuration.to_dict(update_ids_to_dap=update_ids_to_dap),
            "request": request,
        }
        dct.update(self.kwargs)
        return dct


@register_response("startDebugging")
@register
class StartDebuggingResponse(BaseSchema):
    """
    Response to `startDebugging` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("initialize")
@register
class InitializeRequest(BaseSchema):
    """
    The `initialize` request is sent as the first request from the client to the debug adapter in order
    to configure it with client capabilities and to retrieve capabilities from the debug adapter.

    Until the debug adapter has responded with an `initialize` response, the client must not send any
    additional requests or events to the debug adapter.

    In addition the debug adapter is not allowed to send any requests or events to the client until it
    has responded with an `initialize` response.

    The `initialize` request may only be sent once.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["initialize"]},
        "arguments": {"type": "InitializeRequestArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param InitializeRequestArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "initialize"
        if arguments is None:
            self.arguments = InitializeRequestArguments()
        else:
            self.arguments = (
                InitializeRequestArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != InitializeRequestArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class InitializeRequestArguments(BaseSchema):
    """
    Arguments for `initialize` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "clientID": {"type": "string", "description": "The ID of the client using this adapter."},
        "clientName": {"type": "string", "description": "The human-readable name of the client using this adapter."},
        "adapterID": {"type": "string", "description": "The ID of the debug adapter."},
        "locale": {"type": "string", "description": "The ISO-639 locale of the client using this adapter, e.g. en-US or de-CH."},
        "linesStartAt1": {"type": "boolean", "description": "If True all line numbers are 1-based (default)."},
        "columnsStartAt1": {"type": "boolean", "description": "If True all column numbers are 1-based (default)."},
        "pathFormat": {
            "type": "string",
            "_enum": ["path", "uri"],
            "description": "Determines in what format paths are specified. The default is `path`, which is the native format.",
        },
        "supportsVariableType": {"type": "boolean", "description": "Client supports the `type` attribute for variables."},
        "supportsVariablePaging": {"type": "boolean", "description": "Client supports the paging of variables."},
        "supportsRunInTerminalRequest": {"type": "boolean", "description": "Client supports the `runInTerminal` request."},
        "supportsMemoryReferences": {"type": "boolean", "description": "Client supports memory references."},
        "supportsProgressReporting": {"type": "boolean", "description": "Client supports progress reporting."},
        "supportsInvalidatedEvent": {"type": "boolean", "description": "Client supports the `invalidated` event."},
        "supportsMemoryEvent": {"type": "boolean", "description": "Client supports the `memory` event."},
        "supportsArgsCanBeInterpretedByShell": {
            "type": "boolean",
            "description": "Client supports the `argsCanBeInterpretedByShell` attribute on the `runInTerminal` request.",
        },
        "supportsStartDebuggingRequest": {"type": "boolean", "description": "Client supports the `startDebugging` request."},
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(
        self,
        adapterID,
        clientID=None,
        clientName=None,
        locale=None,
        linesStartAt1=None,
        columnsStartAt1=None,
        pathFormat=None,
        supportsVariableType=None,
        supportsVariablePaging=None,
        supportsRunInTerminalRequest=None,
        supportsMemoryReferences=None,
        supportsProgressReporting=None,
        supportsInvalidatedEvent=None,
        supportsMemoryEvent=None,
        supportsArgsCanBeInterpretedByShell=None,
        supportsStartDebuggingRequest=None,
        update_ids_from_dap=False,
        **kwargs,
    ):  # noqa (update_ids_from_dap may be unused)
        """
        :param string adapterID: The ID of the debug adapter.
        :param string clientID: The ID of the client using this adapter.
        :param string clientName: The human-readable name of the client using this adapter.
        :param string locale: The ISO-639 locale of the client using this adapter, e.g. en-US or de-CH.
        :param boolean linesStartAt1: If true all line numbers are 1-based (default).
        :param boolean columnsStartAt1: If true all column numbers are 1-based (default).
        :param string pathFormat: Determines in what format paths are specified. The default is `path`, which is the native format.
        :param boolean supportsVariableType: Client supports the `type` attribute for variables.
        :param boolean supportsVariablePaging: Client supports the paging of variables.
        :param boolean supportsRunInTerminalRequest: Client supports the `runInTerminal` request.
        :param boolean supportsMemoryReferences: Client supports memory references.
        :param boolean supportsProgressReporting: Client supports progress reporting.
        :param boolean supportsInvalidatedEvent: Client supports the `invalidated` event.
        :param boolean supportsMemoryEvent: Client supports the `memory` event.
        :param boolean supportsArgsCanBeInterpretedByShell: Client supports the `argsCanBeInterpretedByShell` attribute on the `runInTerminal` request.
        :param boolean supportsStartDebuggingRequest: Client supports the `startDebugging` request.
        """
        self.adapterID = adapterID
        self.clientID = clientID
        self.clientName = clientName
        self.locale = locale
        self.linesStartAt1 = linesStartAt1
        self.columnsStartAt1 = columnsStartAt1
        self.pathFormat = pathFormat
        self.supportsVariableType = supportsVariableType
        self.supportsVariablePaging = supportsVariablePaging
        self.supportsRunInTerminalRequest = supportsRunInTerminalRequest
        self.supportsMemoryReferences = supportsMemoryReferences
        self.supportsProgressReporting = supportsProgressReporting
        self.supportsInvalidatedEvent = supportsInvalidatedEvent
        self.supportsMemoryEvent = supportsMemoryEvent
        self.supportsArgsCanBeInterpretedByShell = supportsArgsCanBeInterpretedByShell
        self.supportsStartDebuggingRequest = supportsStartDebuggingRequest
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        adapterID = self.adapterID
        clientID = self.clientID
        clientName = self.clientName
        locale = self.locale
        linesStartAt1 = self.linesStartAt1
        columnsStartAt1 = self.columnsStartAt1
        pathFormat = self.pathFormat
        supportsVariableType = self.supportsVariableType
        supportsVariablePaging = self.supportsVariablePaging
        supportsRunInTerminalRequest = self.supportsRunInTerminalRequest
        supportsMemoryReferences = self.supportsMemoryReferences
        supportsProgressReporting = self.supportsProgressReporting
        supportsInvalidatedEvent = self.supportsInvalidatedEvent
        supportsMemoryEvent = self.supportsMemoryEvent
        supportsArgsCanBeInterpretedByShell = self.supportsArgsCanBeInterpretedByShell
        supportsStartDebuggingRequest = self.supportsStartDebuggingRequest
        dct = {
            "adapterID": adapterID,
        }
        if clientID is not None:
            dct["clientID"] = clientID
        if clientName is not None:
            dct["clientName"] = clientName
        if locale is not None:
            dct["locale"] = locale
        if linesStartAt1 is not None:
            dct["linesStartAt1"] = linesStartAt1
        if columnsStartAt1 is not None:
            dct["columnsStartAt1"] = columnsStartAt1
        if pathFormat is not None:
            dct["pathFormat"] = pathFormat
        if supportsVariableType is not None:
            dct["supportsVariableType"] = supportsVariableType
        if supportsVariablePaging is not None:
            dct["supportsVariablePaging"] = supportsVariablePaging
        if supportsRunInTerminalRequest is not None:
            dct["supportsRunInTerminalRequest"] = supportsRunInTerminalRequest
        if supportsMemoryReferences is not None:
            dct["supportsMemoryReferences"] = supportsMemoryReferences
        if supportsProgressReporting is not None:
            dct["supportsProgressReporting"] = supportsProgressReporting
        if supportsInvalidatedEvent is not None:
            dct["supportsInvalidatedEvent"] = supportsInvalidatedEvent
        if supportsMemoryEvent is not None:
            dct["supportsMemoryEvent"] = supportsMemoryEvent
        if supportsArgsCanBeInterpretedByShell is not None:
            dct["supportsArgsCanBeInterpretedByShell"] = supportsArgsCanBeInterpretedByShell
        if supportsStartDebuggingRequest is not None:
            dct["supportsStartDebuggingRequest"] = supportsStartDebuggingRequest
        dct.update(self.kwargs)
        return dct


@register_response("initialize")
@register
class InitializeResponse(BaseSchema):
    """
    Response to `initialize` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {"description": "The capabilities of this debug adapter.", "type": "Capabilities"},
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param Capabilities body: The capabilities of this debug adapter.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        if body is None:
            self.body = Capabilities()
        else:
            self.body = Capabilities(update_ids_from_dap=update_ids_from_dap, **body) if body.__class__ != Capabilities else body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register_request("configurationDone")
@register
class ConfigurationDoneRequest(BaseSchema):
    """
    This request indicates that the client has finished initialization of the debug adapter.

    So it is the last request in the sequence of configuration requests (which was started by the
    `initialized` event).

    Clients should only call this request if the corresponding capability
    `supportsConfigurationDoneRequest` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["configurationDone"]},
        "arguments": {"type": "ConfigurationDoneArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param ConfigurationDoneArguments arguments:
        """
        self.type = "request"
        self.command = "configurationDone"
        self.seq = seq
        if arguments is None:
            self.arguments = ConfigurationDoneArguments()
        else:
            self.arguments = (
                ConfigurationDoneArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != ConfigurationDoneArguments
                else arguments
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register
class ConfigurationDoneArguments(BaseSchema):
    """
    Arguments for `configurationDone` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {}
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """ """

        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        dct = {}
        dct.update(self.kwargs)
        return dct


@register_response("configurationDone")
@register
class ConfigurationDoneResponse(BaseSchema):
    """
    Response to `configurationDone` request. This is just an acknowledgement, so no body field is
    required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("launch")
@register
class LaunchRequest(BaseSchema):
    """
    This launch request is sent from the client to the debug adapter to start the debuggee with or
    without debugging (if `noDebug` is true).

    Since launching is debugger/runtime specific, the arguments for this request are not part of this
    specification.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["launch"]},
        "arguments": {"type": "LaunchRequestArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param LaunchRequestArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "launch"
        if arguments is None:
            self.arguments = LaunchRequestArguments()
        else:
            self.arguments = (
                LaunchRequestArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != LaunchRequestArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class LaunchRequestArguments(BaseSchema):
    """
    Arguments for `launch` request. Additional attributes are implementation specific.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "noDebug": {"type": "boolean", "description": "If True, the launch request should launch the program without enabling debugging."},
        "__restart": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Arbitrary data from the previous, restarted session.\nThe data is sent as the `restart` attribute of the `terminated` event.\nThe client should leave the data intact.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, noDebug=None, __restart=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param boolean noDebug: If true, the launch request should launch the program without enabling debugging.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] __restart: Arbitrary data from the previous, restarted session.
        The data is sent as the `restart` attribute of the `terminated` event.
        The client should leave the data intact.
        """
        self.noDebug = noDebug
        self.__restart = __restart
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        noDebug = self.noDebug
        __restart = self.__restart
        dct = {}
        if noDebug is not None:
            dct["noDebug"] = noDebug
        if __restart is not None:
            dct["__restart"] = __restart
        dct.update(self.kwargs)
        return dct


@register_response("launch")
@register
class LaunchResponse(BaseSchema):
    """
    Response to `launch` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("attach")
@register
class AttachRequest(BaseSchema):
    """
    The `attach` request is sent from the client to the debug adapter to attach to a debuggee that is
    already running.

    Since attaching is debugger/runtime specific, the arguments for this request are not part of this
    specification.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["attach"]},
        "arguments": {"type": "AttachRequestArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param AttachRequestArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "attach"
        if arguments is None:
            self.arguments = AttachRequestArguments()
        else:
            self.arguments = (
                AttachRequestArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != AttachRequestArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class AttachRequestArguments(BaseSchema):
    """
    Arguments for `attach` request. Additional attributes are implementation specific.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "__restart": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Arbitrary data from the previous, restarted session.\nThe data is sent as the `restart` attribute of the `terminated` event.\nThe client should leave the data intact.",
        }
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, __restart=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] __restart: Arbitrary data from the previous, restarted session.
        The data is sent as the `restart` attribute of the `terminated` event.
        The client should leave the data intact.
        """
        self.__restart = __restart
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        __restart = self.__restart
        dct = {}
        if __restart is not None:
            dct["__restart"] = __restart
        dct.update(self.kwargs)
        return dct


@register_response("attach")
@register
class AttachResponse(BaseSchema):
    """
    Response to `attach` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("restart")
@register
class RestartRequest(BaseSchema):
    """
    Restarts a debug session. Clients should only call this request if the corresponding capability
    `supportsRestartRequest` is true.

    If the capability is missing or has the value false, a typical client emulates `restart` by
    terminating the debug adapter first and then launching it anew.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["restart"]},
        "arguments": {"type": "RestartArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param RestartArguments arguments:
        """
        self.type = "request"
        self.command = "restart"
        self.seq = seq
        if arguments is None:
            self.arguments = RestartArguments()
        else:
            self.arguments = (
                RestartArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != RestartArguments
                else arguments
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register
class RestartArguments(BaseSchema):
    """
    Arguments for `restart` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "arguments": {
            "oneOf": [{"$ref": "#/definitions/LaunchRequestArguments"}, {"$ref": "#/definitions/AttachRequestArguments"}],
            "description": "The latest version of the `launch` or `attach` configuration.",
        }
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param TypeNA arguments: The latest version of the `launch` or `attach` configuration.
        """
        self.arguments = arguments
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        arguments = self.arguments
        dct = {}
        if arguments is not None:
            dct["arguments"] = arguments
        dct.update(self.kwargs)
        return dct


@register_response("restart")
@register
class RestartResponse(BaseSchema):
    """
    Response to `restart` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("disconnect")
@register
class DisconnectRequest(BaseSchema):
    """
    The `disconnect` request asks the debug adapter to disconnect from the debuggee (thus ending the
    debug session) and then to shut down itself (the debug adapter).

    In addition, the debug adapter must terminate the debuggee if it was started with the `launch`
    request. If an `attach` request was used to connect to the debuggee, then the debug adapter must not
    terminate the debuggee.

    This implicit behavior of when to terminate the debuggee can be overridden with the
    `terminateDebuggee` argument (which is only supported by a debug adapter if the corresponding
    capability `supportTerminateDebuggee` is true).

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["disconnect"]},
        "arguments": {"type": "DisconnectArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param DisconnectArguments arguments:
        """
        self.type = "request"
        self.command = "disconnect"
        self.seq = seq
        if arguments is None:
            self.arguments = DisconnectArguments()
        else:
            self.arguments = (
                DisconnectArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != DisconnectArguments
                else arguments
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register
class DisconnectArguments(BaseSchema):
    """
    Arguments for `disconnect` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "restart": {
            "type": "boolean",
            "description": "A value of True indicates that this `disconnect` request is part of a restart sequence.",
        },
        "terminateDebuggee": {
            "type": "boolean",
            "description": "Indicates whether the debuggee should be terminated when the debugger is disconnected.\nIf unspecified, the debug adapter is free to do whatever it thinks is best.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportTerminateDebuggee` is True.",
        },
        "suspendDebuggee": {
            "type": "boolean",
            "description": "Indicates whether the debuggee should stay suspended when the debugger is disconnected.\nIf unspecified, the debuggee should resume execution.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportSuspendDebuggee` is True.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, restart=None, terminateDebuggee=None, suspendDebuggee=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param boolean restart: A value of true indicates that this `disconnect` request is part of a restart sequence.
        :param boolean terminateDebuggee: Indicates whether the debuggee should be terminated when the debugger is disconnected.
        If unspecified, the debug adapter is free to do whatever it thinks is best.
        The attribute is only honored by a debug adapter if the corresponding capability `supportTerminateDebuggee` is true.
        :param boolean suspendDebuggee: Indicates whether the debuggee should stay suspended when the debugger is disconnected.
        If unspecified, the debuggee should resume execution.
        The attribute is only honored by a debug adapter if the corresponding capability `supportSuspendDebuggee` is true.
        """
        self.restart = restart
        self.terminateDebuggee = terminateDebuggee
        self.suspendDebuggee = suspendDebuggee
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        restart = self.restart
        terminateDebuggee = self.terminateDebuggee
        suspendDebuggee = self.suspendDebuggee
        dct = {}
        if restart is not None:
            dct["restart"] = restart
        if terminateDebuggee is not None:
            dct["terminateDebuggee"] = terminateDebuggee
        if suspendDebuggee is not None:
            dct["suspendDebuggee"] = suspendDebuggee
        dct.update(self.kwargs)
        return dct


@register_response("disconnect")
@register
class DisconnectResponse(BaseSchema):
    """
    Response to `disconnect` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("terminate")
@register
class TerminateRequest(BaseSchema):
    """
    The `terminate` request is sent from the client to the debug adapter in order to shut down the
    debuggee gracefully. Clients should only call this request if the capability
    `supportsTerminateRequest` is true.

    Typically a debug adapter implements `terminate` by sending a software signal which the debuggee
    intercepts in order to clean things up properly before terminating itself.

    Please note that this request does not directly affect the state of the debug session: if the
    debuggee decides to veto the graceful shutdown for any reason by not terminating itself, then the
    debug session just continues.

    Clients can surface the `terminate` request as an explicit command or they can integrate it into a
    two stage Stop command that first sends `terminate` to request a graceful shutdown, and if that
    fails uses `disconnect` for a forceful shutdown.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["terminate"]},
        "arguments": {"type": "TerminateArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param TerminateArguments arguments:
        """
        self.type = "request"
        self.command = "terminate"
        self.seq = seq
        if arguments is None:
            self.arguments = TerminateArguments()
        else:
            self.arguments = (
                TerminateArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != TerminateArguments
                else arguments
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register
class TerminateArguments(BaseSchema):
    """
    Arguments for `terminate` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "restart": {
            "type": "boolean",
            "description": "A value of True indicates that this `terminate` request is part of a restart sequence.",
        }
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, restart=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param boolean restart: A value of true indicates that this `terminate` request is part of a restart sequence.
        """
        self.restart = restart
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        restart = self.restart
        dct = {}
        if restart is not None:
            dct["restart"] = restart
        dct.update(self.kwargs)
        return dct


@register_response("terminate")
@register
class TerminateResponse(BaseSchema):
    """
    Response to `terminate` request. This is just an acknowledgement, so no body field is required.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": ["array", "boolean", "integer", "null", "number", "object", "string"],
            "description": "Contains request result if success is True and error details if success is false.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'] body: Contains request result if success is true and error details if success is false.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        self.body = body
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body
        dct.update(self.kwargs)
        return dct


@register_request("breakpointLocations")
@register
class BreakpointLocationsRequest(BaseSchema):
    """
    The `breakpointLocations` request returns all possible locations for source breakpoints in a given
    range.

    Clients should only call this request if the corresponding capability
    `supportsBreakpointLocationsRequest` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["breakpointLocations"]},
        "arguments": {"type": "BreakpointLocationsArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, seq=-1, arguments=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param BreakpointLocationsArguments arguments:
        """
        self.type = "request"
        self.command = "breakpointLocations"
        self.seq = seq
        if arguments is None:
            self.arguments = BreakpointLocationsArguments()
        else:
            self.arguments = (
                BreakpointLocationsArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != BreakpointLocationsArguments
                else arguments
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        seq = self.seq
        arguments = self.arguments
        dct = {
            "type": type,
            "command": command,
            "seq": seq,
        }
        if arguments is not None:
            dct["arguments"] = arguments.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register
class BreakpointLocationsArguments(BaseSchema):
    """
    Arguments for `breakpointLocations` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "source": {
            "description": "The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.",
            "type": "Source",
        },
        "line": {
            "type": "integer",
            "description": "Start line of range to search possible breakpoint locations in. If only the line is specified, the request returns all possible locations in that line.",
        },
        "column": {
            "type": "integer",
            "description": "Start position within `line` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed.",
        },
        "endLine": {
            "type": "integer",
            "description": "End line of range to search possible breakpoint locations in. If no end line is given, then the end line is assumed to be the start line.",
        },
        "endColumn": {
            "type": "integer",
            "description": "End position within `endLine` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no end column is given, the last position in the end line is assumed.",
        },
    }
    __refs__ = set(["source"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, source, line, column=None, endLine=None, endColumn=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param Source source: The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.
        :param integer line: Start line of range to search possible breakpoint locations in. If only the line is specified, the request returns all possible locations in that line.
        :param integer column: Start position within `line` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no column is given, the first position in the start line is assumed.
        :param integer endLine: End line of range to search possible breakpoint locations in. If no end line is given, then the end line is assumed to be the start line.
        :param integer endColumn: End position within `endLine` to search possible breakpoint locations in. It is measured in UTF-16 code units and the client capability `columnsStartAt1` determines whether it is 0- or 1-based. If no end column is given, the last position in the end line is assumed.
        """
        if source is None:
            self.source = Source()
        else:
            self.source = Source(update_ids_from_dap=update_ids_from_dap, **source) if source.__class__ != Source else source
        self.line = line
        self.column = column
        self.endLine = endLine
        self.endColumn = endColumn
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        source = self.source
        line = self.line
        column = self.column
        endLine = self.endLine
        endColumn = self.endColumn
        dct = {
            "source": source.to_dict(update_ids_to_dap=update_ids_to_dap),
            "line": line,
        }
        if column is not None:
            dct["column"] = column
        if endLine is not None:
            dct["endLine"] = endLine
        if endColumn is not None:
            dct["endColumn"] = endColumn
        dct.update(self.kwargs)
        return dct


@register_response("breakpointLocations")
@register
class BreakpointLocationsResponse(BaseSchema):
    """
    Response to `breakpointLocations` request.

    Contains possible locations for source breakpoints.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "breakpoints": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/BreakpointLocation"},
                    "description": "Sorted set of possible breakpoint locations.",
                }
            },
            "required": ["breakpoints"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param BreakpointLocationsResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = BreakpointLocationsResponseBody()
        else:
            self.body = (
                BreakpointLocationsResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != BreakpointLocationsResponseBody
                else body
            )
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("setBreakpoints")
@register
class SetBreakpointsRequest(BaseSchema):
    """
    Sets multiple breakpoints for a single source and clears all previous breakpoints in that source.

    To clear all breakpoint for a source, specify an empty array.

    When a breakpoint is hit, a `stopped` event (with reason `breakpoint`) is generated.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["setBreakpoints"]},
        "arguments": {"type": "SetBreakpointsArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param SetBreakpointsArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "setBreakpoints"
        if arguments is None:
            self.arguments = SetBreakpointsArguments()
        else:
            self.arguments = (
                SetBreakpointsArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != SetBreakpointsArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class SetBreakpointsArguments(BaseSchema):
    """
    Arguments for `setBreakpoints` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "source": {
            "description": "The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.",
            "type": "Source",
        },
        "breakpoints": {
            "type": "array",
            "items": {"$ref": "#/definitions/SourceBreakpoint"},
            "description": "The code locations of the breakpoints.",
        },
        "lines": {"type": "array", "items": {"type": "integer"}, "description": "Deprecated: The code locations of the breakpoints."},
        "sourceModified": {
            "type": "boolean",
            "description": "A value of True indicates that the underlying source has been modified which results in new breakpoint locations.",
        },
    }
    __refs__ = set(["source"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, source, breakpoints=None, lines=None, sourceModified=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param Source source: The source location of the breakpoints; either `source.path` or `source.sourceReference` must be specified.
        :param array breakpoints: The code locations of the breakpoints.
        :param array lines: Deprecated: The code locations of the breakpoints.
        :param boolean sourceModified: A value of true indicates that the underlying source has been modified which results in new breakpoint locations.
        """
        if source is None:
            self.source = Source()
        else:
            self.source = Source(update_ids_from_dap=update_ids_from_dap, **source) if source.__class__ != Source else source
        self.breakpoints = breakpoints
        if update_ids_from_dap and self.breakpoints:
            for o in self.breakpoints:
                SourceBreakpoint.update_dict_ids_from_dap(o)
        self.lines = lines
        self.sourceModified = sourceModified
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        source = self.source
        breakpoints = self.breakpoints
        if breakpoints and hasattr(breakpoints[0], "to_dict"):
            breakpoints = [x.to_dict() for x in breakpoints]
        lines = self.lines
        if lines and hasattr(lines[0], "to_dict"):
            lines = [x.to_dict() for x in lines]
        sourceModified = self.sourceModified
        dct = {
            "source": source.to_dict(update_ids_to_dap=update_ids_to_dap),
        }
        if breakpoints is not None:
            dct["breakpoints"] = (
                [SourceBreakpoint.update_dict_ids_to_dap(o) for o in breakpoints] if (update_ids_to_dap and breakpoints) else breakpoints
            )
        if lines is not None:
            dct["lines"] = lines
        if sourceModified is not None:
            dct["sourceModified"] = sourceModified
        dct.update(self.kwargs)
        return dct


@register_response("setBreakpoints")
@register
class SetBreakpointsResponse(BaseSchema):
    """
    Response to `setBreakpoints` request.

    Returned is information about each breakpoint created by this request.

    This includes the actual code location and whether the breakpoint could be verified.

    The breakpoints returned are in the same order as the elements of the `breakpoints`

    (or the deprecated `lines`) array in the arguments.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "breakpoints": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/Breakpoint"},
                    "description": "Information about the breakpoints.\nThe array elements are in the same order as the elements of the `breakpoints` (or the deprecated `lines`) array in the arguments.",
                }
            },
            "required": ["breakpoints"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param SetBreakpointsResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = SetBreakpointsResponseBody()
        else:
            self.body = (
                SetBreakpointsResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != SetBreakpointsResponseBody
                else body
            )
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("setFunctionBreakpoints")
@register
class SetFunctionBreakpointsRequest(BaseSchema):
    """
    Replaces all existing function breakpoints with new function breakpoints.

    To clear all function breakpoints, specify an empty array.

    When a function breakpoint is hit, a `stopped` event (with reason `function breakpoint`) is
    generated.

    Clients should only call this request if the corresponding capability `supportsFunctionBreakpoints`
    is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["setFunctionBreakpoints"]},
        "arguments": {"type": "SetFunctionBreakpointsArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param SetFunctionBreakpointsArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "setFunctionBreakpoints"
        if arguments is None:
            self.arguments = SetFunctionBreakpointsArguments()
        else:
            self.arguments = (
                SetFunctionBreakpointsArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != SetFunctionBreakpointsArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class SetFunctionBreakpointsArguments(BaseSchema):
    """
    Arguments for `setFunctionBreakpoints` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "breakpoints": {
            "type": "array",
            "items": {"$ref": "#/definitions/FunctionBreakpoint"},
            "description": "The function names of the breakpoints.",
        }
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, breakpoints, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param array breakpoints: The function names of the breakpoints.
        """
        self.breakpoints = breakpoints
        if update_ids_from_dap and self.breakpoints:
            for o in self.breakpoints:
                FunctionBreakpoint.update_dict_ids_from_dap(o)
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        breakpoints = self.breakpoints
        if breakpoints and hasattr(breakpoints[0], "to_dict"):
            breakpoints = [x.to_dict() for x in breakpoints]
        dct = {
            "breakpoints": [FunctionBreakpoint.update_dict_ids_to_dap(o) for o in breakpoints]
            if (update_ids_to_dap and breakpoints)
            else breakpoints,
        }
        dct.update(self.kwargs)
        return dct


@register_response("setFunctionBreakpoints")
@register
class SetFunctionBreakpointsResponse(BaseSchema):
    """
    Response to `setFunctionBreakpoints` request.

    Returned is information about each breakpoint created by this request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "breakpoints": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/Breakpoint"},
                    "description": "Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.",
                }
            },
            "required": ["breakpoints"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param SetFunctionBreakpointsResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = SetFunctionBreakpointsResponseBody()
        else:
            self.body = (
                SetFunctionBreakpointsResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != SetFunctionBreakpointsResponseBody
                else body
            )
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("setExceptionBreakpoints")
@register
class SetExceptionBreakpointsRequest(BaseSchema):
    """
    The request configures the debugger's response to thrown exceptions.

    If an exception is configured to break, a `stopped` event is fired (with reason `exception`).

    Clients should only call this request if the corresponding capability `exceptionBreakpointFilters`
    returns one or more filters.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["setExceptionBreakpoints"]},
        "arguments": {"type": "SetExceptionBreakpointsArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param SetExceptionBreakpointsArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "setExceptionBreakpoints"
        if arguments is None:
            self.arguments = SetExceptionBreakpointsArguments()
        else:
            self.arguments = (
                SetExceptionBreakpointsArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != SetExceptionBreakpointsArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class SetExceptionBreakpointsArguments(BaseSchema):
    """
    Arguments for `setExceptionBreakpoints` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "filters": {
            "type": "array",
            "items": {"type": "string"},
            "description": "Set of exception filters specified by their ID. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. The `filter` and `filterOptions` sets are additive.",
        },
        "filterOptions": {
            "type": "array",
            "items": {"$ref": "#/definitions/ExceptionFilterOptions"},
            "description": "Set of exception filters and their options. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. This attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionFilterOptions` is True. The `filter` and `filterOptions` sets are additive.",
        },
        "exceptionOptions": {
            "type": "array",
            "items": {"$ref": "#/definitions/ExceptionOptions"},
            "description": "Configuration options for selected exceptions.\nThe attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionOptions` is True.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, filters, filterOptions=None, exceptionOptions=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param array filters: Set of exception filters specified by their ID. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. The `filter` and `filterOptions` sets are additive.
        :param array filterOptions: Set of exception filters and their options. The set of all possible exception filters is defined by the `exceptionBreakpointFilters` capability. This attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionFilterOptions` is true. The `filter` and `filterOptions` sets are additive.
        :param array exceptionOptions: Configuration options for selected exceptions.
        The attribute is only honored by a debug adapter if the corresponding capability `supportsExceptionOptions` is true.
        """
        self.filters = filters
        self.filterOptions = filterOptions
        if update_ids_from_dap and self.filterOptions:
            for o in self.filterOptions:
                ExceptionFilterOptions.update_dict_ids_from_dap(o)
        self.exceptionOptions = exceptionOptions
        if update_ids_from_dap and self.exceptionOptions:
            for o in self.exceptionOptions:
                ExceptionOptions.update_dict_ids_from_dap(o)
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        filters = self.filters
        if filters and hasattr(filters[0], "to_dict"):
            filters = [x.to_dict() for x in filters]
        filterOptions = self.filterOptions
        if filterOptions and hasattr(filterOptions[0], "to_dict"):
            filterOptions = [x.to_dict() for x in filterOptions]
        exceptionOptions = self.exceptionOptions
        if exceptionOptions and hasattr(exceptionOptions[0], "to_dict"):
            exceptionOptions = [x.to_dict() for x in exceptionOptions]
        dct = {
            "filters": filters,
        }
        if filterOptions is not None:
            dct["filterOptions"] = (
                [ExceptionFilterOptions.update_dict_ids_to_dap(o) for o in filterOptions]
                if (update_ids_to_dap and filterOptions)
                else filterOptions
            )
        if exceptionOptions is not None:
            dct["exceptionOptions"] = (
                [ExceptionOptions.update_dict_ids_to_dap(o) for o in exceptionOptions]
                if (update_ids_to_dap and exceptionOptions)
                else exceptionOptions
            )
        dct.update(self.kwargs)
        return dct


@register_response("setExceptionBreakpoints")
@register
class SetExceptionBreakpointsResponse(BaseSchema):
    """
    Response to `setExceptionBreakpoints` request.

    The response contains an array of `Breakpoint` objects with information about each exception
    breakpoint or filter. The `Breakpoint` objects are in the same order as the elements of the
    `filters`, `filterOptions`, `exceptionOptions` arrays given as arguments. If both `filters` and
    `filterOptions` are given, the returned array must start with `filters` information first, followed
    by `filterOptions` information.

    The `verified` property of a `Breakpoint` object signals whether the exception breakpoint or filter
    could be successfully created and whether the condition is valid. In case of an error the `message`
    property explains the problem. The `id` property can be used to introduce a unique ID for the
    exception breakpoint or filter so that it can be updated subsequently by sending breakpoint events.

    For backward compatibility both the `breakpoints` array and the enclosing `body` are optional. If
    these elements are missing a client is not able to show problems for individual exception
    breakpoints or filters.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "breakpoints": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/Breakpoint"},
                    "description": "Information about the exception breakpoints or filters.\nThe breakpoints returned are in the same order as the elements of the `filters`, `filterOptions`, `exceptionOptions` arrays in the arguments. If both `filters` and `filterOptions` are given, the returned array must start with `filters` information first, followed by `filterOptions` information.",
                }
            },
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, seq=-1, message=None, body=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        :param SetExceptionBreakpointsResponseBody body:
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        self.seq = seq
        self.message = message
        if body is None:
            self.body = SetExceptionBreakpointsResponseBody()
        else:
            self.body = (
                SetExceptionBreakpointsResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != SetExceptionBreakpointsResponseBody
                else body
            )
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        seq = self.seq
        message = self.message
        body = self.body
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        if body is not None:
            dct["body"] = body.to_dict(update_ids_to_dap=update_ids_to_dap)
        dct.update(self.kwargs)
        return dct


@register_request("dataBreakpointInfo")
@register
class DataBreakpointInfoRequest(BaseSchema):
    """
    Obtains information on a possible data breakpoint that could be set on an expression or variable.

    Clients should only call this request if the corresponding capability `supportsDataBreakpoints` is
    true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["dataBreakpointInfo"]},
        "arguments": {"type": "DataBreakpointInfoArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param DataBreakpointInfoArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "dataBreakpointInfo"
        if arguments is None:
            self.arguments = DataBreakpointInfoArguments()
        else:
            self.arguments = (
                DataBreakpointInfoArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != DataBreakpointInfoArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class DataBreakpointInfoArguments(BaseSchema):
    """
    Arguments for `dataBreakpointInfo` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "variablesReference": {
            "type": "integer",
            "description": "Reference to the variable container if the data breakpoint is requested for a child of the container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.",
        },
        "name": {
            "type": "string",
            "description": "The name of the variable's child to obtain data breakpoint information for.\nIf `variablesReference` isn't specified, this can be an expression.",
        },
        "frameId": {
            "type": "integer",
            "description": "When `name` is an expression, evaluate it in the scope of this stack frame. If not specified, the expression is evaluated in the global scope. When `variablesReference` is specified, this property has no effect.",
        },
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, name, variablesReference=None, frameId=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string name: The name of the variable's child to obtain data breakpoint information for.
        If `variablesReference` isn't specified, this can be an expression.
        :param integer variablesReference: Reference to the variable container if the data breakpoint is requested for a child of the container. The `variablesReference` must have been obtained in the current suspended state. See 'Lifetime of Object References' in the Overview section for details.
        :param integer frameId: When `name` is an expression, evaluate it in the scope of this stack frame. If not specified, the expression is evaluated in the global scope. When `variablesReference` is specified, this property has no effect.
        """
        self.name = name
        self.variablesReference = variablesReference
        self.frameId = frameId
        if update_ids_from_dap:
            self.variablesReference = self._translate_id_from_dap(self.variablesReference)
            self.frameId = self._translate_id_from_dap(self.frameId)
        self.kwargs = kwargs

    @classmethod
    def update_dict_ids_from_dap(cls, dct):
        if "variablesReference" in dct:
            dct["variablesReference"] = cls._translate_id_from_dap(dct["variablesReference"])
        if "frameId" in dct:
            dct["frameId"] = cls._translate_id_from_dap(dct["frameId"])
        return dct

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        name = self.name
        variablesReference = self.variablesReference
        frameId = self.frameId
        if update_ids_to_dap:
            if variablesReference is not None:
                variablesReference = self._translate_id_to_dap(variablesReference)
            if frameId is not None:
                frameId = self._translate_id_to_dap(frameId)
        dct = {
            "name": name,
        }
        if variablesReference is not None:
            dct["variablesReference"] = variablesReference
        if frameId is not None:
            dct["frameId"] = frameId
        dct.update(self.kwargs)
        return dct

    @classmethod
    def update_dict_ids_to_dap(cls, dct):
        if "variablesReference" in dct:
            dct["variablesReference"] = cls._translate_id_to_dap(dct["variablesReference"])
        if "frameId" in dct:
            dct["frameId"] = cls._translate_id_to_dap(dct["frameId"])
        return dct


@register_response("dataBreakpointInfo")
@register
class DataBreakpointInfoResponse(BaseSchema):
    """
    Response to `dataBreakpointInfo` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "dataId": {
                    "type": ["string", "null"],
                    "description": "An identifier for the data on which a data breakpoint can be registered with the `setDataBreakpoints` request or null if no data breakpoint is available. If a `variablesReference` or `frameId` is passed, the `dataId` is valid in the current suspended state, otherwise it's valid indefinitely. See 'Lifetime of Object References' in the Overview section for details. Breakpoints set using the `dataId` in the `setDataBreakpoints` request may outlive the lifetime of the associated `dataId`.",
                },
                "description": {
                    "type": "string",
                    "description": "UI string that describes on what data the breakpoint is set on or why a data breakpoint is not available.",
                },
                "accessTypes": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/DataBreakpointAccessType"},
                    "description": "Attribute lists the available access types for a potential data breakpoint. A UI client could surface this information.",
                },
                "canPersist": {
                    "type": "boolean",
                    "description": "Attribute indicates that a potential data breakpoint could be persisted across sessions.",
                },
            },
            "required": ["dataId", "description"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param DataBreakpointInfoResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = DataBreakpointInfoResponseBody()
        else:
            self.body = (
                DataBreakpointInfoResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != DataBreakpointInfoResponseBody
                else body
            )
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("setDataBreakpoints")
@register
class SetDataBreakpointsRequest(BaseSchema):
    """
    Replaces all existing data breakpoints with new data breakpoints.

    To clear all data breakpoints, specify an empty array.

    When a data breakpoint is hit, a `stopped` event (with reason `data breakpoint`) is generated.

    Clients should only call this request if the corresponding capability `supportsDataBreakpoints` is
    true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["setDataBreakpoints"]},
        "arguments": {"type": "SetDataBreakpointsArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param SetDataBreakpointsArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "setDataBreakpoints"
        if arguments is None:
            self.arguments = SetDataBreakpointsArguments()
        else:
            self.arguments = (
                SetDataBreakpointsArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != SetDataBreakpointsArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class SetDataBreakpointsArguments(BaseSchema):
    """
    Arguments for `setDataBreakpoints` request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "breakpoints": {
            "type": "array",
            "items": {"$ref": "#/definitions/DataBreakpoint"},
            "description": "The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints.",
        }
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, breakpoints, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param array breakpoints: The contents of this array replaces all existing data breakpoints. An empty array clears all data breakpoints.
        """
        self.breakpoints = breakpoints
        if update_ids_from_dap and self.breakpoints:
            for o in self.breakpoints:
                DataBreakpoint.update_dict_ids_from_dap(o)
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        breakpoints = self.breakpoints
        if breakpoints and hasattr(breakpoints[0], "to_dict"):
            breakpoints = [x.to_dict() for x in breakpoints]
        dct = {
            "breakpoints": [DataBreakpoint.update_dict_ids_to_dap(o) for o in breakpoints]
            if (update_ids_to_dap and breakpoints)
            else breakpoints,
        }
        dct.update(self.kwargs)
        return dct


@register_response("setDataBreakpoints")
@register
class SetDataBreakpointsResponse(BaseSchema):
    """
    Response to `setDataBreakpoints` request.

    Returned is information about each breakpoint created by this request.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "breakpoints": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/Breakpoint"},
                    "description": "Information about the data breakpoints. The array elements correspond to the elements of the input argument `breakpoints` array.",
                }
            },
            "required": ["breakpoints"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param SetDataBreakpointsResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = SetDataBreakpointsResponseBody()
        else:
            self.body = (
                SetDataBreakpointsResponseBody(update_ids_from_dap=update_ids_from_dap, **body)
                if body.__class__ != SetDataBreakpointsResponseBody
                else body
            )
        self.seq = seq
        self.message = message
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        request_seq = self.request_seq
        success = self.success
        command = self.command
        body = self.body
        seq = self.seq
        message = self.message
        dct = {
            "type": type,
            "request_seq": request_seq,
            "success": success,
            "command": command,
            "body": body.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        if message is not None:
            dct["message"] = message
        dct.update(self.kwargs)
        return dct


@register_request("setInstructionBreakpoints")
@register
class SetInstructionBreakpointsRequest(BaseSchema):
    """
    Replaces all existing instruction breakpoints. Typically, instruction breakpoints would be set from
    a disassembly window.

    To clear all instruction breakpoints, specify an empty array.

    When an instruction breakpoint is hit, a `stopped` event (with reason `instruction breakpoint`) is
    generated.

    Clients should only call this request if the corresponding capability
    `supportsInstructionBreakpoints` is true.

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["request"]},
        "command": {"type": "string", "enum": ["setInstructionBreakpoints"]},
        "arguments": {"type": "SetInstructionBreakpointsArguments"},
    }
    __refs__ = set(["arguments"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, arguments, seq=-1, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param string command:
        :param SetInstructionBreakpointsArguments arguments:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        """
        self.type = "request"
        self.command = "setInstructionBreakpoints"
        if arguments is None:
            self.arguments = SetInstructionBreakpointsArguments()
        else:
            self.arguments = (
                SetInstructionBreakpointsArguments(update_ids_from_dap=update_ids_from_dap, **arguments)
                if arguments.__class__ != SetInstructionBreakpointsArguments
                else arguments
            )
        self.seq = seq
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        type = self.type  # noqa (assign to builtin)
        command = self.command
        arguments = self.arguments
        seq = self.seq
        dct = {
            "type": type,
            "command": command,
            "arguments": arguments.to_dict(update_ids_to_dap=update_ids_to_dap),
            "seq": seq,
        }
        dct.update(self.kwargs)
        return dct


@register
class SetInstructionBreakpointsArguments(BaseSchema):
    """
    Arguments for `setInstructionBreakpoints` request

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "breakpoints": {
            "type": "array",
            "items": {"$ref": "#/definitions/InstructionBreakpoint"},
            "description": "The instruction references of the breakpoints",
        }
    }
    __refs__ = set()

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, breakpoints, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param array breakpoints: The instruction references of the breakpoints
        """
        self.breakpoints = breakpoints
        if update_ids_from_dap and self.breakpoints:
            for o in self.breakpoints:
                InstructionBreakpoint.update_dict_ids_from_dap(o)
        self.kwargs = kwargs

    def to_dict(self, update_ids_to_dap=False):  # noqa (update_ids_to_dap may be unused)
        breakpoints = self.breakpoints
        if breakpoints and hasattr(breakpoints[0], "to_dict"):
            breakpoints = [x.to_dict() for x in breakpoints]
        dct = {
            "breakpoints": [InstructionBreakpoint.update_dict_ids_to_dap(o) for o in breakpoints]
            if (update_ids_to_dap and breakpoints)
            else breakpoints,
        }
        dct.update(self.kwargs)
        return dct


@register_response("setInstructionBreakpoints")
@register
class SetInstructionBreakpointsResponse(BaseSchema):
    """
    Response to `setInstructionBreakpoints` request

    Note: automatically generated code. Do not edit manually.
    """

    __props__ = {
        "seq": {
            "type": "integer",
            "description": "Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.",
        },
        "type": {"type": "string", "enum": ["response"]},
        "request_seq": {"type": "integer", "description": "Sequence number of the corresponding request."},
        "success": {
            "type": "boolean",
            "description": "Outcome of the request.\nIf True, the request was successful and the `body` attribute may contain the result of the request.\nIf the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).",
        },
        "command": {"type": "string", "description": "The command requested."},
        "message": {
            "type": "string",
            "description": "Contains the raw error in short form if `success` is false.\nThis raw error might be interpreted by the client and is not shown in the UI.\nSome predefined values exist.",
            "_enum": ["cancelled", "notStopped"],
            "enumDescriptions": ["the request was cancelled.", "the request may be retried once the adapter is in a 'stopped' state."],
        },
        "body": {
            "type": "object",
            "properties": {
                "breakpoints": {
                    "type": "array",
                    "items": {"$ref": "#/definitions/Breakpoint"},
                    "description": "Information about the breakpoints. The array elements correspond to the elements of the `breakpoints` array.",
                }
            },
            "required": ["breakpoints"],
        },
    }
    __refs__ = set(["body"])

    __slots__ = list(__props__.keys()) + ["kwargs"]

    def __init__(self, request_seq, success, command, body, seq=-1, message=None, update_ids_from_dap=False, **kwargs):  # noqa (update_ids_from_dap may be unused)
        """
        :param string type:
        :param integer request_seq: Sequence number of the corresponding request.
        :param boolean success: Outcome of the request.
        If true, the request was successful and the `body` attribute may contain the result of the request.
        If the value is false, the attribute `message` contains the error in short form and the `body` may contain additional information (see `ErrorResponse.body.error`).
        :param string command: The command requested.
        :param SetInstructionBreakpointsResponseBody body:
        :param integer seq: Sequence number of the message (also known as message ID). The `seq` for the first message sent by a client or debug adapter is 1, and for each subsequent message is 1 greater than the previous message sent by that actor. `seq` can be used to order requests, responses, and events, and to associate requests with their corresponding responses. For protocol messages of type `request` the sequence number can be used to cancel the request.
        :param string message: Contains the raw error in short form if `success` is false.
        This raw error might be interpreted by the client and is not shown in the UI.
        Some predefined values exist.
        """
        self.type = "response"
        self.request_seq = request_seq
        self.success = success
        self.command = command
        if body is None:
            self.body = SetInstructionBreakpointsResponseBody()
        else:
            self.body = (
                SetInstructionBreakpointsResponseBody(update_ids_from_dap=update_i