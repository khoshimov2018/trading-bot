// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/compiler/xla/xla.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxla_2fxla_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxla_2fxla_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/any.pb.h>
#include "tensorflow/compiler/xla/service/hlo.pb.h"
#include "tensorflow/compiler/xla/xla_data.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcompiler_2fxla_2fxla_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
namespace xla {
class CompilationEnvironmentsProto;
struct CompilationEnvironmentsProtoDefaultTypeInternal;
extern CompilationEnvironmentsProtoDefaultTypeInternal _CompilationEnvironmentsProto_default_instance_;
class CompileRequest;
struct CompileRequestDefaultTypeInternal;
extern CompileRequestDefaultTypeInternal _CompileRequest_default_instance_;
class CompileResponse;
struct CompileResponseDefaultTypeInternal;
extern CompileResponseDefaultTypeInternal _CompileResponse_default_instance_;
class ComputationGraphStatsRequest;
struct ComputationGraphStatsRequestDefaultTypeInternal;
extern ComputationGraphStatsRequestDefaultTypeInternal _ComputationGraphStatsRequest_default_instance_;
class ComputationStatsResponse;
struct ComputationStatsResponseDefaultTypeInternal;
extern ComputationStatsResponseDefaultTypeInternal _ComputationStatsResponse_default_instance_;
class ComputeConstantGraphRequest;
struct ComputeConstantGraphRequestDefaultTypeInternal;
extern ComputeConstantGraphRequestDefaultTypeInternal _ComputeConstantGraphRequest_default_instance_;
class ComputeConstantResponse;
struct ComputeConstantResponseDefaultTypeInternal;
extern ComputeConstantResponseDefaultTypeInternal _ComputeConstantResponse_default_instance_;
class CreateChannelHandleRequest;
struct CreateChannelHandleRequestDefaultTypeInternal;
extern CreateChannelHandleRequestDefaultTypeInternal _CreateChannelHandleRequest_default_instance_;
class CreateChannelHandleResponse;
struct CreateChannelHandleResponseDefaultTypeInternal;
extern CreateChannelHandleResponseDefaultTypeInternal _CreateChannelHandleResponse_default_instance_;
class DebugOptions;
struct DebugOptionsDefaultTypeInternal;
extern DebugOptionsDefaultTypeInternal _DebugOptions_default_instance_;
class DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse;
struct DebugOptions_XlaBackendExtraOptionsEntry_DoNotUseDefaultTypeInternal;
extern DebugOptions_XlaBackendExtraOptionsEntry_DoNotUseDefaultTypeInternal _DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse_default_instance_;
class DeconstructTupleRequest;
struct DeconstructTupleRequestDefaultTypeInternal;
extern DeconstructTupleRequestDefaultTypeInternal _DeconstructTupleRequest_default_instance_;
class DeconstructTupleResponse;
struct DeconstructTupleResponseDefaultTypeInternal;
extern DeconstructTupleResponseDefaultTypeInternal _DeconstructTupleResponse_default_instance_;
class ExecuteGraphParallelRequest;
struct ExecuteGraphParallelRequestDefaultTypeInternal;
extern ExecuteGraphParallelRequestDefaultTypeInternal _ExecuteGraphParallelRequest_default_instance_;
class ExecuteGraphRequest;
struct ExecuteGraphRequestDefaultTypeInternal;
extern ExecuteGraphRequestDefaultTypeInternal _ExecuteGraphRequest_default_instance_;
class ExecuteParallelResponse;
struct ExecuteParallelResponseDefaultTypeInternal;
extern ExecuteParallelResponseDefaultTypeInternal _ExecuteParallelResponse_default_instance_;
class ExecuteRequest;
struct ExecuteRequestDefaultTypeInternal;
extern ExecuteRequestDefaultTypeInternal _ExecuteRequest_default_instance_;
class ExecuteResponse;
struct ExecuteResponseDefaultTypeInternal;
extern ExecuteResponseDefaultTypeInternal _ExecuteResponse_default_instance_;
class ExecutionOptions;
struct ExecutionOptionsDefaultTypeInternal;
extern ExecutionOptionsDefaultTypeInternal _ExecutionOptions_default_instance_;
class GetDeviceHandlesRequest;
struct GetDeviceHandlesRequestDefaultTypeInternal;
extern GetDeviceHandlesRequestDefaultTypeInternal _GetDeviceHandlesRequest_default_instance_;
class GetDeviceHandlesResponse;
struct GetDeviceHandlesResponseDefaultTypeInternal;
extern GetDeviceHandlesResponseDefaultTypeInternal _GetDeviceHandlesResponse_default_instance_;
class GetShapeRequest;
struct GetShapeRequestDefaultTypeInternal;
extern GetShapeRequestDefaultTypeInternal _GetShapeRequest_default_instance_;
class GetShapeResponse;
struct GetShapeResponseDefaultTypeInternal;
extern GetShapeResponseDefaultTypeInternal _GetShapeResponse_default_instance_;
class HloModuleConfigProto;
struct HloModuleConfigProtoDefaultTypeInternal;
extern HloModuleConfigProtoDefaultTypeInternal _HloModuleConfigProto_default_instance_;
class HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse;
struct HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUseDefaultTypeInternal;
extern HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUseDefaultTypeInternal _HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse_default_instance_;
class HloModuleConfigProto_BoolList;
struct HloModuleConfigProto_BoolListDefaultTypeInternal;
extern HloModuleConfigProto_BoolListDefaultTypeInternal _HloModuleConfigProto_BoolList_default_instance_;
class HloModuleConfigProto_DotConfigEntry_DoNotUse;
struct HloModuleConfigProto_DotConfigEntry_DoNotUseDefaultTypeInternal;
extern HloModuleConfigProto_DotConfigEntry_DoNotUseDefaultTypeInternal _HloModuleConfigProto_DotConfigEntry_DoNotUse_default_instance_;
class HloModuleConfigProto_Int64List;
struct HloModuleConfigProto_Int64ListDefaultTypeInternal;
extern HloModuleConfigProto_Int64ListDefaultTypeInternal _HloModuleConfigProto_Int64List_default_instance_;
class HloModuleConfigProto_Int64ListList;
struct HloModuleConfigProto_Int64ListListDefaultTypeInternal;
extern HloModuleConfigProto_Int64ListListDefaultTypeInternal _HloModuleConfigProto_Int64ListList_default_instance_;
class HloModuleProtoWithConfig;
struct HloModuleProtoWithConfigDefaultTypeInternal;
extern HloModuleProtoWithConfigDefaultTypeInternal _HloModuleProtoWithConfig_default_instance_;
class LoadDataRequest;
struct LoadDataRequestDefaultTypeInternal;
extern LoadDataRequestDefaultTypeInternal _LoadDataRequest_default_instance_;
class LoadDataResponse;
struct LoadDataResponseDefaultTypeInternal;
extern LoadDataResponseDefaultTypeInternal _LoadDataResponse_default_instance_;
class ResetDeviceRequest;
struct ResetDeviceRequestDefaultTypeInternal;
extern ResetDeviceRequestDefaultTypeInternal _ResetDeviceRequest_default_instance_;
class ResetDeviceResponse;
struct ResetDeviceResponseDefaultTypeInternal;
extern ResetDeviceResponseDefaultTypeInternal _ResetDeviceResponse_default_instance_;
class ScheduleProto;
struct ScheduleProtoDefaultTypeInternal;
extern ScheduleProtoDefaultTypeInternal _ScheduleProto_default_instance_;
class ScheduleProto_Instruction;
struct ScheduleProto_InstructionDefaultTypeInternal;
extern ScheduleProto_InstructionDefaultTypeInternal _ScheduleProto_Instruction_default_instance_;
class ShardableValueUpdatePairProto;
struct ShardableValueUpdatePairProtoDefaultTypeInternal;
extern ShardableValueUpdatePairProtoDefaultTypeInternal _ShardableValueUpdatePairProto_default_instance_;
class TransferFromOutfeedRequest;
struct TransferFromOutfeedRequestDefaultTypeInternal;
extern TransferFromOutfeedRequestDefaultTypeInternal _TransferFromOutfeedRequest_default_instance_;
class TransferFromOutfeedResponse;
struct TransferFromOutfeedResponseDefaultTypeInternal;
extern TransferFromOutfeedResponseDefaultTypeInternal _TransferFromOutfeedResponse_default_instance_;
class TransferToClientRequest;
struct TransferToClientRequestDefaultTypeInternal;
extern TransferToClientRequestDefaultTypeInternal _TransferToClientRequest_default_instance_;
class TransferToClientResponse;
struct TransferToClientResponseDefaultTypeInternal;
extern TransferToClientResponseDefaultTypeInternal _TransferToClientResponse_default_instance_;
class TransferToInfeedRequest;
struct TransferToInfeedRequestDefaultTypeInternal;
extern TransferToInfeedRequestDefaultTypeInternal _TransferToInfeedRequest_default_instance_;
class TransferToInfeedResponse;
struct TransferToInfeedResponseDefaultTypeInternal;
extern TransferToInfeedResponseDefaultTypeInternal _TransferToInfeedResponse_default_instance_;
class TransferToServerRequest;
struct TransferToServerRequestDefaultTypeInternal;
extern TransferToServerRequestDefaultTypeInternal _TransferToServerRequest_default_instance_;
class TransferToServerResponse;
struct TransferToServerResponseDefaultTypeInternal;
extern TransferToServerResponseDefaultTypeInternal _TransferToServerResponse_default_instance_;
class UnpackRequest;
struct UnpackRequestDefaultTypeInternal;
extern UnpackRequestDefaultTypeInternal _UnpackRequest_default_instance_;
class UnpackResponse;
struct UnpackResponseDefaultTypeInternal;
extern UnpackResponseDefaultTypeInternal _UnpackResponse_default_instance_;
class UnregisterRequest;
struct UnregisterRequestDefaultTypeInternal;
extern UnregisterRequestDefaultTypeInternal _UnregisterRequest_default_instance_;
class UnregisterResponse;
struct UnregisterResponseDefaultTypeInternal;
extern UnregisterResponseDefaultTypeInternal _UnregisterResponse_default_instance_;
class WaitForExecutionRequest;
struct WaitForExecutionRequestDefaultTypeInternal;
extern WaitForExecutionRequestDefaultTypeInternal _WaitForExecutionRequest_default_instance_;
class WaitForExecutionResponse;
struct WaitForExecutionResponseDefaultTypeInternal;
extern WaitForExecutionResponseDefaultTypeInternal _WaitForExecutionResponse_default_instance_;
}  // namespace xla
PROTOBUF_NAMESPACE_OPEN
template<> ::xla::CompilationEnvironmentsProto* Arena::CreateMaybeMessage<::xla::CompilationEnvironmentsProto>(Arena*);
template<> ::xla::CompileRequest* Arena::CreateMaybeMessage<::xla::CompileRequest>(Arena*);
template<> ::xla::CompileResponse* Arena::CreateMaybeMessage<::xla::CompileResponse>(Arena*);
template<> ::xla::ComputationGraphStatsRequest* Arena::CreateMaybeMessage<::xla::ComputationGraphStatsRequest>(Arena*);
template<> ::xla::ComputationStatsResponse* Arena::CreateMaybeMessage<::xla::ComputationStatsResponse>(Arena*);
template<> ::xla::ComputeConstantGraphRequest* Arena::CreateMaybeMessage<::xla::ComputeConstantGraphRequest>(Arena*);
template<> ::xla::ComputeConstantResponse* Arena::CreateMaybeMessage<::xla::ComputeConstantResponse>(Arena*);
template<> ::xla::CreateChannelHandleRequest* Arena::CreateMaybeMessage<::xla::CreateChannelHandleRequest>(Arena*);
template<> ::xla::CreateChannelHandleResponse* Arena::CreateMaybeMessage<::xla::CreateChannelHandleResponse>(Arena*);
template<> ::xla::DebugOptions* Arena::CreateMaybeMessage<::xla::DebugOptions>(Arena*);
template<> ::xla::DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse* Arena::CreateMaybeMessage<::xla::DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse>(Arena*);
template<> ::xla::DeconstructTupleRequest* Arena::CreateMaybeMessage<::xla::DeconstructTupleRequest>(Arena*);
template<> ::xla::DeconstructTupleResponse* Arena::CreateMaybeMessage<::xla::DeconstructTupleResponse>(Arena*);
template<> ::xla::ExecuteGraphParallelRequest* Arena::CreateMaybeMessage<::xla::ExecuteGraphParallelRequest>(Arena*);
template<> ::xla::ExecuteGraphRequest* Arena::CreateMaybeMessage<::xla::ExecuteGraphRequest>(Arena*);
template<> ::xla::ExecuteParallelResponse* Arena::CreateMaybeMessage<::xla::ExecuteParallelResponse>(Arena*);
template<> ::xla::ExecuteRequest* Arena::CreateMaybeMessage<::xla::ExecuteRequest>(Arena*);
template<> ::xla::ExecuteResponse* Arena::CreateMaybeMessage<::xla::ExecuteResponse>(Arena*);
template<> ::xla::ExecutionOptions* Arena::CreateMaybeMessage<::xla::ExecutionOptions>(Arena*);
template<> ::xla::GetDeviceHandlesRequest* Arena::CreateMaybeMessage<::xla::GetDeviceHandlesRequest>(Arena*);
template<> ::xla::GetDeviceHandlesResponse* Arena::CreateMaybeMessage<::xla::GetDeviceHandlesResponse>(Arena*);
template<> ::xla::GetShapeRequest* Arena::CreateMaybeMessage<::xla::GetShapeRequest>(Arena*);
template<> ::xla::GetShapeResponse* Arena::CreateMaybeMessage<::xla::GetShapeResponse>(Arena*);
template<> ::xla::HloModuleConfigProto* Arena::CreateMaybeMessage<::xla::HloModuleConfigProto>(Arena*);
template<> ::xla::HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse* Arena::CreateMaybeMessage<::xla::HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse>(Arena*);
template<> ::xla::HloModuleConfigProto_BoolList* Arena::CreateMaybeMessage<::xla::HloModuleConfigProto_BoolList>(Arena*);
template<> ::xla::HloModuleConfigProto_DotConfigEntry_DoNotUse* Arena::CreateMaybeMessage<::xla::HloModuleConfigProto_DotConfigEntry_DoNotUse>(Arena*);
template<> ::xla::HloModuleConfigProto_Int64List* Arena::CreateMaybeMessage<::xla::HloModuleConfigProto_Int64List>(Arena*);
template<> ::xla::HloModuleConfigProto_Int64ListList* Arena::CreateMaybeMessage<::xla::HloModuleConfigProto_Int64ListList>(Arena*);
template<> ::xla::HloModuleProtoWithConfig* Arena::CreateMaybeMessage<::xla::HloModuleProtoWithConfig>(Arena*);
template<> ::xla::LoadDataRequest* Arena::CreateMaybeMessage<::xla::LoadDataRequest>(Arena*);
template<> ::xla::LoadDataResponse* Arena::CreateMaybeMessage<::xla::LoadDataResponse>(Arena*);
template<> ::xla::ResetDeviceRequest* Arena::CreateMaybeMessage<::xla::ResetDeviceRequest>(Arena*);
template<> ::xla::ResetDeviceResponse* Arena::CreateMaybeMessage<::xla::ResetDeviceResponse>(Arena*);
template<> ::xla::ScheduleProto* Arena::CreateMaybeMessage<::xla::ScheduleProto>(Arena*);
template<> ::xla::ScheduleProto_Instruction* Arena::CreateMaybeMessage<::xla::ScheduleProto_Instruction>(Arena*);
template<> ::xla::ShardableValueUpdatePairProto* Arena::CreateMaybeMessage<::xla::ShardableValueUpdatePairProto>(Arena*);
template<> ::xla::TransferFromOutfeedRequest* Arena::CreateMaybeMessage<::xla::TransferFromOutfeedRequest>(Arena*);
template<> ::xla::TransferFromOutfeedResponse* Arena::CreateMaybeMessage<::xla::TransferFromOutfeedResponse>(Arena*);
template<> ::xla::TransferToClientRequest* Arena::CreateMaybeMessage<::xla::TransferToClientRequest>(Arena*);
template<> ::xla::TransferToClientResponse* Arena::CreateMaybeMessage<::xla::TransferToClientResponse>(Arena*);
template<> ::xla::TransferToInfeedRequest* Arena::CreateMaybeMessage<::xla::TransferToInfeedRequest>(Arena*);
template<> ::xla::TransferToInfeedResponse* Arena::CreateMaybeMessage<::xla::TransferToInfeedResponse>(Arena*);
template<> ::xla::TransferToServerRequest* Arena::CreateMaybeMessage<::xla::TransferToServerRequest>(Arena*);
template<> ::xla::TransferToServerResponse* Arena::CreateMaybeMessage<::xla::TransferToServerResponse>(Arena*);
template<> ::xla::UnpackRequest* Arena::CreateMaybeMessage<::xla::UnpackRequest>(Arena*);
template<> ::xla::UnpackResponse* Arena::CreateMaybeMessage<::xla::UnpackResponse>(Arena*);
template<> ::xla::UnregisterRequest* Arena::CreateMaybeMessage<::xla::UnregisterRequest>(Arena*);
template<> ::xla::UnregisterResponse* Arena::CreateMaybeMessage<::xla::UnregisterResponse>(Arena*);
template<> ::xla::WaitForExecutionRequest* Arena::CreateMaybeMessage<::xla::WaitForExecutionRequest>(Arena*);
template<> ::xla::WaitForExecutionResponse* Arena::CreateMaybeMessage<::xla::WaitForExecutionResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xla {

enum DebugOptions_ShapeChecks : int {
  DebugOptions_ShapeChecks_IGNORE = 0,
  DebugOptions_ShapeChecks_RUNTIME = 1,
  DebugOptions_ShapeChecks_COMPILE_TIME = 2,
  DebugOptions_ShapeChecks_DebugOptions_ShapeChecks_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DebugOptions_ShapeChecks_DebugOptions_ShapeChecks_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DebugOptions_ShapeChecks_IsValid(int value);
constexpr DebugOptions_ShapeChecks DebugOptions_ShapeChecks_ShapeChecks_MIN = DebugOptions_ShapeChecks_IGNORE;
constexpr DebugOptions_ShapeChecks DebugOptions_ShapeChecks_ShapeChecks_MAX = DebugOptions_ShapeChecks_COMPILE_TIME;
constexpr int DebugOptions_ShapeChecks_ShapeChecks_ARRAYSIZE = DebugOptions_ShapeChecks_ShapeChecks_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugOptions_ShapeChecks_descriptor();
template<typename T>
inline const std::string& DebugOptions_ShapeChecks_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugOptions_ShapeChecks>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugOptions_ShapeChecks_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugOptions_ShapeChecks_descriptor(), enum_t_value);
}
inline bool DebugOptions_ShapeChecks_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugOptions_ShapeChecks* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugOptions_ShapeChecks>(
    DebugOptions_ShapeChecks_descriptor(), name, value);
}
enum DebugOptions_StepMarkerLocation : int {
  DebugOptions_StepMarkerLocation_STEP_MARK_AT_ENTRY = 0,
  DebugOptions_StepMarkerLocation_STEP_MARK_AT_TOP_LEVEL_WHILE_LOOP = 1,
  DebugOptions_StepMarkerLocation_STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP = 3,
  DebugOptions_StepMarkerLocation_STEP_MARK_NONE = 2,
  DebugOptions_StepMarkerLocation_DebugOptions_StepMarkerLocation_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DebugOptions_StepMarkerLocation_DebugOptions_StepMarkerLocation_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DebugOptions_StepMarkerLocation_IsValid(int value);
constexpr DebugOptions_StepMarkerLocation DebugOptions_StepMarkerLocation_StepMarkerLocation_MIN = DebugOptions_StepMarkerLocation_STEP_MARK_AT_ENTRY;
constexpr DebugOptions_StepMarkerLocation DebugOptions_StepMarkerLocation_StepMarkerLocation_MAX = DebugOptions_StepMarkerLocation_STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP;
constexpr int DebugOptions_StepMarkerLocation_StepMarkerLocation_ARRAYSIZE = DebugOptions_StepMarkerLocation_StepMarkerLocation_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugOptions_StepMarkerLocation_descriptor();
template<typename T>
inline const std::string& DebugOptions_StepMarkerLocation_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugOptions_StepMarkerLocation>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugOptions_StepMarkerLocation_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugOptions_StepMarkerLocation_descriptor(), enum_t_value);
}
inline bool DebugOptions_StepMarkerLocation_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugOptions_StepMarkerLocation* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugOptions_StepMarkerLocation>(
    DebugOptions_StepMarkerLocation_descriptor(), name, value);
}
enum DebugOptions_PartitioningAlgorithm : int {
  DebugOptions_PartitioningAlgorithm_PARTITIONING_ALGORITHM_NOOP = 0,
  DebugOptions_PartitioningAlgorithm_DebugOptions_PartitioningAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DebugOptions_PartitioningAlgorithm_DebugOptions_PartitioningAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DebugOptions_PartitioningAlgorithm_IsValid(int value);
constexpr DebugOptions_PartitioningAlgorithm DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_MIN = DebugOptions_PartitioningAlgorithm_PARTITIONING_ALGORITHM_NOOP;
constexpr DebugOptions_PartitioningAlgorithm DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_MAX = DebugOptions_PartitioningAlgorithm_PARTITIONING_ALGORITHM_NOOP;
constexpr int DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_ARRAYSIZE = DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DebugOptions_PartitioningAlgorithm_descriptor();
template<typename T>
inline const std::string& DebugOptions_PartitioningAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DebugOptions_PartitioningAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DebugOptions_PartitioningAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DebugOptions_PartitioningAlgorithm_descriptor(), enum_t_value);
}
inline bool DebugOptions_PartitioningAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DebugOptions_PartitioningAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DebugOptions_PartitioningAlgorithm>(
    DebugOptions_PartitioningAlgorithm_descriptor(), name, value);
}
enum HloModuleConfigProto_FusionConfigCollection : int {
  HloModuleConfigProto_FusionConfigCollection_OFF = 0,
  HloModuleConfigProto_FusionConfigCollection_PER_EDGE = 1,
  HloModuleConfigProto_FusionConfigCollection_PER_NODE = 2,
  HloModuleConfigProto_FusionConfigCollection_HloModuleConfigProto_FusionConfigCollection_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  HloModuleConfigProto_FusionConfigCollection_HloModuleConfigProto_FusionConfigCollection_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool HloModuleConfigProto_FusionConfigCollection_IsValid(int value);
constexpr HloModuleConfigProto_FusionConfigCollection HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_MIN = HloModuleConfigProto_FusionConfigCollection_OFF;
constexpr HloModuleConfigProto_FusionConfigCollection HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_MAX = HloModuleConfigProto_FusionConfigCollection_PER_NODE;
constexpr int HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_ARRAYSIZE = HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* HloModuleConfigProto_FusionConfigCollection_descriptor();
template<typename T>
inline const std::string& HloModuleConfigProto_FusionConfigCollection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, HloModuleConfigProto_FusionConfigCollection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function HloModuleConfigProto_FusionConfigCollection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    HloModuleConfigProto_FusionConfigCollection_descriptor(), enum_t_value);
}
inline bool HloModuleConfigProto_FusionConfigCollection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, HloModuleConfigProto_FusionConfigCollection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<HloModuleConfigProto_FusionConfigCollection>(
    HloModuleConfigProto_FusionConfigCollection_descriptor(), name, value);
}
// ===================================================================

class CompilationEnvironmentsProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.CompilationEnvironmentsProto) */ {
 public:
  inline CompilationEnvironmentsProto() : CompilationEnvironmentsProto(nullptr) {}
  ~CompilationEnvironmentsProto() override;
  explicit PROTOBUF_CONSTEXPR CompilationEnvironmentsProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CompilationEnvironmentsProto(const CompilationEnvironmentsProto& from);
  CompilationEnvironmentsProto(CompilationEnvironmentsProto&& from) noexcept
    : CompilationEnvironmentsProto() {
    *this = ::std::move(from);
  }

  inline CompilationEnvironmentsProto& operator=(const CompilationEnvironmentsProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline CompilationEnvironmentsProto& operator=(CompilationEnvironmentsProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CompilationEnvironmentsProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const CompilationEnvironmentsProto* internal_default_instance() {
    return reinterpret_cast<const CompilationEnvironmentsProto*>(
               &_CompilationEnvironmentsProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CompilationEnvironmentsProto& a, CompilationEnvironmentsProto& b) {
    a.Swap(&b);
  }
  inline void Swap(CompilationEnvironmentsProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CompilationEnvironmentsProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CompilationEnvironmentsProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CompilationEnvironmentsProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CompilationEnvironmentsProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CompilationEnvironmentsProto& from) {
    CompilationEnvironmentsProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CompilationEnvironmentsProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.CompilationEnvironmentsProto";
  }
  protected:
  explicit CompilationEnvironmentsProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnvironmentsFieldNumber = 1,
  };
  // repeated .google.protobuf.Any environments = 1;
  int environments_size() const;
  private:
  int _internal_environments_size() const;
  public:
  void clear_environments();
  ::PROTOBUF_NAMESPACE_ID::Any* mutable_environments(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >*
      mutable_environments();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Any& _internal_environments(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* _internal_add_environments();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Any& environments(int index) const;
  ::PROTOBUF_NAMESPACE_ID::Any* add_environments();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any >&
      environments() const;

  // @@protoc_insertion_point(class_scope:xla.CompilationEnvironmentsProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::PROTOBUF_NAMESPACE_ID::Any > environments_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse& other);
  static const DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse*>(&_DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xla.DebugOptions.XlaBackendExtraOptionsEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xla.DebugOptions.XlaBackendExtraOptionsEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};

// -------------------------------------------------------------------

class DebugOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.DebugOptions) */ {
 public:
  inline DebugOptions() : DebugOptions(nullptr) {}
  ~DebugOptions() override;
  explicit PROTOBUF_CONSTEXPR DebugOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DebugOptions(const DebugOptions& from);
  DebugOptions(DebugOptions&& from) noexcept
    : DebugOptions() {
    *this = ::std::move(from);
  }

  inline DebugOptions& operator=(const DebugOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline DebugOptions& operator=(DebugOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DebugOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const DebugOptions* internal_default_instance() {
    return reinterpret_cast<const DebugOptions*>(
               &_DebugOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DebugOptions& a, DebugOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(DebugOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DebugOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DebugOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DebugOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DebugOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DebugOptions& from) {
    DebugOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DebugOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.DebugOptions";
  }
  protected:
  explicit DebugOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  typedef DebugOptions_ShapeChecks ShapeChecks;
  static constexpr ShapeChecks IGNORE =
    DebugOptions_ShapeChecks_IGNORE;
  static constexpr ShapeChecks RUNTIME =
    DebugOptions_ShapeChecks_RUNTIME;
  static constexpr ShapeChecks COMPILE_TIME =
    DebugOptions_ShapeChecks_COMPILE_TIME;
  static inline bool ShapeChecks_IsValid(int value) {
    return DebugOptions_ShapeChecks_IsValid(value);
  }
  static constexpr ShapeChecks ShapeChecks_MIN =
    DebugOptions_ShapeChecks_ShapeChecks_MIN;
  static constexpr ShapeChecks ShapeChecks_MAX =
    DebugOptions_ShapeChecks_ShapeChecks_MAX;
  static constexpr int ShapeChecks_ARRAYSIZE =
    DebugOptions_ShapeChecks_ShapeChecks_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ShapeChecks_descriptor() {
    return DebugOptions_ShapeChecks_descriptor();
  }
  template<typename T>
  static inline const std::string& ShapeChecks_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ShapeChecks>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ShapeChecks_Name.");
    return DebugOptions_ShapeChecks_Name(enum_t_value);
  }
  static inline bool ShapeChecks_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ShapeChecks* value) {
    return DebugOptions_ShapeChecks_Parse(name, value);
  }

  typedef DebugOptions_StepMarkerLocation StepMarkerLocation;
  static constexpr StepMarkerLocation STEP_MARK_AT_ENTRY =
    DebugOptions_StepMarkerLocation_STEP_MARK_AT_ENTRY;
  static constexpr StepMarkerLocation STEP_MARK_AT_TOP_LEVEL_WHILE_LOOP =
    DebugOptions_StepMarkerLocation_STEP_MARK_AT_TOP_LEVEL_WHILE_LOOP;
  static constexpr StepMarkerLocation STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP =
    DebugOptions_StepMarkerLocation_STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP;
  static constexpr StepMarkerLocation STEP_MARK_NONE =
    DebugOptions_StepMarkerLocation_STEP_MARK_NONE;
  static inline bool StepMarkerLocation_IsValid(int value) {
    return DebugOptions_StepMarkerLocation_IsValid(value);
  }
  static constexpr StepMarkerLocation StepMarkerLocation_MIN =
    DebugOptions_StepMarkerLocation_StepMarkerLocation_MIN;
  static constexpr StepMarkerLocation StepMarkerLocation_MAX =
    DebugOptions_StepMarkerLocation_StepMarkerLocation_MAX;
  static constexpr int StepMarkerLocation_ARRAYSIZE =
    DebugOptions_StepMarkerLocation_StepMarkerLocation_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  StepMarkerLocation_descriptor() {
    return DebugOptions_StepMarkerLocation_descriptor();
  }
  template<typename T>
  static inline const std::string& StepMarkerLocation_Name(T enum_t_value) {
    static_assert(::std::is_same<T, StepMarkerLocation>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function StepMarkerLocation_Name.");
    return DebugOptions_StepMarkerLocation_Name(enum_t_value);
  }
  static inline bool StepMarkerLocation_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      StepMarkerLocation* value) {
    return DebugOptions_StepMarkerLocation_Parse(name, value);
  }

  typedef DebugOptions_PartitioningAlgorithm PartitioningAlgorithm;
  static constexpr PartitioningAlgorithm PARTITIONING_ALGORITHM_NOOP =
    DebugOptions_PartitioningAlgorithm_PARTITIONING_ALGORITHM_NOOP;
  static inline bool PartitioningAlgorithm_IsValid(int value) {
    return DebugOptions_PartitioningAlgorithm_IsValid(value);
  }
  static constexpr PartitioningAlgorithm PartitioningAlgorithm_MIN =
    DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_MIN;
  static constexpr PartitioningAlgorithm PartitioningAlgorithm_MAX =
    DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_MAX;
  static constexpr int PartitioningAlgorithm_ARRAYSIZE =
    DebugOptions_PartitioningAlgorithm_PartitioningAlgorithm_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  PartitioningAlgorithm_descriptor() {
    return DebugOptions_PartitioningAlgorithm_descriptor();
  }
  template<typename T>
  static inline const std::string& PartitioningAlgorithm_Name(T enum_t_value) {
    static_assert(::std::is_same<T, PartitioningAlgorithm>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function PartitioningAlgorithm_Name.");
    return DebugOptions_PartitioningAlgorithm_Name(enum_t_value);
  }
  static inline bool PartitioningAlgorithm_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      PartitioningAlgorithm* value) {
    return DebugOptions_PartitioningAlgorithm_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kXlaDisableHloPassesFieldNumber = 30,
    kXlaEnableHloPassesOnlyFieldNumber = 124,
    kXlaGpuPtxFileFieldNumber = 127,
    kXlaGpuLlvmIrFileFieldNumber = 150,
    kXlaBackendExtraOptionsFieldNumber = 500,
    kXlaGpuCudaDataDirFieldNumber = 61,
    kXlaDumpToFieldNumber = 109,
    kXlaDumpHloModuleReFieldNumber = 110,
    kXlaDumpHloPassReFieldNumber = 111,
    kXlaGpuAlgorithmDenylistPathFieldNumber = 128,
    kXlaGpuAsmExtraFlagsFieldNumber = 141,
    kXlaDumpHloPipelineReFieldNumber = 154,
    kXlaBackendOptimizationLevelFieldNumber = 31,
    kXlaHloGraphAddressesFieldNumber = 2,
    kXlaHloProfileFieldNumber = 9,
    kXlaDisableAllHloPassesFieldNumber = 104,
    kXlaEmbedIrInExecutableFieldNumber = 33,
    kXlaEliminateHloImplicitBroadcastFieldNumber = 35,
    kXlaCpuMultiThreadEigenFieldNumber = 60,
    kXlaGpuFtzFieldNumber = 62,
    kXlaLlvmEnableAliasScopeMetadataFieldNumber = 70,
    kXlaLlvmEnableNoaliasMetadataFieldNumber = 71,
    kXlaLlvmEnableInvariantLoadMetadataFieldNumber = 72,
    kXlaLlvmDisableExpensivePassesFieldNumber = 73,
    kXlaTestAllOutputLayoutsFieldNumber = 90,
    kXlaForceHostPlatformDeviceCountFieldNumber = 102,
    kXlaStepMarkerLocationFieldNumber = 108,
    kXlaHloEvaluatorUseFastPathFieldNumber = 106,
    kXlaAllowScalarIndexDynamicOpsFieldNumber = 107,
    kXlaDumpHloAsTextFieldNumber = 112,
    kXlaDumpHloAsProtoFieldNumber = 113,
    kXlaTestAllInputLayoutsFieldNumber = 91,
    kXlaHloGraphShardingColorFieldNumber = 92,
    kXlaCpuUseMklDnnFieldNumber = 97,
    kXlaCpuUseXlaRuntimeFieldNumber = 177,
    kXlaCpuEnableFastMathFieldNumber = 99,
    kXlaCpuFastMathHonorNansFieldNumber = 120,
    kXlaCpuFastMathHonorInfsFieldNumber = 121,
    kXlaCpuFastMathHonorDivisionFieldNumber = 126,
    kXlaCpuFastMathHonorFunctionsFieldNumber = 129,
    kXlaCpuEnableFastMinMaxFieldNumber = 140,
    kXlaGpuEnableFastMinMaxFieldNumber = 100,
    kXlaAllowExcessPrecisionFieldNumber = 122,
    kXlaGpuAutotuneLevelFieldNumber = 123,
    kXlaDumpHloAsDotFieldNumber = 114,
    kXlaDumpHloAsUrlFieldNumber = 115,
    kXlaDumpHloAsHtmlFieldNumber = 116,
    kXlaDumpFusionVisualizationFieldNumber = 149,
    kXlaDumpMaxHloModulesFieldNumber = 132,
    kXlaDumpHloSnapshotsFieldNumber = 118,
    kXlaDumpIncludeTimestampFieldNumber = 131,
    kXlaDumpModuleMetadataFieldNumber = 144,
    kXlaDumpCompressProtosFieldNumber = 151,
    kXlaGpuCrashOnVerificationFailuresFieldNumber = 101,
    kXlaGpuDisableGpuasmOptimizationsFieldNumber = 103,
    kXlaGpuEnableMlirLoweringFieldNumber = 173,
    kXlaGpuEnableSoftmaxFusionFieldNumber = 179,
    kXlaMultiheapSizeConstraintPerHeapFieldNumber = 142,
    kXlaGpuUnsafeFallbackToDriverOnPtxasNotFoundFieldNumber = 138,
    kXlaDetailedLoggingAndDumpingFieldNumber = 143,
    kXlaGpuDeterministicOpsFieldNumber = 148,
    kXlaGpuEnableAsyncAllReduceFieldNumber = 152,
    kXlaGpuForceCompilationParallelismFieldNumber = 147,
    kXlaDumpHloAsLongTextFieldNumber = 164,
    kXlaGpuForceConvNchwFieldNumber = 125,
    kXlaGpuForceConvNhwcFieldNumber = 146,
    kXlaGpuDumpLlvmirFieldNumber = 155,
    kXlaDumpEnableMlirPrettyFormFieldNumber = 185,
    kXlaTpuDetectNanFieldNumber = 135,
    kXlaTpuDetectInfFieldNumber = 136,
    kXlaCpuEnableXprofTracemeFieldNumber = 137,
    kXlaGpuAllReduceCombineThresholdBytesFieldNumber = 157,
    kXlaGpuAllReduceBlueconnectNumDevicesPerHostFieldNumber = 159,
    kXlaGpuEnableAsyncCollectivePermuteFieldNumber = 183,
    kXlaGpuAllReduceContiguousFieldNumber = 158,
    kXlaGpuEnableCudnnFrontendFieldNumber = 160,
    kXlaDumpDisableMetadataFieldNumber = 153,
    kXlaGpuNcclTerminationTimeoutSecondsFieldNumber = 163,
    kXlaGpuStrictConvAlgorithmPickerFieldNumber = 156,
    kXlaGpuEnableXlaRuntimeExecutableFieldNumber = 169,
    kXlaGpuEnableSharedConstantsFieldNumber = 165,
    kXlaGpuEnableCublasltFieldNumber = 166,
    kXlaGpuShapeChecksFieldNumber = 170,
    kXlaGpuRedzoneScratchMaxMegabytesFieldNumber = 167,
    kXlaGpuEnableCudaGraphsFieldNumber = 180,
    kXlaGpuSimplifyAllFpConversionsFieldNumber = 168,
    kXlaGpuNormalizeLayoutsFieldNumber = 172,
    kXlaCpuUseAclFieldNumber = 174,
    kXlaCpuStrictDotConvMathFieldNumber = 175,
    kXlaGpuUseRuntimeFusionFieldNumber = 181,
    kXlaDumpLatencyHidingScheduleFieldNumber = 182,
    kXlaCpuEnableMlirTilingAndFusionFieldNumber = 184,
    kXlaGpuEnableLatencyHidingSchedulerFieldNumber = 186,
    kXlaPartitioningAlgorithmFieldNumber = 187,
  };
  // repeated string xla_disable_hlo_passes = 30;
  int xla_disable_hlo_passes_size() const;
  private:
  int _internal_xla_disable_hlo_passes_size() const;
  public:
  void clear_xla_disable_hlo_passes();
  const std::string& xla_disable_hlo_passes(int index) const;
  std::string* mutable_xla_disable_hlo_passes(int index);
  void set_xla_disable_hlo_passes(int index, const std::string& value);
  void set_xla_disable_hlo_passes(int index, std::string&& value);
  void set_xla_disable_hlo_passes(int index, const char* value);
  void set_xla_disable_hlo_passes(int index, const char* value, size_t size);
  std::string* add_xla_disable_hlo_passes();
  void add_xla_disable_hlo_passes(const std::string& value);
  void add_xla_disable_hlo_passes(std::string&& value);
  void add_xla_disable_hlo_passes(const char* value);
  void add_xla_disable_hlo_passes(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& xla_disable_hlo_passes() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_xla_disable_hlo_passes();
  private:
  const std::string& _internal_xla_disable_hlo_passes(int index) const;
  std::string* _internal_add_xla_disable_hlo_passes();
  public:

  // repeated string xla_enable_hlo_passes_only = 124;
  int xla_enable_hlo_passes_only_size() const;
  private:
  int _internal_xla_enable_hlo_passes_only_size() const;
  public:
  void clear_xla_enable_hlo_passes_only();
  const std::string& xla_enable_hlo_passes_only(int index) const;
  std::string* mutable_xla_enable_hlo_passes_only(int index);
  void set_xla_enable_hlo_passes_only(int index, const std::string& value);
  void set_xla_enable_hlo_passes_only(int index, std::string&& value);
  void set_xla_enable_hlo_passes_only(int index, const char* value);
  void set_xla_enable_hlo_passes_only(int index, const char* value, size_t size);
  std::string* add_xla_enable_hlo_passes_only();
  void add_xla_enable_hlo_passes_only(const std::string& value);
  void add_xla_enable_hlo_passes_only(std::string&& value);
  void add_xla_enable_hlo_passes_only(const char* value);
  void add_xla_enable_hlo_passes_only(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& xla_enable_hlo_passes_only() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_xla_enable_hlo_passes_only();
  private:
  const std::string& _internal_xla_enable_hlo_passes_only(int index) const;
  std::string* _internal_add_xla_enable_hlo_passes_only();
  public:

  // repeated string xla_gpu_ptx_file = 127;
  int xla_gpu_ptx_file_size() const;
  private:
  int _internal_xla_gpu_ptx_file_size() const;
  public:
  void clear_xla_gpu_ptx_file();
  const std::string& xla_gpu_ptx_file(int index) const;
  std::string* mutable_xla_gpu_ptx_file(int index);
  void set_xla_gpu_ptx_file(int index, const std::string& value);
  void set_xla_gpu_ptx_file(int index, std::string&& value);
  void set_xla_gpu_ptx_file(int index, const char* value);
  void set_xla_gpu_ptx_file(int index, const char* value, size_t size);
  std::string* add_xla_gpu_ptx_file();
  void add_xla_gpu_ptx_file(const std::string& value);
  void add_xla_gpu_ptx_file(std::string&& value);
  void add_xla_gpu_ptx_file(const char* value);
  void add_xla_gpu_ptx_file(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& xla_gpu_ptx_file() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_xla_gpu_ptx_file();
  private:
  const std::string& _internal_xla_gpu_ptx_file(int index) const;
  std::string* _internal_add_xla_gpu_ptx_file();
  public:

  // repeated string xla_gpu_llvm_ir_file = 150;
  int xla_gpu_llvm_ir_file_size() const;
  private:
  int _internal_xla_gpu_llvm_ir_file_size() const;
  public:
  void clear_xla_gpu_llvm_ir_file();
  const std::string& xla_gpu_llvm_ir_file(int index) const;
  std::string* mutable_xla_gpu_llvm_ir_file(int index);
  void set_xla_gpu_llvm_ir_file(int index, const std::string& value);
  void set_xla_gpu_llvm_ir_file(int index, std::string&& value);
  void set_xla_gpu_llvm_ir_file(int index, const char* value);
  void set_xla_gpu_llvm_ir_file(int index, const char* value, size_t size);
  std::string* add_xla_gpu_llvm_ir_file();
  void add_xla_gpu_llvm_ir_file(const std::string& value);
  void add_xla_gpu_llvm_ir_file(std::string&& value);
  void add_xla_gpu_llvm_ir_file(const char* value);
  void add_xla_gpu_llvm_ir_file(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& xla_gpu_llvm_ir_file() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_xla_gpu_llvm_ir_file();
  private:
  const std::string& _internal_xla_gpu_llvm_ir_file(int index) const;
  std::string* _internal_add_xla_gpu_llvm_ir_file();
  public:

  // map<string, string> xla_backend_extra_options = 500;
  int xla_backend_extra_options_size() const;
  private:
  int _internal_xla_backend_extra_options_size() const;
  public:
  void clear_xla_backend_extra_options();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_xla_backend_extra_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_xla_backend_extra_options();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      xla_backend_extra_options() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_xla_backend_extra_options();

  // string xla_gpu_cuda_data_dir = 61;
  void clear_xla_gpu_cuda_data_dir();
  const std::string& xla_gpu_cuda_data_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_gpu_cuda_data_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_gpu_cuda_data_dir();
  PROTOBUF_NODISCARD std::string* release_xla_gpu_cuda_data_dir();
  void set_allocated_xla_gpu_cuda_data_dir(std::string* xla_gpu_cuda_data_dir);
  private:
  const std::string& _internal_xla_gpu_cuda_data_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_gpu_cuda_data_dir(const std::string& value);
  std::string* _internal_mutable_xla_gpu_cuda_data_dir();
  public:

  // string xla_dump_to = 109;
  void clear_xla_dump_to();
  const std::string& xla_dump_to() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_dump_to(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_dump_to();
  PROTOBUF_NODISCARD std::string* release_xla_dump_to();
  void set_allocated_xla_dump_to(std::string* xla_dump_to);
  private:
  const std::string& _internal_xla_dump_to() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_dump_to(const std::string& value);
  std::string* _internal_mutable_xla_dump_to();
  public:

  // string xla_dump_hlo_module_re = 110;
  void clear_xla_dump_hlo_module_re();
  const std::string& xla_dump_hlo_module_re() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_dump_hlo_module_re(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_dump_hlo_module_re();
  PROTOBUF_NODISCARD std::string* release_xla_dump_hlo_module_re();
  void set_allocated_xla_dump_hlo_module_re(std::string* xla_dump_hlo_module_re);
  private:
  const std::string& _internal_xla_dump_hlo_module_re() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_dump_hlo_module_re(const std::string& value);
  std::string* _internal_mutable_xla_dump_hlo_module_re();
  public:

  // string xla_dump_hlo_pass_re = 111;
  void clear_xla_dump_hlo_pass_re();
  const std::string& xla_dump_hlo_pass_re() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_dump_hlo_pass_re(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_dump_hlo_pass_re();
  PROTOBUF_NODISCARD std::string* release_xla_dump_hlo_pass_re();
  void set_allocated_xla_dump_hlo_pass_re(std::string* xla_dump_hlo_pass_re);
  private:
  const std::string& _internal_xla_dump_hlo_pass_re() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_dump_hlo_pass_re(const std::string& value);
  std::string* _internal_mutable_xla_dump_hlo_pass_re();
  public:

  // string xla_gpu_algorithm_denylist_path = 128;
  void clear_xla_gpu_algorithm_denylist_path();
  const std::string& xla_gpu_algorithm_denylist_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_gpu_algorithm_denylist_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_gpu_algorithm_denylist_path();
  PROTOBUF_NODISCARD std::string* release_xla_gpu_algorithm_denylist_path();
  void set_allocated_xla_gpu_algorithm_denylist_path(std::string* xla_gpu_algorithm_denylist_path);
  private:
  const std::string& _internal_xla_gpu_algorithm_denylist_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_gpu_algorithm_denylist_path(const std::string& value);
  std::string* _internal_mutable_xla_gpu_algorithm_denylist_path();
  public:

  // string xla_gpu_asm_extra_flags = 141;
  void clear_xla_gpu_asm_extra_flags();
  const std::string& xla_gpu_asm_extra_flags() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_gpu_asm_extra_flags(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_gpu_asm_extra_flags();
  PROTOBUF_NODISCARD std::string* release_xla_gpu_asm_extra_flags();
  void set_allocated_xla_gpu_asm_extra_flags(std::string* xla_gpu_asm_extra_flags);
  private:
  const std::string& _internal_xla_gpu_asm_extra_flags() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_gpu_asm_extra_flags(const std::string& value);
  std::string* _internal_mutable_xla_gpu_asm_extra_flags();
  public:

  // string xla_dump_hlo_pipeline_re = 154;
  void clear_xla_dump_hlo_pipeline_re();
  const std::string& xla_dump_hlo_pipeline_re() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xla_dump_hlo_pipeline_re(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xla_dump_hlo_pipeline_re();
  PROTOBUF_NODISCARD std::string* release_xla_dump_hlo_pipeline_re();
  void set_allocated_xla_dump_hlo_pipeline_re(std::string* xla_dump_hlo_pipeline_re);
  private:
  const std::string& _internal_xla_dump_hlo_pipeline_re() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xla_dump_hlo_pipeline_re(const std::string& value);
  std::string* _internal_mutable_xla_dump_hlo_pipeline_re();
  public:

  // int32 xla_backend_optimization_level = 31;
  void clear_xla_backend_optimization_level();
  int32_t xla_backend_optimization_level() const;
  void set_xla_backend_optimization_level(int32_t value);
  private:
  int32_t _internal_xla_backend_optimization_level() const;
  void _internal_set_xla_backend_optimization_level(int32_t value);
  public:

  // bool xla_hlo_graph_addresses = 2;
  void clear_xla_hlo_graph_addresses();
  bool xla_hlo_graph_addresses() const;
  void set_xla_hlo_graph_addresses(bool value);
  private:
  bool _internal_xla_hlo_graph_addresses() const;
  void _internal_set_xla_hlo_graph_addresses(bool value);
  public:

  // bool xla_hlo_profile = 9;
  void clear_xla_hlo_profile();
  bool xla_hlo_profile() const;
  void set_xla_hlo_profile(bool value);
  private:
  bool _internal_xla_hlo_profile() const;
  void _internal_set_xla_hlo_profile(bool value);
  public:

  // bool xla_disable_all_hlo_passes = 104;
  void clear_xla_disable_all_hlo_passes();
  bool xla_disable_all_hlo_passes() const;
  void set_xla_disable_all_hlo_passes(bool value);
  private:
  bool _internal_xla_disable_all_hlo_passes() const;
  void _internal_set_xla_disable_all_hlo_passes(bool value);
  public:

  // bool xla_embed_ir_in_executable = 33;
  void clear_xla_embed_ir_in_executable();
  bool xla_embed_ir_in_executable() const;
  void set_xla_embed_ir_in_executable(bool value);
  private:
  bool _internal_xla_embed_ir_in_executable() const;
  void _internal_set_xla_embed_ir_in_executable(bool value);
  public:

  // bool xla_eliminate_hlo_implicit_broadcast = 35;
  void clear_xla_eliminate_hlo_implicit_broadcast();
  bool xla_eliminate_hlo_implicit_broadcast() const;
  void set_xla_eliminate_hlo_implicit_broadcast(bool value);
  private:
  bool _internal_xla_eliminate_hlo_implicit_broadcast() const;
  void _internal_set_xla_eliminate_hlo_implicit_broadcast(bool value);
  public:

  // bool xla_cpu_multi_thread_eigen = 60;
  void clear_xla_cpu_multi_thread_eigen();
  bool xla_cpu_multi_thread_eigen() const;
  void set_xla_cpu_multi_thread_eigen(bool value);
  private:
  bool _internal_xla_cpu_multi_thread_eigen() const;
  void _internal_set_xla_cpu_multi_thread_eigen(bool value);
  public:

  // bool xla_gpu_ftz = 62;
  void clear_xla_gpu_ftz();
  bool xla_gpu_ftz() const;
  void set_xla_gpu_ftz(bool value);
  private:
  bool _internal_xla_gpu_ftz() const;
  void _internal_set_xla_gpu_ftz(bool value);
  public:

  // bool xla_llvm_enable_alias_scope_metadata = 70;
  void clear_xla_llvm_enable_alias_scope_metadata();
  bool xla_llvm_enable_alias_scope_metadata() const;
  void set_xla_llvm_enable_alias_scope_metadata(bool value);
  private:
  bool _internal_xla_llvm_enable_alias_scope_metadata() const;
  void _internal_set_xla_llvm_enable_alias_scope_metadata(bool value);
  public:

  // bool xla_llvm_enable_noalias_metadata = 71;
  void clear_xla_llvm_enable_noalias_metadata();
  bool xla_llvm_enable_noalias_metadata() const;
  void set_xla_llvm_enable_noalias_metadata(bool value);
  private:
  bool _internal_xla_llvm_enable_noalias_metadata() const;
  void _internal_set_xla_llvm_enable_noalias_metadata(bool value);
  public:

  // bool xla_llvm_enable_invariant_load_metadata = 72;
  void clear_xla_llvm_enable_invariant_load_metadata();
  bool xla_llvm_enable_invariant_load_metadata() const;
  void set_xla_llvm_enable_invariant_load_metadata(bool value);
  private:
  bool _internal_xla_llvm_enable_invariant_load_metadata() const;
  void _internal_set_xla_llvm_enable_invariant_load_metadata(bool value);
  public:

  // bool xla_llvm_disable_expensive_passes = 73;
  void clear_xla_llvm_disable_expensive_passes();
  bool xla_llvm_disable_expensive_passes() const;
  void set_xla_llvm_disable_expensive_passes(bool value);
  private:
  bool _internal_xla_llvm_disable_expensive_passes() const;
  void _internal_set_xla_llvm_disable_expensive_passes(bool value);
  public:

  // bool xla_test_all_output_layouts = 90;
  void clear_xla_test_all_output_layouts();
  bool xla_test_all_output_layouts() const;
  void set_xla_test_all_output_layouts(bool value);
  private:
  bool _internal_xla_test_all_output_layouts() const;
  void _internal_set_xla_test_all_output_layouts(bool value);
  public:

  // int32 xla_force_host_platform_device_count = 102;
  void clear_xla_force_host_platform_device_count();
  int32_t xla_force_host_platform_device_count() const;
  void set_xla_force_host_platform_device_count(int32_t value);
  private:
  int32_t _internal_xla_force_host_platform_device_count() const;
  void _internal_set_xla_force_host_platform_device_count(int32_t value);
  public:

  // .xla.DebugOptions.StepMarkerLocation xla_step_marker_location = 108;
  void clear_xla_step_marker_location();
  ::xla::DebugOptions_StepMarkerLocation xla_step_marker_location() const;
  void set_xla_step_marker_location(::xla::DebugOptions_StepMarkerLocation value);
  private:
  ::xla::DebugOptions_StepMarkerLocation _internal_xla_step_marker_location() const;
  void _internal_set_xla_step_marker_location(::xla::DebugOptions_StepMarkerLocation value);
  public:

  // bool xla_hlo_evaluator_use_fast_path = 106;
  void clear_xla_hlo_evaluator_use_fast_path();
  bool xla_hlo_evaluator_use_fast_path() const;
  void set_xla_hlo_evaluator_use_fast_path(bool value);
  private:
  bool _internal_xla_hlo_evaluator_use_fast_path() const;
  void _internal_set_xla_hlo_evaluator_use_fast_path(bool value);
  public:

  // bool xla_allow_scalar_index_dynamic_ops = 107;
  void clear_xla_allow_scalar_index_dynamic_ops();
  bool xla_allow_scalar_index_dynamic_ops() const;
  void set_xla_allow_scalar_index_dynamic_ops(bool value);
  private:
  bool _internal_xla_allow_scalar_index_dynamic_ops() const;
  void _internal_set_xla_allow_scalar_index_dynamic_ops(bool value);
  public:

  // bool xla_dump_hlo_as_text = 112;
  void clear_xla_dump_hlo_as_text();
  bool xla_dump_hlo_as_text() const;
  void set_xla_dump_hlo_as_text(bool value);
  private:
  bool _internal_xla_dump_hlo_as_text() const;
  void _internal_set_xla_dump_hlo_as_text(bool value);
  public:

  // bool xla_dump_hlo_as_proto = 113;
  void clear_xla_dump_hlo_as_proto();
  bool xla_dump_hlo_as_proto() const;
  void set_xla_dump_hlo_as_proto(bool value);
  private:
  bool _internal_xla_dump_hlo_as_proto() const;
  void _internal_set_xla_dump_hlo_as_proto(bool value);
  public:

  // bool xla_test_all_input_layouts = 91;
  void clear_xla_test_all_input_layouts();
  bool xla_test_all_input_layouts() const;
  void set_xla_test_all_input_layouts(bool value);
  private:
  bool _internal_xla_test_all_input_layouts() const;
  void _internal_set_xla_test_all_input_layouts(bool value);
  public:

  // bool xla_hlo_graph_sharding_color = 92;
  void clear_xla_hlo_graph_sharding_color();
  bool xla_hlo_graph_sharding_color() const;
  void set_xla_hlo_graph_sharding_color(bool value);
  private:
  bool _internal_xla_hlo_graph_sharding_color() const;
  void _internal_set_xla_hlo_graph_sharding_color(bool value);
  public:

  // bool xla_cpu_use_mkl_dnn = 97;
  void clear_xla_cpu_use_mkl_dnn();
  bool xla_cpu_use_mkl_dnn() const;
  void set_xla_cpu_use_mkl_dnn(bool value);
  private:
  bool _internal_xla_cpu_use_mkl_dnn() const;
  void _internal_set_xla_cpu_use_mkl_dnn(bool value);
  public:

  // bool xla_cpu_use_xla_runtime = 177;
  void clear_xla_cpu_use_xla_runtime();
  bool xla_cpu_use_xla_runtime() const;
  void set_xla_cpu_use_xla_runtime(bool value);
  private:
  bool _internal_xla_cpu_use_xla_runtime() const;
  void _internal_set_xla_cpu_use_xla_runtime(bool value);
  public:

  // bool xla_cpu_enable_fast_math = 99;
  void clear_xla_cpu_enable_fast_math();
  bool xla_cpu_enable_fast_math() const;
  void set_xla_cpu_enable_fast_math(bool value);
  private:
  bool _internal_xla_cpu_enable_fast_math() const;
  void _internal_set_xla_cpu_enable_fast_math(bool value);
  public:

  // bool xla_cpu_fast_math_honor_nans = 120;
  void clear_xla_cpu_fast_math_honor_nans();
  bool xla_cpu_fast_math_honor_nans() const;
  void set_xla_cpu_fast_math_honor_nans(bool value);
  private:
  bool _internal_xla_cpu_fast_math_honor_nans() const;
  void _internal_set_xla_cpu_fast_math_honor_nans(bool value);
  public:

  // bool xla_cpu_fast_math_honor_infs = 121;
  void clear_xla_cpu_fast_math_honor_infs();
  bool xla_cpu_fast_math_honor_infs() const;
  void set_xla_cpu_fast_math_honor_infs(bool value);
  private:
  bool _internal_xla_cpu_fast_math_honor_infs() const;
  void _internal_set_xla_cpu_fast_math_honor_infs(bool value);
  public:

  // bool xla_cpu_fast_math_honor_division = 126;
  void clear_xla_cpu_fast_math_honor_division();
  bool xla_cpu_fast_math_honor_division() const;
  void set_xla_cpu_fast_math_honor_division(bool value);
  private:
  bool _internal_xla_cpu_fast_math_honor_division() const;
  void _internal_set_xla_cpu_fast_math_honor_division(bool value);
  public:

  // bool xla_cpu_fast_math_honor_functions = 129;
  void clear_xla_cpu_fast_math_honor_functions();
  bool xla_cpu_fast_math_honor_functions() const;
  void set_xla_cpu_fast_math_honor_functions(bool value);
  private:
  bool _internal_xla_cpu_fast_math_honor_functions() const;
  void _internal_set_xla_cpu_fast_math_honor_functions(bool value);
  public:

  // bool xla_cpu_enable_fast_min_max = 140;
  void clear_xla_cpu_enable_fast_min_max();
  bool xla_cpu_enable_fast_min_max() const;
  void set_xla_cpu_enable_fast_min_max(bool value);
  private:
  bool _internal_xla_cpu_enable_fast_min_max() const;
  void _internal_set_xla_cpu_enable_fast_min_max(bool value);
  public:

  // bool xla_gpu_enable_fast_min_max = 100;
  void clear_xla_gpu_enable_fast_min_max();
  bool xla_gpu_enable_fast_min_max() const;
  void set_xla_gpu_enable_fast_min_max(bool value);
  private:
  bool _internal_xla_gpu_enable_fast_min_max() const;
  void _internal_set_xla_gpu_enable_fast_min_max(bool value);
  public:

  // bool xla_allow_excess_precision = 122;
  void clear_xla_allow_excess_precision();
  bool xla_allow_excess_precision() const;
  void set_xla_allow_excess_precision(bool value);
  private:
  bool _internal_xla_allow_excess_precision() const;
  void _internal_set_xla_allow_excess_precision(bool value);
  public:

  // int32 xla_gpu_autotune_level = 123;
  void clear_xla_gpu_autotune_level();
  int32_t xla_gpu_autotune_level() const;
  void set_xla_gpu_autotune_level(int32_t value);
  private:
  int32_t _internal_xla_gpu_autotune_level() const;
  void _internal_set_xla_gpu_autotune_level(int32_t value);
  public:

  // bool xla_dump_hlo_as_dot = 114;
  void clear_xla_dump_hlo_as_dot();
  bool xla_dump_hlo_as_dot() const;
  void set_xla_dump_hlo_as_dot(bool value);
  private:
  bool _internal_xla_dump_hlo_as_dot() const;
  void _internal_set_xla_dump_hlo_as_dot(bool value);
  public:

  // bool xla_dump_hlo_as_url = 115;
  void clear_xla_dump_hlo_as_url();
  bool xla_dump_hlo_as_url() const;
  void set_xla_dump_hlo_as_url(bool value);
  private:
  bool _internal_xla_dump_hlo_as_url() const;
  void _internal_set_xla_dump_hlo_as_url(bool value);
  public:

  // bool xla_dump_hlo_as_html = 116;
  void clear_xla_dump_hlo_as_html();
  bool xla_dump_hlo_as_html() const;
  void set_xla_dump_hlo_as_html(bool value);
  private:
  bool _internal_xla_dump_hlo_as_html() const;
  void _internal_set_xla_dump_hlo_as_html(bool value);
  public:

  // bool xla_dump_fusion_visualization = 149;
  void clear_xla_dump_fusion_visualization();
  bool xla_dump_fusion_visualization() const;
  void set_xla_dump_fusion_visualization(bool value);
  private:
  bool _internal_xla_dump_fusion_visualization() const;
  void _internal_set_xla_dump_fusion_visualization(bool value);
  public:

  // int32 xla_dump_max_hlo_modules = 132;
  void clear_xla_dump_max_hlo_modules();
  int32_t xla_dump_max_hlo_modules() const;
  void set_xla_dump_max_hlo_modules(int32_t value);
  private:
  int32_t _internal_xla_dump_max_hlo_modules() const;
  void _internal_set_xla_dump_max_hlo_modules(int32_t value);
  public:

  // bool xla_dump_hlo_snapshots = 118;
  void clear_xla_dump_hlo_snapshots();
  bool xla_dump_hlo_snapshots() const;
  void set_xla_dump_hlo_snapshots(bool value);
  private:
  bool _internal_xla_dump_hlo_snapshots() const;
  void _internal_set_xla_dump_hlo_snapshots(bool value);
  public:

  // bool xla_dump_include_timestamp = 131;
  void clear_xla_dump_include_timestamp();
  bool xla_dump_include_timestamp() const;
  void set_xla_dump_include_timestamp(bool value);
  private:
  bool _internal_xla_dump_include_timestamp() const;
  void _internal_set_xla_dump_include_timestamp(bool value);
  public:

  // bool xla_dump_module_metadata = 144;
  void clear_xla_dump_module_metadata();
  bool xla_dump_module_metadata() const;
  void set_xla_dump_module_metadata(bool value);
  private:
  bool _internal_xla_dump_module_metadata() const;
  void _internal_set_xla_dump_module_metadata(bool value);
  public:

  // bool xla_dump_compress_protos = 151;
  void clear_xla_dump_compress_protos();
  bool xla_dump_compress_protos() const;
  void set_xla_dump_compress_protos(bool value);
  private:
  bool _internal_xla_dump_compress_protos() const;
  void _internal_set_xla_dump_compress_protos(bool value);
  public:

  // bool xla_gpu_crash_on_verification_failures = 101;
  void clear_xla_gpu_crash_on_verification_failures();
  bool xla_gpu_crash_on_verification_failures() const;
  void set_xla_gpu_crash_on_verification_failures(bool value);
  private:
  bool _internal_xla_gpu_crash_on_verification_failures() const;
  void _internal_set_xla_gpu_crash_on_verification_failures(bool value);
  public:

  // bool xla_gpu_disable_gpuasm_optimizations = 103;
  void clear_xla_gpu_disable_gpuasm_optimizations();
  bool xla_gpu_disable_gpuasm_optimizations() const;
  void set_xla_gpu_disable_gpuasm_optimizations(bool value);
  private:
  bool _internal_xla_gpu_disable_gpuasm_optimizations() const;
  void _internal_set_xla_gpu_disable_gpuasm_optimizations(bool value);
  public:

  // bool xla_gpu_enable_mlir_lowering = 173;
  void clear_xla_gpu_enable_mlir_lowering();
  bool xla_gpu_enable_mlir_lowering() const;
  void set_xla_gpu_enable_mlir_lowering(bool value);
  private:
  bool _internal_xla_gpu_enable_mlir_lowering() const;
  void _internal_set_xla_gpu_enable_mlir_lowering(bool value);
  public:

  // bool xla_gpu_enable_softmax_fusion = 179;
  void clear_xla_gpu_enable_softmax_fusion();
  bool xla_gpu_enable_softmax_fusion() const;
  void set_xla_gpu_enable_softmax_fusion(bool value);
  private:
  bool _internal_xla_gpu_enable_softmax_fusion() const;
  void _internal_set_xla_gpu_enable_softmax_fusion(bool value);
  public:

  // int32 xla_multiheap_size_constraint_per_heap = 142;
  void clear_xla_multiheap_size_constraint_per_heap();
  int32_t xla_multiheap_size_constraint_per_heap() const;
  void set_xla_multiheap_size_constraint_per_heap(int32_t value);
  private:
  int32_t _internal_xla_multiheap_size_constraint_per_heap() const;
  void _internal_set_xla_multiheap_size_constraint_per_heap(int32_t value);
  public:

  // bool xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found = 138;
  void clear_xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found();
  bool xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found() const;
  void set_xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found(bool value);
  private:
  bool _internal_xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found() const;
  void _internal_set_xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found(bool value);
  public:

  // bool xla_detailed_logging_and_dumping = 143;
  void clear_xla_detailed_logging_and_dumping();
  bool xla_detailed_logging_and_dumping() const;
  void set_xla_detailed_logging_and_dumping(bool value);
  private:
  bool _internal_xla_detailed_logging_and_dumping() const;
  void _internal_set_xla_detailed_logging_and_dumping(bool value);
  public:

  // bool xla_gpu_deterministic_ops = 148;
  void clear_xla_gpu_deterministic_ops();
  bool xla_gpu_deterministic_ops() const;
  void set_xla_gpu_deterministic_ops(bool value);
  private:
  bool _internal_xla_gpu_deterministic_ops() const;
  void _internal_set_xla_gpu_deterministic_ops(bool value);
  public:

  // bool xla_gpu_enable_async_all_reduce = 152;
  void clear_xla_gpu_enable_async_all_reduce();
  bool xla_gpu_enable_async_all_reduce() const;
  void set_xla_gpu_enable_async_all_reduce(bool value);
  private:
  bool _internal_xla_gpu_enable_async_all_reduce() const;
  void _internal_set_xla_gpu_enable_async_all_reduce(bool value);
  public:

  // int32 xla_gpu_force_compilation_parallelism = 147;
  void clear_xla_gpu_force_compilation_parallelism();
  int32_t xla_gpu_force_compilation_parallelism() const;
  void set_xla_gpu_force_compilation_parallelism(int32_t value);
  private:
  int32_t _internal_xla_gpu_force_compilation_parallelism() const;
  void _internal_set_xla_gpu_force_compilation_parallelism(int32_t value);
  public:

  // bool xla_dump_hlo_as_long_text = 164;
  void clear_xla_dump_hlo_as_long_text();
  bool xla_dump_hlo_as_long_text() const;
  void set_xla_dump_hlo_as_long_text(bool value);
  private:
  bool _internal_xla_dump_hlo_as_long_text() const;
  void _internal_set_xla_dump_hlo_as_long_text(bool value);
  public:

  // bool xla_gpu_force_conv_nchw = 125;
  void clear_xla_gpu_force_conv_nchw();
  bool xla_gpu_force_conv_nchw() const;
  void set_xla_gpu_force_conv_nchw(bool value);
  private:
  bool _internal_xla_gpu_force_conv_nchw() const;
  void _internal_set_xla_gpu_force_conv_nchw(bool value);
  public:

  // bool xla_gpu_force_conv_nhwc = 146;
  void clear_xla_gpu_force_conv_nhwc();
  bool xla_gpu_force_conv_nhwc() const;
  void set_xla_gpu_force_conv_nhwc(bool value);
  private:
  bool _internal_xla_gpu_force_conv_nhwc() const;
  void _internal_set_xla_gpu_force_conv_nhwc(bool value);
  public:

  // bool xla_gpu_dump_llvmir = 155;
  void clear_xla_gpu_dump_llvmir();
  bool xla_gpu_dump_llvmir() const;
  void set_xla_gpu_dump_llvmir(bool value);
  private:
  bool _internal_xla_gpu_dump_llvmir() const;
  void _internal_set_xla_gpu_dump_llvmir(bool value);
  public:

  // bool xla_dump_enable_mlir_pretty_form = 185;
  void clear_xla_dump_enable_mlir_pretty_form();
  bool xla_dump_enable_mlir_pretty_form() const;
  void set_xla_dump_enable_mlir_pretty_form(bool value);
  private:
  bool _internal_xla_dump_enable_mlir_pretty_form() const;
  void _internal_set_xla_dump_enable_mlir_pretty_form(bool value);
  public:

  // bool xla_tpu_detect_nan = 135;
  void clear_xla_tpu_detect_nan();
  bool xla_tpu_detect_nan() const;
  void set_xla_tpu_detect_nan(bool value);
  private:
  bool _internal_xla_tpu_detect_nan() const;
  void _internal_set_xla_tpu_detect_nan(bool value);
  public:

  // bool xla_tpu_detect_inf = 136;
  void clear_xla_tpu_detect_inf();
  bool xla_tpu_detect_inf() const;
  void set_xla_tpu_detect_inf(bool value);
  private:
  bool _internal_xla_tpu_detect_inf() const;
  void _internal_set_xla_tpu_detect_inf(bool value);
  public:

  // bool xla_cpu_enable_xprof_traceme = 137;
  void clear_xla_cpu_enable_xprof_traceme();
  bool xla_cpu_enable_xprof_traceme() const;
  void set_xla_cpu_enable_xprof_traceme(bool value);
  private:
  bool _internal_xla_cpu_enable_xprof_traceme() const;
  void _internal_set_xla_cpu_enable_xprof_traceme(bool value);
  public:

  // int64 xla_gpu_all_reduce_combine_threshold_bytes = 157;
  void clear_xla_gpu_all_reduce_combine_threshold_bytes();
  int64_t xla_gpu_all_reduce_combine_threshold_bytes() const;
  void set_xla_gpu_all_reduce_combine_threshold_bytes(int64_t value);
  private:
  int64_t _internal_xla_gpu_all_reduce_combine_threshold_bytes() const;
  void _internal_set_xla_gpu_all_reduce_combine_threshold_bytes(int64_t value);
  public:

  // int32 xla_gpu_all_reduce_blueconnect_num_devices_per_host = 159;
  void clear_xla_gpu_all_reduce_blueconnect_num_devices_per_host();
  int32_t xla_gpu_all_reduce_blueconnect_num_devices_per_host() const;
  void set_xla_gpu_all_reduce_blueconnect_num_devices_per_host(int32_t value);
  private:
  int32_t _internal_xla_gpu_all_reduce_blueconnect_num_devices_per_host() const;
  void _internal_set_xla_gpu_all_reduce_blueconnect_num_devices_per_host(int32_t value);
  public:

  // bool xla_gpu_enable_async_collective_permute = 183;
  void clear_xla_gpu_enable_async_collective_permute();
  bool xla_gpu_enable_async_collective_permute() const;
  void set_xla_gpu_enable_async_collective_permute(bool value);
  private:
  bool _internal_xla_gpu_enable_async_collective_permute() const;
  void _internal_set_xla_gpu_enable_async_collective_permute(bool value);
  public:

  // bool xla_gpu_all_reduce_contiguous = 158;
  void clear_xla_gpu_all_reduce_contiguous();
  bool xla_gpu_all_reduce_contiguous() const;
  void set_xla_gpu_all_reduce_contiguous(bool value);
  private:
  bool _internal_xla_gpu_all_reduce_contiguous() const;
  void _internal_set_xla_gpu_all_reduce_contiguous(bool value);
  public:

  // bool xla_gpu_enable_cudnn_frontend = 160;
  void clear_xla_gpu_enable_cudnn_frontend();
  bool xla_gpu_enable_cudnn_frontend() const;
  void set_xla_gpu_enable_cudnn_frontend(bool value);
  private:
  bool _internal_xla_gpu_enable_cudnn_frontend() const;
  void _internal_set_xla_gpu_enable_cudnn_frontend(bool value);
  public:

  // bool xla_dump_disable_metadata = 153;
  void clear_xla_dump_disable_metadata();
  bool xla_dump_disable_metadata() const;
  void set_xla_dump_disable_metadata(bool value);
  private:
  bool _internal_xla_dump_disable_metadata() const;
  void _internal_set_xla_dump_disable_metadata(bool value);
  public:

  // int64 xla_gpu_nccl_termination_timeout_seconds = 163;
  void clear_xla_gpu_nccl_termination_timeout_seconds();
  int64_t xla_gpu_nccl_termination_timeout_seconds() const;
  void set_xla_gpu_nccl_termination_timeout_seconds(int64_t value);
  private:
  int64_t _internal_xla_gpu_nccl_termination_timeout_seconds() const;
  void _internal_set_xla_gpu_nccl_termination_timeout_seconds(int64_t value);
  public:

  // bool xla_gpu_strict_conv_algorithm_picker = 156;
  void clear_xla_gpu_strict_conv_algorithm_picker();
  bool xla_gpu_strict_conv_algorithm_picker() const;
  void set_xla_gpu_strict_conv_algorithm_picker(bool value);
  private:
  bool _internal_xla_gpu_strict_conv_algorithm_picker() const;
  void _internal_set_xla_gpu_strict_conv_algorithm_picker(bool value);
  public:

  // bool xla_gpu_enable_xla_runtime_executable = 169;
  void clear_xla_gpu_enable_xla_runtime_executable();
  bool xla_gpu_enable_xla_runtime_executable() const;
  void set_xla_gpu_enable_xla_runtime_executable(bool value);
  private:
  bool _internal_xla_gpu_enable_xla_runtime_executable() const;
  void _internal_set_xla_gpu_enable_xla_runtime_executable(bool value);
  public:

  // bool xla_gpu_enable_shared_constants = 165;
  void clear_xla_gpu_enable_shared_constants();
  bool xla_gpu_enable_shared_constants() const;
  void set_xla_gpu_enable_shared_constants(bool value);
  private:
  bool _internal_xla_gpu_enable_shared_constants() const;
  void _internal_set_xla_gpu_enable_shared_constants(bool value);
  public:

  // bool xla_gpu_enable_cublaslt = 166;
  void clear_xla_gpu_enable_cublaslt();
  bool xla_gpu_enable_cublaslt() const;
  void set_xla_gpu_enable_cublaslt(bool value);
  private:
  bool _internal_xla_gpu_enable_cublaslt() const;
  void _internal_set_xla_gpu_enable_cublaslt(bool value);
  public:

  // .xla.DebugOptions.ShapeChecks xla_gpu_shape_checks = 170;
  void clear_xla_gpu_shape_checks();
  ::xla::DebugOptions_ShapeChecks xla_gpu_shape_checks() const;
  void set_xla_gpu_shape_checks(::xla::DebugOptions_ShapeChecks value);
  private:
  ::xla::DebugOptions_ShapeChecks _internal_xla_gpu_shape_checks() const;
  void _internal_set_xla_gpu_shape_checks(::xla::DebugOptions_ShapeChecks value);
  public:

  // int64 xla_gpu_redzone_scratch_max_megabytes = 167;
  void clear_xla_gpu_redzone_scratch_max_megabytes();
  int64_t xla_gpu_redzone_scratch_max_megabytes() const;
  void set_xla_gpu_redzone_scratch_max_megabytes(int64_t value);
  private:
  int64_t _internal_xla_gpu_redzone_scratch_max_megabytes() const;
  void _internal_set_xla_gpu_redzone_scratch_max_megabytes(int64_t value);
  public:

  // bool xla_gpu_enable_cuda_graphs = 180;
  void clear_xla_gpu_enable_cuda_graphs();
  bool xla_gpu_enable_cuda_graphs() const;
  void set_xla_gpu_enable_cuda_graphs(bool value);
  private:
  bool _internal_xla_gpu_enable_cuda_graphs() const;
  void _internal_set_xla_gpu_enable_cuda_graphs(bool value);
  public:

  // bool xla_gpu_simplify_all_fp_conversions = 168;
  void clear_xla_gpu_simplify_all_fp_conversions();
  bool xla_gpu_simplify_all_fp_conversions() const;
  void set_xla_gpu_simplify_all_fp_conversions(bool value);
  private:
  bool _internal_xla_gpu_simplify_all_fp_conversions() const;
  void _internal_set_xla_gpu_simplify_all_fp_conversions(bool value);
  public:

  // bool xla_gpu_normalize_layouts = 172;
  void clear_xla_gpu_normalize_layouts();
  bool xla_gpu_normalize_layouts() const;
  void set_xla_gpu_normalize_layouts(bool value);
  private:
  bool _internal_xla_gpu_normalize_layouts() const;
  void _internal_set_xla_gpu_normalize_layouts(bool value);
  public:

  // bool xla_cpu_use_acl = 174;
  void clear_xla_cpu_use_acl();
  bool xla_cpu_use_acl() const;
  void set_xla_cpu_use_acl(bool value);
  private:
  bool _internal_xla_cpu_use_acl() const;
  void _internal_set_xla_cpu_use_acl(bool value);
  public:

  // bool xla_cpu_strict_dot_conv_math = 175;
  void clear_xla_cpu_strict_dot_conv_math();
  bool xla_cpu_strict_dot_conv_math() const;
  void set_xla_cpu_strict_dot_conv_math(bool value);
  private:
  bool _internal_xla_cpu_strict_dot_conv_math() const;
  void _internal_set_xla_cpu_strict_dot_conv_math(bool value);
  public:

  // bool xla_gpu_use_runtime_fusion = 181;
  void clear_xla_gpu_use_runtime_fusion();
  bool xla_gpu_use_runtime_fusion() const;
  void set_xla_gpu_use_runtime_fusion(bool value);
  private:
  bool _internal_xla_gpu_use_runtime_fusion() const;
  void _internal_set_xla_gpu_use_runtime_fusion(bool value);
  public:

  // bool xla_dump_latency_hiding_schedule = 182;
  void clear_xla_dump_latency_hiding_schedule();
  bool xla_dump_latency_hiding_schedule() const;
  void set_xla_dump_latency_hiding_schedule(bool value);
  private:
  bool _internal_xla_dump_latency_hiding_schedule() const;
  void _internal_set_xla_dump_latency_hiding_schedule(bool value);
  public:

  // bool xla_cpu_enable_mlir_tiling_and_fusion = 184;
  void clear_xla_cpu_enable_mlir_tiling_and_fusion();
  bool xla_cpu_enable_mlir_tiling_and_fusion() const;
  void set_xla_cpu_enable_mlir_tiling_and_fusion(bool value);
  private:
  bool _internal_xla_cpu_enable_mlir_tiling_and_fusion() const;
  void _internal_set_xla_cpu_enable_mlir_tiling_and_fusion(bool value);
  public:

  // bool xla_gpu_enable_latency_hiding_scheduler = 186;
  void clear_xla_gpu_enable_latency_hiding_scheduler();
  bool xla_gpu_enable_latency_hiding_scheduler() const;
  void set_xla_gpu_enable_latency_hiding_scheduler(bool value);
  private:
  bool _internal_xla_gpu_enable_latency_hiding_scheduler() const;
  void _internal_set_xla_gpu_enable_latency_hiding_scheduler(bool value);
  public:

  // .xla.DebugOptions.PartitioningAlgorithm xla_partitioning_algorithm = 187;
  void clear_xla_partitioning_algorithm();
  ::xla::DebugOptions_PartitioningAlgorithm xla_partitioning_algorithm() const;
  void set_xla_partitioning_algorithm(::xla::DebugOptions_PartitioningAlgorithm value);
  private:
  ::xla::DebugOptions_PartitioningAlgorithm _internal_xla_partitioning_algorithm() const;
  void _internal_set_xla_partitioning_algorithm(::xla::DebugOptions_PartitioningAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:xla.DebugOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> xla_disable_hlo_passes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> xla_enable_hlo_passes_only_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> xla_gpu_ptx_file_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> xla_gpu_llvm_ir_file_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        DebugOptions_XlaBackendExtraOptionsEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> xla_backend_extra_options_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_gpu_cuda_data_dir_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_dump_to_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_dump_hlo_module_re_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_dump_hlo_pass_re_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_gpu_algorithm_denylist_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_gpu_asm_extra_flags_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xla_dump_hlo_pipeline_re_;
    int32_t xla_backend_optimization_level_;
    bool xla_hlo_graph_addresses_;
    bool xla_hlo_profile_;
    bool xla_disable_all_hlo_passes_;
    bool xla_embed_ir_in_executable_;
    bool xla_eliminate_hlo_implicit_broadcast_;
    bool xla_cpu_multi_thread_eigen_;
    bool xla_gpu_ftz_;
    bool xla_llvm_enable_alias_scope_metadata_;
    bool xla_llvm_enable_noalias_metadata_;
    bool xla_llvm_enable_invariant_load_metadata_;
    bool xla_llvm_disable_expensive_passes_;
    bool xla_test_all_output_layouts_;
    int32_t xla_force_host_platform_device_count_;
    int xla_step_marker_location_;
    bool xla_hlo_evaluator_use_fast_path_;
    bool xla_allow_scalar_index_dynamic_ops_;
    bool xla_dump_hlo_as_text_;
    bool xla_dump_hlo_as_proto_;
    bool xla_test_all_input_layouts_;
    bool xla_hlo_graph_sharding_color_;
    bool xla_cpu_use_mkl_dnn_;
    bool xla_cpu_use_xla_runtime_;
    bool xla_cpu_enable_fast_math_;
    bool xla_cpu_fast_math_honor_nans_;
    bool xla_cpu_fast_math_honor_infs_;
    bool xla_cpu_fast_math_honor_division_;
    bool xla_cpu_fast_math_honor_functions_;
    bool xla_cpu_enable_fast_min_max_;
    bool xla_gpu_enable_fast_min_max_;
    bool xla_allow_excess_precision_;
    int32_t xla_gpu_autotune_level_;
    bool xla_dump_hlo_as_dot_;
    bool xla_dump_hlo_as_url_;
    bool xla_dump_hlo_as_html_;
    bool xla_dump_fusion_visualization_;
    int32_t xla_dump_max_hlo_modules_;
    bool xla_dump_hlo_snapshots_;
    bool xla_dump_include_timestamp_;
    bool xla_dump_module_metadata_;
    bool xla_dump_compress_protos_;
    bool xla_gpu_crash_on_verification_failures_;
    bool xla_gpu_disable_gpuasm_optimizations_;
    bool xla_gpu_enable_mlir_lowering_;
    bool xla_gpu_enable_softmax_fusion_;
    int32_t xla_multiheap_size_constraint_per_heap_;
    bool xla_gpu_unsafe_fallback_to_driver_on_ptxas_not_found_;
    bool xla_detailed_logging_and_dumping_;
    bool xla_gpu_deterministic_ops_;
    bool xla_gpu_enable_async_all_reduce_;
    int32_t xla_gpu_force_compilation_parallelism_;
    bool xla_dump_hlo_as_long_text_;
    bool xla_gpu_force_conv_nchw_;
    bool xla_gpu_force_conv_nhwc_;
    bool xla_gpu_dump_llvmir_;
    bool xla_dump_enable_mlir_pretty_form_;
    bool xla_tpu_detect_nan_;
    bool xla_tpu_detect_inf_;
    bool xla_cpu_enable_xprof_traceme_;
    int64_t xla_gpu_all_reduce_combine_threshold_bytes_;
    int32_t xla_gpu_all_reduce_blueconnect_num_devices_per_host_;
    bool xla_gpu_enable_async_collective_permute_;
    bool xla_gpu_all_reduce_contiguous_;
    bool xla_gpu_enable_cudnn_frontend_;
    bool xla_dump_disable_metadata_;
    int64_t xla_gpu_nccl_termination_timeout_seconds_;
    bool xla_gpu_strict_conv_algorithm_picker_;
    bool xla_gpu_enable_xla_runtime_executable_;
    bool xla_gpu_enable_shared_constants_;
    bool xla_gpu_enable_cublaslt_;
    int xla_gpu_shape_checks_;
    int64_t xla_gpu_redzone_scratch_max_megabytes_;
    bool xla_gpu_enable_cuda_graphs_;
    bool xla_gpu_simplify_all_fp_conversions_;
    bool xla_gpu_normalize_layouts_;
    bool xla_cpu_use_acl_;
    bool xla_cpu_strict_dot_conv_math_;
    bool xla_gpu_use_runtime_fusion_;
    bool xla_dump_latency_hiding_schedule_;
    bool xla_cpu_enable_mlir_tiling_and_fusion_;
    bool xla_gpu_enable_latency_hiding_scheduler_;
    int xla_partitioning_algorithm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class ShardableValueUpdatePairProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ShardableValueUpdatePairProto) */ {
 public:
  inline ShardableValueUpdatePairProto() : ShardableValueUpdatePairProto(nullptr) {}
  ~ShardableValueUpdatePairProto() override;
  explicit PROTOBUF_CONSTEXPR ShardableValueUpdatePairProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShardableValueUpdatePairProto(const ShardableValueUpdatePairProto& from);
  ShardableValueUpdatePairProto(ShardableValueUpdatePairProto&& from) noexcept
    : ShardableValueUpdatePairProto() {
    *this = ::std::move(from);
  }

  inline ShardableValueUpdatePairProto& operator=(const ShardableValueUpdatePairProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShardableValueUpdatePairProto& operator=(ShardableValueUpdatePairProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShardableValueUpdatePairProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShardableValueUpdatePairProto* internal_default_instance() {
    return reinterpret_cast<const ShardableValueUpdatePairProto*>(
               &_ShardableValueUpdatePairProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ShardableValueUpdatePairProto& a, ShardableValueUpdatePairProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ShardableValueUpdatePairProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShardableValueUpdatePairProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShardableValueUpdatePairProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShardableValueUpdatePairProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShardableValueUpdatePairProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShardableValueUpdatePairProto& from) {
    ShardableValueUpdatePairProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShardableValueUpdatePairProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ShardableValueUpdatePairProto";
  }
  protected:
  explicit ShardableValueUpdatePairProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParameterShapeIndexFieldNumber = 2,
    kOutputShapeIndexFieldNumber = 3,
    kInputParameterNumberFieldNumber = 1,
  };
  // repeated int64 parameter_shape_index = 2;
  int parameter_shape_index_size() const;
  private:
  int _internal_parameter_shape_index_size() const;
  public:
  void clear_parameter_shape_index();
  private:
  int64_t _internal_parameter_shape_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_parameter_shape_index() const;
  void _internal_add_parameter_shape_index(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_parameter_shape_index();
  public:
  int64_t parameter_shape_index(int index) const;
  void set_parameter_shape_index(int index, int64_t value);
  void add_parameter_shape_index(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      parameter_shape_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_parameter_shape_index();

  // repeated int64 output_shape_index = 3;
  int output_shape_index_size() const;
  private:
  int _internal_output_shape_index_size() const;
  public:
  void clear_output_shape_index();
  private:
  int64_t _internal_output_shape_index(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_output_shape_index() const;
  void _internal_add_output_shape_index(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_output_shape_index();
  public:
  int64_t output_shape_index(int index) const;
  void set_output_shape_index(int index, int64_t value);
  void add_output_shape_index(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      output_shape_index() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_output_shape_index();

  // int64 input_parameter_number = 1;
  void clear_input_parameter_number();
  int64_t input_parameter_number() const;
  void set_input_parameter_number(int64_t value);
  private:
  int64_t _internal_input_parameter_number() const;
  void _internal_set_input_parameter_number(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ShardableValueUpdatePairProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > parameter_shape_index_;
    mutable std::atomic<int> _parameter_shape_index_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > output_shape_index_;
    mutable std::atomic<int> _output_shape_index_cached_byte_size_;
    int64_t input_parameter_number_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class ExecutionOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ExecutionOptions) */ {
 public:
  inline ExecutionOptions() : ExecutionOptions(nullptr) {}
  ~ExecutionOptions() override;
  explicit PROTOBUF_CONSTEXPR ExecutionOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionOptions(const ExecutionOptions& from);
  ExecutionOptions(ExecutionOptions&& from) noexcept
    : ExecutionOptions() {
    *this = ::std::move(from);
  }

  inline ExecutionOptions& operator=(const ExecutionOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionOptions& operator=(ExecutionOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionOptions* internal_default_instance() {
    return reinterpret_cast<const ExecutionOptions*>(
               &_ExecutionOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ExecutionOptions& a, ExecutionOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionOptions& from) {
    ExecutionOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ExecutionOptions";
  }
  protected:
  explicit ExecutionOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceHandlesFieldNumber = 5,
    kAutoSpmdPartitioningMeshShapeFieldNumber = 16,
    kAutoSpmdPartitioningMeshIdsFieldNumber = 17,
    kParamRequiresBroadcastViaCollectivesFieldNumber = 18,
    kShardableValueUpdatePairsFieldNumber = 20,
    kShapeWithOutputLayoutFieldNumber = 2,
    kDebugOptionsFieldNumber = 4,
    kDeviceAssignmentFieldNumber = 7,
    kSeedFieldNumber = 3,
    kNumReplicasFieldNumber = 6,
    kNumPartitionsFieldNumber = 9,
    kLaunchIdFieldNumber = 10,
    kAliasPassthroughParamsFieldNumber = 8,
    kUseSpmdPartitioningFieldNumber = 11,
    kUseAutoSpmdPartitioningFieldNumber = 15,
    kDeduplicateHloFieldNumber = 12,
    kAllowSpmdShardingPropagationToOutputFieldNumber = 14,
    kAllowSeparateShardingProgramsFieldNumber = 19,
  };
  // repeated .xla.DeviceHandle device_handles = 5;
  int device_handles_size() const;
  private:
  int _internal_device_handles_size() const;
  public:
  void clear_device_handles();
  ::xla::DeviceHandle* mutable_device_handles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceHandle >*
      mutable_device_handles();
  private:
  const ::xla::DeviceHandle& _internal_device_handles(int index) const;
  ::xla::DeviceHandle* _internal_add_device_handles();
  public:
  const ::xla::DeviceHandle& device_handles(int index) const;
  ::xla::DeviceHandle* add_device_handles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceHandle >&
      device_handles() const;

  // repeated int64 auto_spmd_partitioning_mesh_shape = 16;
  int auto_spmd_partitioning_mesh_shape_size() const;
  private:
  int _internal_auto_spmd_partitioning_mesh_shape_size() const;
  public:
  void clear_auto_spmd_partitioning_mesh_shape();
  private:
  int64_t _internal_auto_spmd_partitioning_mesh_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_auto_spmd_partitioning_mesh_shape() const;
  void _internal_add_auto_spmd_partitioning_mesh_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_auto_spmd_partitioning_mesh_shape();
  public:
  int64_t auto_spmd_partitioning_mesh_shape(int index) const;
  void set_auto_spmd_partitioning_mesh_shape(int index, int64_t value);
  void add_auto_spmd_partitioning_mesh_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      auto_spmd_partitioning_mesh_shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_auto_spmd_partitioning_mesh_shape();

  // repeated int64 auto_spmd_partitioning_mesh_ids = 17;
  int auto_spmd_partitioning_mesh_ids_size() const;
  private:
  int _internal_auto_spmd_partitioning_mesh_ids_size() const;
  public:
  void clear_auto_spmd_partitioning_mesh_ids();
  private:
  int64_t _internal_auto_spmd_partitioning_mesh_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_auto_spmd_partitioning_mesh_ids() const;
  void _internal_add_auto_spmd_partitioning_mesh_ids(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_auto_spmd_partitioning_mesh_ids();
  public:
  int64_t auto_spmd_partitioning_mesh_ids(int index) const;
  void set_auto_spmd_partitioning_mesh_ids(int index, int64_t value);
  void add_auto_spmd_partitioning_mesh_ids(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      auto_spmd_partitioning_mesh_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_auto_spmd_partitioning_mesh_ids();

  // repeated bool param_requires_broadcast_via_collectives = 18;
  int param_requires_broadcast_via_collectives_size() const;
  private:
  int _internal_param_requires_broadcast_via_collectives_size() const;
  public:
  void clear_param_requires_broadcast_via_collectives();
  private:
  bool _internal_param_requires_broadcast_via_collectives(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_param_requires_broadcast_via_collectives() const;
  void _internal_add_param_requires_broadcast_via_collectives(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_param_requires_broadcast_via_collectives();
  public:
  bool param_requires_broadcast_via_collectives(int index) const;
  void set_param_requires_broadcast_via_collectives(int index, bool value);
  void add_param_requires_broadcast_via_collectives(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      param_requires_broadcast_via_collectives() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_param_requires_broadcast_via_collectives();

  // repeated .xla.ShardableValueUpdatePairProto shardable_value_update_pairs = 20;
  int shardable_value_update_pairs_size() const;
  private:
  int _internal_shardable_value_update_pairs_size() const;
  public:
  void clear_shardable_value_update_pairs();
  ::xla::ShardableValueUpdatePairProto* mutable_shardable_value_update_pairs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShardableValueUpdatePairProto >*
      mutable_shardable_value_update_pairs();
  private:
  const ::xla::ShardableValueUpdatePairProto& _internal_shardable_value_update_pairs(int index) const;
  ::xla::ShardableValueUpdatePairProto* _internal_add_shardable_value_update_pairs();
  public:
  const ::xla::ShardableValueUpdatePairProto& shardable_value_update_pairs(int index) const;
  ::xla::ShardableValueUpdatePairProto* add_shardable_value_update_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShardableValueUpdatePairProto >&
      shardable_value_update_pairs() const;

  // .xla.ShapeProto shape_with_output_layout = 2;
  bool has_shape_with_output_layout() const;
  private:
  bool _internal_has_shape_with_output_layout() const;
  public:
  void clear_shape_with_output_layout();
  const ::xla::ShapeProto& shape_with_output_layout() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_shape_with_output_layout();
  ::xla::ShapeProto* mutable_shape_with_output_layout();
  void set_allocated_shape_with_output_layout(::xla::ShapeProto* shape_with_output_layout);
  private:
  const ::xla::ShapeProto& _internal_shape_with_output_layout() const;
  ::xla::ShapeProto* _internal_mutable_shape_with_output_layout();
  public:
  void unsafe_arena_set_allocated_shape_with_output_layout(
      ::xla::ShapeProto* shape_with_output_layout);
  ::xla::ShapeProto* unsafe_arena_release_shape_with_output_layout();

  // .xla.DebugOptions debug_options = 4;
  bool has_debug_options() const;
  private:
  bool _internal_has_debug_options() const;
  public:
  void clear_debug_options();
  const ::xla::DebugOptions& debug_options() const;
  PROTOBUF_NODISCARD ::xla::DebugOptions* release_debug_options();
  ::xla::DebugOptions* mutable_debug_options();
  void set_allocated_debug_options(::xla::DebugOptions* debug_options);
  private:
  const ::xla::DebugOptions& _internal_debug_options() const;
  ::xla::DebugOptions* _internal_mutable_debug_options();
  public:
  void unsafe_arena_set_allocated_debug_options(
      ::xla::DebugOptions* debug_options);
  ::xla::DebugOptions* unsafe_arena_release_debug_options();

  // .xla.DeviceAssignmentProto device_assignment = 7;
  bool has_device_assignment() const;
  private:
  bool _internal_has_device_assignment() const;
  public:
  void clear_device_assignment();
  const ::xla::DeviceAssignmentProto& device_assignment() const;
  PROTOBUF_NODISCARD ::xla::DeviceAssignmentProto* release_device_assignment();
  ::xla::DeviceAssignmentProto* mutable_device_assignment();
  void set_allocated_device_assignment(::xla::DeviceAssignmentProto* device_assignment);
  private:
  const ::xla::DeviceAssignmentProto& _internal_device_assignment() const;
  ::xla::DeviceAssignmentProto* _internal_mutable_device_assignment();
  public:
  void unsafe_arena_set_allocated_device_assignment(
      ::xla::DeviceAssignmentProto* device_assignment);
  ::xla::DeviceAssignmentProto* unsafe_arena_release_device_assignment();

  // uint64 seed = 3;
  void clear_seed();
  uint64_t seed() const;
  void set_seed(uint64_t value);
  private:
  uint64_t _internal_seed() const;
  void _internal_set_seed(uint64_t value);
  public:

  // int32 num_replicas = 6;
  void clear_num_replicas();
  int32_t num_replicas() const;
  void set_num_replicas(int32_t value);
  private:
  int32_t _internal_num_replicas() const;
  void _internal_set_num_replicas(int32_t value);
  public:

  // int32 num_partitions = 9;
  void clear_num_partitions();
  int32_t num_partitions() const;
  void set_num_partitions(int32_t value);
  private:
  int32_t _internal_num_partitions() const;
  void _internal_set_num_partitions(int32_t value);
  public:

  // int32 launch_id = 10;
  void clear_launch_id();
  int32_t launch_id() const;
  void set_launch_id(int32_t value);
  private:
  int32_t _internal_launch_id() const;
  void _internal_set_launch_id(int32_t value);
  public:

  // bool alias_passthrough_params = 8;
  void clear_alias_passthrough_params();
  bool alias_passthrough_params() const;
  void set_alias_passthrough_params(bool value);
  private:
  bool _internal_alias_passthrough_params() const;
  void _internal_set_alias_passthrough_params(bool value);
  public:

  // bool use_spmd_partitioning = 11;
  void clear_use_spmd_partitioning();
  bool use_spmd_partitioning() const;
  void set_use_spmd_partitioning(bool value);
  private:
  bool _internal_use_spmd_partitioning() const;
  void _internal_set_use_spmd_partitioning(bool value);
  public:

  // bool use_auto_spmd_partitioning = 15;
  void clear_use_auto_spmd_partitioning();
  bool use_auto_spmd_partitioning() const;
  void set_use_auto_spmd_partitioning(bool value);
  private:
  bool _internal_use_auto_spmd_partitioning() const;
  void _internal_set_use_auto_spmd_partitioning(bool value);
  public:

  // bool deduplicate_hlo = 12;
  void clear_deduplicate_hlo();
  bool deduplicate_hlo() const;
  void set_deduplicate_hlo(bool value);
  private:
  bool _internal_deduplicate_hlo() const;
  void _internal_set_deduplicate_hlo(bool value);
  public:

  // bool allow_spmd_sharding_propagation_to_output = 14;
  void clear_allow_spmd_sharding_propagation_to_output();
  bool allow_spmd_sharding_propagation_to_output() const;
  void set_allow_spmd_sharding_propagation_to_output(bool value);
  private:
  bool _internal_allow_spmd_sharding_propagation_to_output() const;
  void _internal_set_allow_spmd_sharding_propagation_to_output(bool value);
  public:

  // bool allow_separate_sharding_programs = 19;
  void clear_allow_separate_sharding_programs();
  bool allow_separate_sharding_programs() const;
  void set_allow_separate_sharding_programs(bool value);
  private:
  bool _internal_allow_separate_sharding_programs() const;
  void _internal_set_allow_separate_sharding_programs(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ExecutionOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceHandle > device_handles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > auto_spmd_partitioning_mesh_shape_;
    mutable std::atomic<int> _auto_spmd_partitioning_mesh_shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > auto_spmd_partitioning_mesh_ids_;
    mutable std::atomic<int> _auto_spmd_partitioning_mesh_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > param_requires_broadcast_via_collectives_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShardableValueUpdatePairProto > shardable_value_update_pairs_;
    ::xla::ShapeProto* shape_with_output_layout_;
    ::xla::DebugOptions* debug_options_;
    ::xla::DeviceAssignmentProto* device_assignment_;
    uint64_t seed_;
    int32_t num_replicas_;
    int32_t num_partitions_;
    int32_t launch_id_;
    bool alias_passthrough_params_;
    bool use_spmd_partitioning_;
    bool use_auto_spmd_partitioning_;
    bool deduplicate_hlo_;
    bool allow_spmd_sharding_propagation_to_output_;
    bool allow_separate_sharding_programs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class HloModuleConfigProto_BoolList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.HloModuleConfigProto.BoolList) */ {
 public:
  inline HloModuleConfigProto_BoolList() : HloModuleConfigProto_BoolList(nullptr) {}
  ~HloModuleConfigProto_BoolList() override;
  explicit PROTOBUF_CONSTEXPR HloModuleConfigProto_BoolList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HloModuleConfigProto_BoolList(const HloModuleConfigProto_BoolList& from);
  HloModuleConfigProto_BoolList(HloModuleConfigProto_BoolList&& from) noexcept
    : HloModuleConfigProto_BoolList() {
    *this = ::std::move(from);
  }

  inline HloModuleConfigProto_BoolList& operator=(const HloModuleConfigProto_BoolList& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloModuleConfigProto_BoolList& operator=(HloModuleConfigProto_BoolList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloModuleConfigProto_BoolList& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloModuleConfigProto_BoolList* internal_default_instance() {
    return reinterpret_cast<const HloModuleConfigProto_BoolList*>(
               &_HloModuleConfigProto_BoolList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HloModuleConfigProto_BoolList& a, HloModuleConfigProto_BoolList& b) {
    a.Swap(&b);
  }
  inline void Swap(HloModuleConfigProto_BoolList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloModuleConfigProto_BoolList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloModuleConfigProto_BoolList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HloModuleConfigProto_BoolList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HloModuleConfigProto_BoolList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HloModuleConfigProto_BoolList& from) {
    HloModuleConfigProto_BoolList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HloModuleConfigProto_BoolList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HloModuleConfigProto.BoolList";
  }
  protected:
  explicit HloModuleConfigProto_BoolList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 1,
  };
  // repeated bool vals = 1;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  bool _internal_vals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_vals() const;
  void _internal_add_vals(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_vals();
  public:
  bool vals(int index) const;
  void set_vals(int index, bool value);
  void add_vals(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_vals();

  // @@protoc_insertion_point(class_scope:xla.HloModuleConfigProto.BoolList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > vals_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class HloModuleConfigProto_Int64List final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.HloModuleConfigProto.Int64List) */ {
 public:
  inline HloModuleConfigProto_Int64List() : HloModuleConfigProto_Int64List(nullptr) {}
  ~HloModuleConfigProto_Int64List() override;
  explicit PROTOBUF_CONSTEXPR HloModuleConfigProto_Int64List(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HloModuleConfigProto_Int64List(const HloModuleConfigProto_Int64List& from);
  HloModuleConfigProto_Int64List(HloModuleConfigProto_Int64List&& from) noexcept
    : HloModuleConfigProto_Int64List() {
    *this = ::std::move(from);
  }

  inline HloModuleConfigProto_Int64List& operator=(const HloModuleConfigProto_Int64List& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloModuleConfigProto_Int64List& operator=(HloModuleConfigProto_Int64List&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloModuleConfigProto_Int64List& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloModuleConfigProto_Int64List* internal_default_instance() {
    return reinterpret_cast<const HloModuleConfigProto_Int64List*>(
               &_HloModuleConfigProto_Int64List_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HloModuleConfigProto_Int64List& a, HloModuleConfigProto_Int64List& b) {
    a.Swap(&b);
  }
  inline void Swap(HloModuleConfigProto_Int64List* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloModuleConfigProto_Int64List* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloModuleConfigProto_Int64List* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HloModuleConfigProto_Int64List>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HloModuleConfigProto_Int64List& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HloModuleConfigProto_Int64List& from) {
    HloModuleConfigProto_Int64List::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HloModuleConfigProto_Int64List* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HloModuleConfigProto.Int64List";
  }
  protected:
  explicit HloModuleConfigProto_Int64List(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValsFieldNumber = 1,
  };
  // repeated int64 vals = 1;
  int vals_size() const;
  private:
  int _internal_vals_size() const;
  public:
  void clear_vals();
  private:
  int64_t _internal_vals(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_vals() const;
  void _internal_add_vals(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_vals();
  public:
  int64_t vals(int index) const;
  void set_vals(int index, int64_t value);
  void add_vals(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      vals() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_vals();

  // @@protoc_insertion_point(class_scope:xla.HloModuleConfigProto.Int64List)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > vals_;
    mutable std::atomic<int> _vals_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class HloModuleConfigProto_Int64ListList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.HloModuleConfigProto.Int64ListList) */ {
 public:
  inline HloModuleConfigProto_Int64ListList() : HloModuleConfigProto_Int64ListList(nullptr) {}
  ~HloModuleConfigProto_Int64ListList() override;
  explicit PROTOBUF_CONSTEXPR HloModuleConfigProto_Int64ListList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HloModuleConfigProto_Int64ListList(const HloModuleConfigProto_Int64ListList& from);
  HloModuleConfigProto_Int64ListList(HloModuleConfigProto_Int64ListList&& from) noexcept
    : HloModuleConfigProto_Int64ListList() {
    *this = ::std::move(from);
  }

  inline HloModuleConfigProto_Int64ListList& operator=(const HloModuleConfigProto_Int64ListList& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloModuleConfigProto_Int64ListList& operator=(HloModuleConfigProto_Int64ListList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloModuleConfigProto_Int64ListList& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloModuleConfigProto_Int64ListList* internal_default_instance() {
    return reinterpret_cast<const HloModuleConfigProto_Int64ListList*>(
               &_HloModuleConfigProto_Int64ListList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(HloModuleConfigProto_Int64ListList& a, HloModuleConfigProto_Int64ListList& b) {
    a.Swap(&b);
  }
  inline void Swap(HloModuleConfigProto_Int64ListList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloModuleConfigProto_Int64ListList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloModuleConfigProto_Int64ListList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HloModuleConfigProto_Int64ListList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HloModuleConfigProto_Int64ListList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HloModuleConfigProto_Int64ListList& from) {
    HloModuleConfigProto_Int64ListList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HloModuleConfigProto_Int64ListList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HloModuleConfigProto.Int64ListList";
  }
  protected:
  explicit HloModuleConfigProto_Int64ListList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kListsFieldNumber = 1,
  };
  // repeated .xla.HloModuleConfigProto.Int64List lists = 1;
  int lists_size() const;
  private:
  int _internal_lists_size() const;
  public:
  void clear_lists();
  ::xla::HloModuleConfigProto_Int64List* mutable_lists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_Int64List >*
      mutable_lists();
  private:
  const ::xla::HloModuleConfigProto_Int64List& _internal_lists(int index) const;
  ::xla::HloModuleConfigProto_Int64List* _internal_add_lists();
  public:
  const ::xla::HloModuleConfigProto_Int64List& lists(int index) const;
  ::xla::HloModuleConfigProto_Int64List* add_lists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_Int64List >&
      lists() const;

  // @@protoc_insertion_point(class_scope:xla.HloModuleConfigProto.Int64ListList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_Int64List > lists_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class HloModuleConfigProto_DotConfigEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HloModuleConfigProto_DotConfigEntry_DoNotUse, 
    std::string, ::xla::HloModuleConfigProto_Int64List,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HloModuleConfigProto_DotConfigEntry_DoNotUse, 
    std::string, ::xla::HloModuleConfigProto_Int64List,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> SuperType;
  HloModuleConfigProto_DotConfigEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HloModuleConfigProto_DotConfigEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HloModuleConfigProto_DotConfigEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HloModuleConfigProto_DotConfigEntry_DoNotUse& other);
  static const HloModuleConfigProto_DotConfigEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HloModuleConfigProto_DotConfigEntry_DoNotUse*>(&_HloModuleConfigProto_DotConfigEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xla.HloModuleConfigProto.DotConfigEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};

// -------------------------------------------------------------------

class HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse, 
    std::string, int64_t,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> SuperType;
  HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse& other);
  static const HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse*>(&_HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xla.HloModuleConfigProto.AnalysisAllowanceMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};

// -------------------------------------------------------------------

class HloModuleConfigProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.HloModuleConfigProto) */ {
 public:
  inline HloModuleConfigProto() : HloModuleConfigProto(nullptr) {}
  ~HloModuleConfigProto() override;
  explicit PROTOBUF_CONSTEXPR HloModuleConfigProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HloModuleConfigProto(const HloModuleConfigProto& from);
  HloModuleConfigProto(HloModuleConfigProto&& from) noexcept
    : HloModuleConfigProto() {
    *this = ::std::move(from);
  }

  inline HloModuleConfigProto& operator=(const HloModuleConfigProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloModuleConfigProto& operator=(HloModuleConfigProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloModuleConfigProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloModuleConfigProto* internal_default_instance() {
    return reinterpret_cast<const HloModuleConfigProto*>(
               &_HloModuleConfigProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(HloModuleConfigProto& a, HloModuleConfigProto& b) {
    a.Swap(&b);
  }
  inline void Swap(HloModuleConfigProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloModuleConfigProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloModuleConfigProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HloModuleConfigProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HloModuleConfigProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HloModuleConfigProto& from) {
    HloModuleConfigProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HloModuleConfigProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HloModuleConfigProto";
  }
  protected:
  explicit HloModuleConfigProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef HloModuleConfigProto_BoolList BoolList;
  typedef HloModuleConfigProto_Int64List Int64List;
  typedef HloModuleConfigProto_Int64ListList Int64ListList;

  typedef HloModuleConfigProto_FusionConfigCollection FusionConfigCollection;
  static constexpr FusionConfigCollection OFF =
    HloModuleConfigProto_FusionConfigCollection_OFF;
  static constexpr FusionConfigCollection PER_EDGE =
    HloModuleConfigProto_FusionConfigCollection_PER_EDGE;
  static constexpr FusionConfigCollection PER_NODE =
    HloModuleConfigProto_FusionConfigCollection_PER_NODE;
  static inline bool FusionConfigCollection_IsValid(int value) {
    return HloModuleConfigProto_FusionConfigCollection_IsValid(value);
  }
  static constexpr FusionConfigCollection FusionConfigCollection_MIN =
    HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_MIN;
  static constexpr FusionConfigCollection FusionConfigCollection_MAX =
    HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_MAX;
  static constexpr int FusionConfigCollection_ARRAYSIZE =
    HloModuleConfigProto_FusionConfigCollection_FusionConfigCollection_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  FusionConfigCollection_descriptor() {
    return HloModuleConfigProto_FusionConfigCollection_descriptor();
  }
  template<typename T>
  static inline const std::string& FusionConfigCollection_Name(T enum_t_value) {
    static_assert(::std::is_same<T, FusionConfigCollection>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function FusionConfigCollection_Name.");
    return HloModuleConfigProto_FusionConfigCollection_Name(enum_t_value);
  }
  static inline bool FusionConfigCollection_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      FusionConfigCollection* value) {
    return HloModuleConfigProto_FusionConfigCollection_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kParamRequiresBroadcastViaCollectivesFieldNumber = 6,
    kAutoSpmdPartitioningMeshShapeFieldNumber = 9,
    kAutoSpmdPartitioningMeshIdsFieldNumber = 10,
    kShardableValueUpdatePairsFieldNumber = 16,
    kFusionConfigFieldNumber = 20,
    kDotConfigFieldNumber = 21,
    kLayoutConfigFieldNumber = 22,
    kMemorySpaceAssignmentConfigFieldNumber = 23,
    kPhaseOrderingConfigFieldNumber = 24,
    kAnalysisAllowanceMapFieldNumber = 28,
    kDeviceTypeFieldNumber = 13,
    kEntryComputationLayoutFieldNumber = 1,
    kDebugOptionsFieldNumber = 14,
    kStaticDeviceAssignmentFieldNumber = 15,
    kSeedFieldNumber = 2,
    kReplicaCountFieldNumber = 4,
    kNumPartitionsFieldNumber = 5,
    kLaunchIdFieldNumber = 3,
    kUseSpmdPartitioningFieldNumber = 7,
    kUseAutoSpmdPartitioningFieldNumber = 8,
    kDeduplicateHloFieldNumber = 11,
    kAllowSeparateShardingProgramsFieldNumber = 30,
    kIntraOpParallelismThreadsFieldNumber = 12,
    kFusionConfigCollectionFieldNumber = 19,
    kAliasPassthroughParamsFieldNumber = 17,
    kContentAwareComputationSortingFieldNumber = 18,
    kAllowSpmdShardingPropagationToOutputFieldNumber = 27,
    kPhaseIndexFieldNumber = 25,
    kMatrixUnitOperandPrecisionFieldNumber = 29,
  };
  // repeated bool param_requires_broadcast_via_collectives = 6;
  int param_requires_broadcast_via_collectives_size() const;
  private:
  int _internal_param_requires_broadcast_via_collectives_size() const;
  public:
  void clear_param_requires_broadcast_via_collectives();
  private:
  bool _internal_param_requires_broadcast_via_collectives(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_param_requires_broadcast_via_collectives() const;
  void _internal_add_param_requires_broadcast_via_collectives(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_param_requires_broadcast_via_collectives();
  public:
  bool param_requires_broadcast_via_collectives(int index) const;
  void set_param_requires_broadcast_via_collectives(int index, bool value);
  void add_param_requires_broadcast_via_collectives(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      param_requires_broadcast_via_collectives() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_param_requires_broadcast_via_collectives();

  // repeated int64 auto_spmd_partitioning_mesh_shape = 9;
  int auto_spmd_partitioning_mesh_shape_size() const;
  private:
  int _internal_auto_spmd_partitioning_mesh_shape_size() const;
  public:
  void clear_auto_spmd_partitioning_mesh_shape();
  private:
  int64_t _internal_auto_spmd_partitioning_mesh_shape(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_auto_spmd_partitioning_mesh_shape() const;
  void _internal_add_auto_spmd_partitioning_mesh_shape(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_auto_spmd_partitioning_mesh_shape();
  public:
  int64_t auto_spmd_partitioning_mesh_shape(int index) const;
  void set_auto_spmd_partitioning_mesh_shape(int index, int64_t value);
  void add_auto_spmd_partitioning_mesh_shape(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      auto_spmd_partitioning_mesh_shape() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_auto_spmd_partitioning_mesh_shape();

  // repeated int64 auto_spmd_partitioning_mesh_ids = 10;
  int auto_spmd_partitioning_mesh_ids_size() const;
  private:
  int _internal_auto_spmd_partitioning_mesh_ids_size() const;
  public:
  void clear_auto_spmd_partitioning_mesh_ids();
  private:
  int64_t _internal_auto_spmd_partitioning_mesh_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_auto_spmd_partitioning_mesh_ids() const;
  void _internal_add_auto_spmd_partitioning_mesh_ids(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_auto_spmd_partitioning_mesh_ids();
  public:
  int64_t auto_spmd_partitioning_mesh_ids(int index) const;
  void set_auto_spmd_partitioning_mesh_ids(int index, int64_t value);
  void add_auto_spmd_partitioning_mesh_ids(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      auto_spmd_partitioning_mesh_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_auto_spmd_partitioning_mesh_ids();

  // repeated .xla.ShardableValueUpdatePairProto shardable_value_update_pairs = 16;
  int shardable_value_update_pairs_size() const;
  private:
  int _internal_shardable_value_update_pairs_size() const;
  public:
  void clear_shardable_value_update_pairs();
  ::xla::ShardableValueUpdatePairProto* mutable_shardable_value_update_pairs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShardableValueUpdatePairProto >*
      mutable_shardable_value_update_pairs();
  private:
  const ::xla::ShardableValueUpdatePairProto& _internal_shardable_value_update_pairs(int index) const;
  ::xla::ShardableValueUpdatePairProto* _internal_add_shardable_value_update_pairs();
  public:
  const ::xla::ShardableValueUpdatePairProto& shardable_value_update_pairs(int index) const;
  ::xla::ShardableValueUpdatePairProto* add_shardable_value_update_pairs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShardableValueUpdatePairProto >&
      shardable_value_update_pairs() const;

  // repeated .xla.HloModuleConfigProto.BoolList fusion_config = 20;
  int fusion_config_size() const;
  private:
  int _internal_fusion_config_size() const;
  public:
  void clear_fusion_config();
  ::xla::HloModuleConfigProto_BoolList* mutable_fusion_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_BoolList >*
      mutable_fusion_config();
  private:
  const ::xla::HloModuleConfigProto_BoolList& _internal_fusion_config(int index) const;
  ::xla::HloModuleConfigProto_BoolList* _internal_add_fusion_config();
  public:
  const ::xla::HloModuleConfigProto_BoolList& fusion_config(int index) const;
  ::xla::HloModuleConfigProto_BoolList* add_fusion_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_BoolList >&
      fusion_config() const;

  // map<string, .xla.HloModuleConfigProto.Int64List> dot_config = 21;
  int dot_config_size() const;
  private:
  int _internal_dot_config_size() const;
  public:
  void clear_dot_config();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xla::HloModuleConfigProto_Int64List >&
      _internal_dot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xla::HloModuleConfigProto_Int64List >*
      _internal_mutable_dot_config();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xla::HloModuleConfigProto_Int64List >&
      dot_config() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, ::xla::HloModuleConfigProto_Int64List >*
      mutable_dot_config();

  // repeated .xla.HloModuleConfigProto.Int64ListList layout_config = 22;
  int layout_config_size() const;
  private:
  int _internal_layout_config_size() const;
  public:
  void clear_layout_config();
  ::xla::HloModuleConfigProto_Int64ListList* mutable_layout_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_Int64ListList >*
      mutable_layout_config();
  private:
  const ::xla::HloModuleConfigProto_Int64ListList& _internal_layout_config(int index) const;
  ::xla::HloModuleConfigProto_Int64ListList* _internal_add_layout_config();
  public:
  const ::xla::HloModuleConfigProto_Int64ListList& layout_config(int index) const;
  ::xla::HloModuleConfigProto_Int64ListList* add_layout_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_Int64ListList >&
      layout_config() const;

  // repeated uint64 memory_space_assignment_config = 23;
  int memory_space_assignment_config_size() const;
  private:
  int _internal_memory_space_assignment_config_size() const;
  public:
  void clear_memory_space_assignment_config();
  private:
  uint64_t _internal_memory_space_assignment_config(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_memory_space_assignment_config() const;
  void _internal_add_memory_space_assignment_config(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_memory_space_assignment_config();
  public:
  uint64_t memory_space_assignment_config(int index) const;
  void set_memory_space_assignment_config(int index, uint64_t value);
  void add_memory_space_assignment_config(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      memory_space_assignment_config() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_memory_space_assignment_config();

  // repeated .xla.HloModuleConfigProto.BoolList phase_ordering_config = 24;
  int phase_ordering_config_size() const;
  private:
  int _internal_phase_ordering_config_size() const;
  public:
  void clear_phase_ordering_config();
  ::xla::HloModuleConfigProto_BoolList* mutable_phase_ordering_config(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_BoolList >*
      mutable_phase_ordering_config();
  private:
  const ::xla::HloModuleConfigProto_BoolList& _internal_phase_ordering_config(int index) const;
  ::xla::HloModuleConfigProto_BoolList* _internal_add_phase_ordering_config();
  public:
  const ::xla::HloModuleConfigProto_BoolList& phase_ordering_config(int index) const;
  ::xla::HloModuleConfigProto_BoolList* add_phase_ordering_config();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_BoolList >&
      phase_ordering_config() const;

  // map<string, int64> analysis_allowance_map = 28;
  int analysis_allowance_map_size() const;
  private:
  int _internal_analysis_allowance_map_size() const;
  public:
  void clear_analysis_allowance_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      _internal_analysis_allowance_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      _internal_mutable_analysis_allowance_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >&
      analysis_allowance_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, int64_t >*
      mutable_analysis_allowance_map();

  // string device_type = 13;
  void clear_device_type();
  const std::string& device_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_type();
  PROTOBUF_NODISCARD std::string* release_device_type();
  void set_allocated_device_type(std::string* device_type);
  private:
  const std::string& _internal_device_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_type(const std::string& value);
  std::string* _internal_mutable_device_type();
  public:

  // .xla.ProgramShapeProto entry_computation_layout = 1;
  bool has_entry_computation_layout() const;
  private:
  bool _internal_has_entry_computation_layout() const;
  public:
  void clear_entry_computation_layout();
  const ::xla::ProgramShapeProto& entry_computation_layout() const;
  PROTOBUF_NODISCARD ::xla::ProgramShapeProto* release_entry_computation_layout();
  ::xla::ProgramShapeProto* mutable_entry_computation_layout();
  void set_allocated_entry_computation_layout(::xla::ProgramShapeProto* entry_computation_layout);
  private:
  const ::xla::ProgramShapeProto& _internal_entry_computation_layout() const;
  ::xla::ProgramShapeProto* _internal_mutable_entry_computation_layout();
  public:
  void unsafe_arena_set_allocated_entry_computation_layout(
      ::xla::ProgramShapeProto* entry_computation_layout);
  ::xla::ProgramShapeProto* unsafe_arena_release_entry_computation_layout();

  // .xla.DebugOptions debug_options = 14;
  bool has_debug_options() const;
  private:
  bool _internal_has_debug_options() const;
  public:
  void clear_debug_options();
  const ::xla::DebugOptions& debug_options() const;
  PROTOBUF_NODISCARD ::xla::DebugOptions* release_debug_options();
  ::xla::DebugOptions* mutable_debug_options();
  void set_allocated_debug_options(::xla::DebugOptions* debug_options);
  private:
  const ::xla::DebugOptions& _internal_debug_options() const;
  ::xla::DebugOptions* _internal_mutable_debug_options();
  public:
  void unsafe_arena_set_allocated_debug_options(
      ::xla::DebugOptions* debug_options);
  ::xla::DebugOptions* unsafe_arena_release_debug_options();

  // .xla.DeviceAssignmentProto static_device_assignment = 15;
  bool has_static_device_assignment() const;
  private:
  bool _internal_has_static_device_assignment() const;
  public:
  void clear_static_device_assignment();
  const ::xla::DeviceAssignmentProto& static_device_assignment() const;
  PROTOBUF_NODISCARD ::xla::DeviceAssignmentProto* release_static_device_assignment();
  ::xla::DeviceAssignmentProto* mutable_static_device_assignment();
  void set_allocated_static_device_assignment(::xla::DeviceAssignmentProto* static_device_assignment);
  private:
  const ::xla::DeviceAssignmentProto& _internal_static_device_assignment() const;
  ::xla::DeviceAssignmentProto* _internal_mutable_static_device_assignment();
  public:
  void unsafe_arena_set_allocated_static_device_assignment(
      ::xla::DeviceAssignmentProto* static_device_assignment);
  ::xla::DeviceAssignmentProto* unsafe_arena_release_static_device_assignment();

  // uint64 seed = 2;
  void clear_seed();
  uint64_t seed() const;
  void set_seed(uint64_t value);
  private:
  uint64_t _internal_seed() const;
  void _internal_set_seed(uint64_t value);
  public:

  // int64 replica_count = 4;
  void clear_replica_count();
  int64_t replica_count() const;
  void set_replica_count(int64_t value);
  private:
  int64_t _internal_replica_count() const;
  void _internal_set_replica_count(int64_t value);
  public:

  // int64 num_partitions = 5;
  void clear_num_partitions();
  int64_t num_partitions() const;
  void set_num_partitions(int64_t value);
  private:
  int64_t _internal_num_partitions() const;
  void _internal_set_num_partitions(int64_t value);
  public:

  // int32 launch_id = 3;
  void clear_launch_id();
  int32_t launch_id() const;
  void set_launch_id(int32_t value);
  private:
  int32_t _internal_launch_id() const;
  void _internal_set_launch_id(int32_t value);
  public:

  // bool use_spmd_partitioning = 7;
  void clear_use_spmd_partitioning();
  bool use_spmd_partitioning() const;
  void set_use_spmd_partitioning(bool value);
  private:
  bool _internal_use_spmd_partitioning() const;
  void _internal_set_use_spmd_partitioning(bool value);
  public:

  // bool use_auto_spmd_partitioning = 8;
  void clear_use_auto_spmd_partitioning();
  bool use_auto_spmd_partitioning() const;
  void set_use_auto_spmd_partitioning(bool value);
  private:
  bool _internal_use_auto_spmd_partitioning() const;
  void _internal_set_use_auto_spmd_partitioning(bool value);
  public:

  // bool deduplicate_hlo = 11;
  void clear_deduplicate_hlo();
  bool deduplicate_hlo() const;
  void set_deduplicate_hlo(bool value);
  private:
  bool _internal_deduplicate_hlo() const;
  void _internal_set_deduplicate_hlo(bool value);
  public:

  // bool allow_separate_sharding_programs = 30;
  void clear_allow_separate_sharding_programs();
  bool allow_separate_sharding_programs() const;
  void set_allow_separate_sharding_programs(bool value);
  private:
  bool _internal_allow_separate_sharding_programs() const;
  void _internal_set_allow_separate_sharding_programs(bool value);
  public:

  // int64 intra_op_parallelism_threads = 12;
  void clear_intra_op_parallelism_threads();
  int64_t intra_op_parallelism_threads() const;
  void set_intra_op_parallelism_threads(int64_t value);
  private:
  int64_t _internal_intra_op_parallelism_threads() const;
  void _internal_set_intra_op_parallelism_threads(int64_t value);
  public:

  // .xla.HloModuleConfigProto.FusionConfigCollection fusion_config_collection = 19;
  void clear_fusion_config_collection();
  ::xla::HloModuleConfigProto_FusionConfigCollection fusion_config_collection() const;
  void set_fusion_config_collection(::xla::HloModuleConfigProto_FusionConfigCollection value);
  private:
  ::xla::HloModuleConfigProto_FusionConfigCollection _internal_fusion_config_collection() const;
  void _internal_set_fusion_config_collection(::xla::HloModuleConfigProto_FusionConfigCollection value);
  public:

  // bool alias_passthrough_params = 17;
  void clear_alias_passthrough_params();
  bool alias_passthrough_params() const;
  void set_alias_passthrough_params(bool value);
  private:
  bool _internal_alias_passthrough_params() const;
  void _internal_set_alias_passthrough_params(bool value);
  public:

  // bool content_aware_computation_sorting = 18;
  void clear_content_aware_computation_sorting();
  bool content_aware_computation_sorting() const;
  void set_content_aware_computation_sorting(bool value);
  private:
  bool _internal_content_aware_computation_sorting() const;
  void _internal_set_content_aware_computation_sorting(bool value);
  public:

  // bool allow_spmd_sharding_propagation_to_output = 27;
  void clear_allow_spmd_sharding_propagation_to_output();
  bool allow_spmd_sharding_propagation_to_output() const;
  void set_allow_spmd_sharding_propagation_to_output(bool value);
  private:
  bool _internal_allow_spmd_sharding_propagation_to_output() const;
  void _internal_set_allow_spmd_sharding_propagation_to_output(bool value);
  public:

  // int32 phase_index = 25;
  void clear_phase_index();
  int32_t phase_index() const;
  void set_phase_index(int32_t value);
  private:
  int32_t _internal_phase_index() const;
  void _internal_set_phase_index(int32_t value);
  public:

  // .xla.PrecisionConfig.Precision matrix_unit_operand_precision = 29;
  void clear_matrix_unit_operand_precision();
  ::xla::PrecisionConfig_Precision matrix_unit_operand_precision() const;
  void set_matrix_unit_operand_precision(::xla::PrecisionConfig_Precision value);
  private:
  ::xla::PrecisionConfig_Precision _internal_matrix_unit_operand_precision() const;
  void _internal_set_matrix_unit_operand_precision(::xla::PrecisionConfig_Precision value);
  public:

  // @@protoc_insertion_point(class_scope:xla.HloModuleConfigProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > param_requires_broadcast_via_collectives_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > auto_spmd_partitioning_mesh_shape_;
    mutable std::atomic<int> _auto_spmd_partitioning_mesh_shape_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > auto_spmd_partitioning_mesh_ids_;
    mutable std::atomic<int> _auto_spmd_partitioning_mesh_ids_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShardableValueUpdatePairProto > shardable_value_update_pairs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_BoolList > fusion_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HloModuleConfigProto_DotConfigEntry_DoNotUse,
        std::string, ::xla::HloModuleConfigProto_Int64List,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_MESSAGE> dot_config_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_Int64ListList > layout_config_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > memory_space_assignment_config_;
    mutable std::atomic<int> _memory_space_assignment_config_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::HloModuleConfigProto_BoolList > phase_ordering_config_;
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        HloModuleConfigProto_AnalysisAllowanceMapEntry_DoNotUse,
        std::string, int64_t,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_INT64> analysis_allowance_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_type_;
    ::xla::ProgramShapeProto* entry_computation_layout_;
    ::xla::DebugOptions* debug_options_;
    ::xla::DeviceAssignmentProto* static_device_assignment_;
    uint64_t seed_;
    int64_t replica_count_;
    int64_t num_partitions_;
    int32_t launch_id_;
    bool use_spmd_partitioning_;
    bool use_auto_spmd_partitioning_;
    bool deduplicate_hlo_;
    bool allow_separate_sharding_programs_;
    int64_t intra_op_parallelism_threads_;
    int fusion_config_collection_;
    bool alias_passthrough_params_;
    bool content_aware_computation_sorting_;
    bool allow_spmd_sharding_propagation_to_output_;
    int32_t phase_index_;
    int matrix_unit_operand_precision_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class HloModuleProtoWithConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.HloModuleProtoWithConfig) */ {
 public:
  inline HloModuleProtoWithConfig() : HloModuleProtoWithConfig(nullptr) {}
  ~HloModuleProtoWithConfig() override;
  explicit PROTOBUF_CONSTEXPR HloModuleProtoWithConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HloModuleProtoWithConfig(const HloModuleProtoWithConfig& from);
  HloModuleProtoWithConfig(HloModuleProtoWithConfig&& from) noexcept
    : HloModuleProtoWithConfig() {
    *this = ::std::move(from);
  }

  inline HloModuleProtoWithConfig& operator=(const HloModuleProtoWithConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline HloModuleProtoWithConfig& operator=(HloModuleProtoWithConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HloModuleProtoWithConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const HloModuleProtoWithConfig* internal_default_instance() {
    return reinterpret_cast<const HloModuleProtoWithConfig*>(
               &_HloModuleProtoWithConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(HloModuleProtoWithConfig& a, HloModuleProtoWithConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(HloModuleProtoWithConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HloModuleProtoWithConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HloModuleProtoWithConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HloModuleProtoWithConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HloModuleProtoWithConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HloModuleProtoWithConfig& from) {
    HloModuleProtoWithConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HloModuleProtoWithConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.HloModuleProtoWithConfig";
  }
  protected:
  explicit HloModuleProtoWithConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHloModuleFieldNumber = 1,
    kConfigFieldNumber = 2,
  };
  // .xla.HloModuleProto hlo_module = 1;
  bool has_hlo_module() const;
  private:
  bool _internal_has_hlo_module() const;
  public:
  void clear_hlo_module();
  const ::xla::HloModuleProto& hlo_module() const;
  PROTOBUF_NODISCARD ::xla::HloModuleProto* release_hlo_module();
  ::xla::HloModuleProto* mutable_hlo_module();
  void set_allocated_hlo_module(::xla::HloModuleProto* hlo_module);
  private:
  const ::xla::HloModuleProto& _internal_hlo_module() const;
  ::xla::HloModuleProto* _internal_mutable_hlo_module();
  public:
  void unsafe_arena_set_allocated_hlo_module(
      ::xla::HloModuleProto* hlo_module);
  ::xla::HloModuleProto* unsafe_arena_release_hlo_module();

  // .xla.HloModuleConfigProto config = 2;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::xla::HloModuleConfigProto& config() const;
  PROTOBUF_NODISCARD ::xla::HloModuleConfigProto* release_config();
  ::xla::HloModuleConfigProto* mutable_config();
  void set_allocated_config(::xla::HloModuleConfigProto* config);
  private:
  const ::xla::HloModuleConfigProto& _internal_config() const;
  ::xla::HloModuleConfigProto* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::xla::HloModuleConfigProto* config);
  ::xla::HloModuleConfigProto* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:xla.HloModuleProtoWithConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::HloModuleProto* hlo_module_;
    ::xla::HloModuleConfigProto* config_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class GetDeviceHandlesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.GetDeviceHandlesRequest) */ {
 public:
  inline GetDeviceHandlesRequest() : GetDeviceHandlesRequest(nullptr) {}
  ~GetDeviceHandlesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetDeviceHandlesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDeviceHandlesRequest(const GetDeviceHandlesRequest& from);
  GetDeviceHandlesRequest(GetDeviceHandlesRequest&& from) noexcept
    : GetDeviceHandlesRequest() {
    *this = ::std::move(from);
  }

  inline GetDeviceHandlesRequest& operator=(const GetDeviceHandlesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDeviceHandlesRequest& operator=(GetDeviceHandlesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDeviceHandlesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDeviceHandlesRequest* internal_default_instance() {
    return reinterpret_cast<const GetDeviceHandlesRequest*>(
               &_GetDeviceHandlesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetDeviceHandlesRequest& a, GetDeviceHandlesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDeviceHandlesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDeviceHandlesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDeviceHandlesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDeviceHandlesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDeviceHandlesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDeviceHandlesRequest& from) {
    GetDeviceHandlesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDeviceHandlesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.GetDeviceHandlesRequest";
  }
  protected:
  explicit GetDeviceHandlesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceCountFieldNumber = 1,
  };
  // int64 device_count = 1;
  void clear_device_count();
  int64_t device_count() const;
  void set_device_count(int64_t value);
  private:
  int64_t _internal_device_count() const;
  void _internal_set_device_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.GetDeviceHandlesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t device_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class GetDeviceHandlesResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.GetDeviceHandlesResponse) */ {
 public:
  inline GetDeviceHandlesResponse() : GetDeviceHandlesResponse(nullptr) {}
  ~GetDeviceHandlesResponse() override;
  explicit PROTOBUF_CONSTEXPR GetDeviceHandlesResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetDeviceHandlesResponse(const GetDeviceHandlesResponse& from);
  GetDeviceHandlesResponse(GetDeviceHandlesResponse&& from) noexcept
    : GetDeviceHandlesResponse() {
    *this = ::std::move(from);
  }

  inline GetDeviceHandlesResponse& operator=(const GetDeviceHandlesResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetDeviceHandlesResponse& operator=(GetDeviceHandlesResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetDeviceHandlesResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetDeviceHandlesResponse* internal_default_instance() {
    return reinterpret_cast<const GetDeviceHandlesResponse*>(
               &_GetDeviceHandlesResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetDeviceHandlesResponse& a, GetDeviceHandlesResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetDeviceHandlesResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetDeviceHandlesResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetDeviceHandlesResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetDeviceHandlesResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetDeviceHandlesResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetDeviceHandlesResponse& from) {
    GetDeviceHandlesResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetDeviceHandlesResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.GetDeviceHandlesResponse";
  }
  protected:
  explicit GetDeviceHandlesResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceHandlesFieldNumber = 1,
  };
  // repeated .xla.DeviceHandle device_handles = 1;
  int device_handles_size() const;
  private:
  int _internal_device_handles_size() const;
  public:
  void clear_device_handles();
  ::xla::DeviceHandle* mutable_device_handles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceHandle >*
      mutable_device_handles();
  private:
  const ::xla::DeviceHandle& _internal_device_handles(int index) const;
  ::xla::DeviceHandle* _internal_add_device_handles();
  public:
  const ::xla::DeviceHandle& device_handles(int index) const;
  ::xla::DeviceHandle* add_device_handles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceHandle >&
      device_handles() const;

  // @@protoc_insertion_point(class_scope:xla.GetDeviceHandlesResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceHandle > device_handles_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferToClientRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferToClientRequest) */ {
 public:
  inline TransferToClientRequest() : TransferToClientRequest(nullptr) {}
  ~TransferToClientRequest() override;
  explicit PROTOBUF_CONSTEXPR TransferToClientRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferToClientRequest(const TransferToClientRequest& from);
  TransferToClientRequest(TransferToClientRequest&& from) noexcept
    : TransferToClientRequest() {
    *this = ::std::move(from);
  }

  inline TransferToClientRequest& operator=(const TransferToClientRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferToClientRequest& operator=(TransferToClientRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferToClientRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferToClientRequest* internal_default_instance() {
    return reinterpret_cast<const TransferToClientRequest*>(
               &_TransferToClientRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(TransferToClientRequest& a, TransferToClientRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferToClientRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferToClientRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferToClientRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferToClientRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferToClientRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferToClientRequest& from) {
    TransferToClientRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferToClientRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferToClientRequest";
  }
  protected:
  explicit TransferToClientRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kShapeWithLayoutFieldNumber = 2,
  };
  // .xla.GlobalDataHandle data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::xla::GlobalDataHandle& data() const;
  PROTOBUF_NODISCARD ::xla::GlobalDataHandle* release_data();
  ::xla::GlobalDataHandle* mutable_data();
  void set_allocated_data(::xla::GlobalDataHandle* data);
  private:
  const ::xla::GlobalDataHandle& _internal_data() const;
  ::xla::GlobalDataHandle* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::xla::GlobalDataHandle* data);
  ::xla::GlobalDataHandle* unsafe_arena_release_data();

  // .xla.ShapeProto shape_with_layout = 2;
  bool has_shape_with_layout() const;
  private:
  bool _internal_has_shape_with_layout() const;
  public:
  void clear_shape_with_layout();
  const ::xla::ShapeProto& shape_with_layout() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_shape_with_layout();
  ::xla::ShapeProto* mutable_shape_with_layout();
  void set_allocated_shape_with_layout(::xla::ShapeProto* shape_with_layout);
  private:
  const ::xla::ShapeProto& _internal_shape_with_layout() const;
  ::xla::ShapeProto* _internal_mutable_shape_with_layout();
  public:
  void unsafe_arena_set_allocated_shape_with_layout(
      ::xla::ShapeProto* shape_with_layout);
  ::xla::ShapeProto* unsafe_arena_release_shape_with_layout();

  // @@protoc_insertion_point(class_scope:xla.TransferToClientRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::GlobalDataHandle* data_;
    ::xla::ShapeProto* shape_with_layout_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferToClientResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferToClientResponse) */ {
 public:
  inline TransferToClientResponse() : TransferToClientResponse(nullptr) {}
  ~TransferToClientResponse() override;
  explicit PROTOBUF_CONSTEXPR TransferToClientResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferToClientResponse(const TransferToClientResponse& from);
  TransferToClientResponse(TransferToClientResponse&& from) noexcept
    : TransferToClientResponse() {
    *this = ::std::move(from);
  }

  inline TransferToClientResponse& operator=(const TransferToClientResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferToClientResponse& operator=(TransferToClientResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferToClientResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferToClientResponse* internal_default_instance() {
    return reinterpret_cast<const TransferToClientResponse*>(
               &_TransferToClientResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransferToClientResponse& a, TransferToClientResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferToClientResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferToClientResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferToClientResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferToClientResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferToClientResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferToClientResponse& from) {
    TransferToClientResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferToClientResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferToClientResponse";
  }
  protected:
  explicit TransferToClientResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiteralFieldNumber = 1,
  };
  // .xla.LiteralProto literal = 1;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::xla::LiteralProto& literal() const;
  PROTOBUF_NODISCARD ::xla::LiteralProto* release_literal();
  ::xla::LiteralProto* mutable_literal();
  void set_allocated_literal(::xla::LiteralProto* literal);
  private:
  const ::xla::LiteralProto& _internal_literal() const;
  ::xla::LiteralProto* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::xla::LiteralProto* literal);
  ::xla::LiteralProto* unsafe_arena_release_literal();

  // @@protoc_insertion_point(class_scope:xla.TransferToClientResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::LiteralProto* literal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferToServerRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferToServerRequest) */ {
 public:
  inline TransferToServerRequest() : TransferToServerRequest(nullptr) {}
  ~TransferToServerRequest() override;
  explicit PROTOBUF_CONSTEXPR TransferToServerRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferToServerRequest(const TransferToServerRequest& from);
  TransferToServerRequest(TransferToServerRequest&& from) noexcept
    : TransferToServerRequest() {
    *this = ::std::move(from);
  }

  inline TransferToServerRequest& operator=(const TransferToServerRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferToServerRequest& operator=(TransferToServerRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferToServerRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferToServerRequest* internal_default_instance() {
    return reinterpret_cast<const TransferToServerRequest*>(
               &_TransferToServerRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TransferToServerRequest& a, TransferToServerRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferToServerRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferToServerRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferToServerRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferToServerRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferToServerRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferToServerRequest& from) {
    TransferToServerRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferToServerRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferToServerRequest";
  }
  protected:
  explicit TransferToServerRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiteralFieldNumber = 1,
    kDeviceHandleFieldNumber = 2,
  };
  // .xla.LiteralProto literal = 1;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::xla::LiteralProto& literal() const;
  PROTOBUF_NODISCARD ::xla::LiteralProto* release_literal();
  ::xla::LiteralProto* mutable_literal();
  void set_allocated_literal(::xla::LiteralProto* literal);
  private:
  const ::xla::LiteralProto& _internal_literal() const;
  ::xla::LiteralProto* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::xla::LiteralProto* literal);
  ::xla::LiteralProto* unsafe_arena_release_literal();

  // .xla.DeviceHandle device_handle = 2;
  bool has_device_handle() const;
  private:
  bool _internal_has_device_handle() const;
  public:
  void clear_device_handle();
  const ::xla::DeviceHandle& device_handle() const;
  PROTOBUF_NODISCARD ::xla::DeviceHandle* release_device_handle();
  ::xla::DeviceHandle* mutable_device_handle();
  void set_allocated_device_handle(::xla::DeviceHandle* device_handle);
  private:
  const ::xla::DeviceHandle& _internal_device_handle() const;
  ::xla::DeviceHandle* _internal_mutable_device_handle();
  public:
  void unsafe_arena_set_allocated_device_handle(
      ::xla::DeviceHandle* device_handle);
  ::xla::DeviceHandle* unsafe_arena_release_device_handle();

  // @@protoc_insertion_point(class_scope:xla.TransferToServerRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::LiteralProto* literal_;
    ::xla::DeviceHandle* device_handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferToServerResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferToServerResponse) */ {
 public:
  inline TransferToServerResponse() : TransferToServerResponse(nullptr) {}
  ~TransferToServerResponse() override;
  explicit PROTOBUF_CONSTEXPR TransferToServerResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferToServerResponse(const TransferToServerResponse& from);
  TransferToServerResponse(TransferToServerResponse&& from) noexcept
    : TransferToServerResponse() {
    *this = ::std::move(from);
  }

  inline TransferToServerResponse& operator=(const TransferToServerResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferToServerResponse& operator=(TransferToServerResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferToServerResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferToServerResponse* internal_default_instance() {
    return reinterpret_cast<const TransferToServerResponse*>(
               &_TransferToServerResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(TransferToServerResponse& a, TransferToServerResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferToServerResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferToServerResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferToServerResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferToServerResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferToServerResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferToServerResponse& from) {
    TransferToServerResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferToServerResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferToServerResponse";
  }
  protected:
  explicit TransferToServerResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
  };
  // .xla.GlobalDataHandle data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const ::xla::GlobalDataHandle& data() const;
  PROTOBUF_NODISCARD ::xla::GlobalDataHandle* release_data();
  ::xla::GlobalDataHandle* mutable_data();
  void set_allocated_data(::xla::GlobalDataHandle* data);
  private:
  const ::xla::GlobalDataHandle& _internal_data() const;
  ::xla::GlobalDataHandle* _internal_mutable_data();
  public:
  void unsafe_arena_set_allocated_data(
      ::xla::GlobalDataHandle* data);
  ::xla::GlobalDataHandle* unsafe_arena_release_data();

  // @@protoc_insertion_point(class_scope:xla.TransferToServerResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::GlobalDataHandle* data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferToInfeedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferToInfeedRequest) */ {
 public:
  inline TransferToInfeedRequest() : TransferToInfeedRequest(nullptr) {}
  ~TransferToInfeedRequest() override;
  explicit PROTOBUF_CONSTEXPR TransferToInfeedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferToInfeedRequest(const TransferToInfeedRequest& from);
  TransferToInfeedRequest(TransferToInfeedRequest&& from) noexcept
    : TransferToInfeedRequest() {
    *this = ::std::move(from);
  }

  inline TransferToInfeedRequest& operator=(const TransferToInfeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferToInfeedRequest& operator=(TransferToInfeedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferToInfeedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferToInfeedRequest* internal_default_instance() {
    return reinterpret_cast<const TransferToInfeedRequest*>(
               &_TransferToInfeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(TransferToInfeedRequest& a, TransferToInfeedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferToInfeedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferToInfeedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferToInfeedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferToInfeedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferToInfeedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferToInfeedRequest& from) {
    TransferToInfeedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferToInfeedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferToInfeedRequest";
  }
  protected:
  explicit TransferToInfeedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiteralFieldNumber = 1,
    kDeviceHandleFieldNumber = 3,
    kReplicaIdFieldNumber = 2,
  };
  // .xla.LiteralProto literal = 1;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::xla::LiteralProto& literal() const;
  PROTOBUF_NODISCARD ::xla::LiteralProto* release_literal();
  ::xla::LiteralProto* mutable_literal();
  void set_allocated_literal(::xla::LiteralProto* literal);
  private:
  const ::xla::LiteralProto& _internal_literal() const;
  ::xla::LiteralProto* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::xla::LiteralProto* literal);
  ::xla::LiteralProto* unsafe_arena_release_literal();

  // .xla.DeviceHandle device_handle = 3;
  bool has_device_handle() const;
  private:
  bool _internal_has_device_handle() const;
  public:
  void clear_device_handle();
  const ::xla::DeviceHandle& device_handle() const;
  PROTOBUF_NODISCARD ::xla::DeviceHandle* release_device_handle();
  ::xla::DeviceHandle* mutable_device_handle();
  void set_allocated_device_handle(::xla::DeviceHandle* device_handle);
  private:
  const ::xla::DeviceHandle& _internal_device_handle() const;
  ::xla::DeviceHandle* _internal_mutable_device_handle();
  public:
  void unsafe_arena_set_allocated_device_handle(
      ::xla::DeviceHandle* device_handle);
  ::xla::DeviceHandle* unsafe_arena_release_device_handle();

  // int64 replica_id = 2;
  void clear_replica_id();
  int64_t replica_id() const;
  void set_replica_id(int64_t value);
  private:
  int64_t _internal_replica_id() const;
  void _internal_set_replica_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.TransferToInfeedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::LiteralProto* literal_;
    ::xla::DeviceHandle* device_handle_;
    int64_t replica_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferToInfeedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xla.TransferToInfeedResponse) */ {
 public:
  inline TransferToInfeedResponse() : TransferToInfeedResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR TransferToInfeedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferToInfeedResponse(const TransferToInfeedResponse& from);
  TransferToInfeedResponse(TransferToInfeedResponse&& from) noexcept
    : TransferToInfeedResponse() {
    *this = ::std::move(from);
  }

  inline TransferToInfeedResponse& operator=(const TransferToInfeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferToInfeedResponse& operator=(TransferToInfeedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferToInfeedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferToInfeedResponse* internal_default_instance() {
    return reinterpret_cast<const TransferToInfeedResponse*>(
               &_TransferToInfeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(TransferToInfeedResponse& a, TransferToInfeedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferToInfeedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferToInfeedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferToInfeedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferToInfeedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const TransferToInfeedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const TransferToInfeedResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferToInfeedResponse";
  }
  protected:
  explicit TransferToInfeedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xla.TransferToInfeedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferFromOutfeedRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferFromOutfeedRequest) */ {
 public:
  inline TransferFromOutfeedRequest() : TransferFromOutfeedRequest(nullptr) {}
  ~TransferFromOutfeedRequest() override;
  explicit PROTOBUF_CONSTEXPR TransferFromOutfeedRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferFromOutfeedRequest(const TransferFromOutfeedRequest& from);
  TransferFromOutfeedRequest(TransferFromOutfeedRequest&& from) noexcept
    : TransferFromOutfeedRequest() {
    *this = ::std::move(from);
  }

  inline TransferFromOutfeedRequest& operator=(const TransferFromOutfeedRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferFromOutfeedRequest& operator=(TransferFromOutfeedRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferFromOutfeedRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferFromOutfeedRequest* internal_default_instance() {
    return reinterpret_cast<const TransferFromOutfeedRequest*>(
               &_TransferFromOutfeedRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(TransferFromOutfeedRequest& a, TransferFromOutfeedRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferFromOutfeedRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferFromOutfeedRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferFromOutfeedRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferFromOutfeedRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferFromOutfeedRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferFromOutfeedRequest& from) {
    TransferFromOutfeedRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferFromOutfeedRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferFromOutfeedRequest";
  }
  protected:
  explicit TransferFromOutfeedRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kShapeWithLayoutFieldNumber = 1,
    kDeviceHandleFieldNumber = 3,
    kReplicaIdFieldNumber = 2,
  };
  // .xla.ShapeProto shape_with_layout = 1;
  bool has_shape_with_layout() const;
  private:
  bool _internal_has_shape_with_layout() const;
  public:
  void clear_shape_with_layout();
  const ::xla::ShapeProto& shape_with_layout() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_shape_with_layout();
  ::xla::ShapeProto* mutable_shape_with_layout();
  void set_allocated_shape_with_layout(::xla::ShapeProto* shape_with_layout);
  private:
  const ::xla::ShapeProto& _internal_shape_with_layout() const;
  ::xla::ShapeProto* _internal_mutable_shape_with_layout();
  public:
  void unsafe_arena_set_allocated_shape_with_layout(
      ::xla::ShapeProto* shape_with_layout);
  ::xla::ShapeProto* unsafe_arena_release_shape_with_layout();

  // .xla.DeviceHandle device_handle = 3;
  bool has_device_handle() const;
  private:
  bool _internal_has_device_handle() const;
  public:
  void clear_device_handle();
  const ::xla::DeviceHandle& device_handle() const;
  PROTOBUF_NODISCARD ::xla::DeviceHandle* release_device_handle();
  ::xla::DeviceHandle* mutable_device_handle();
  void set_allocated_device_handle(::xla::DeviceHandle* device_handle);
  private:
  const ::xla::DeviceHandle& _internal_device_handle() const;
  ::xla::DeviceHandle* _internal_mutable_device_handle();
  public:
  void unsafe_arena_set_allocated_device_handle(
      ::xla::DeviceHandle* device_handle);
  ::xla::DeviceHandle* unsafe_arena_release_device_handle();

  // int64 replica_id = 2;
  void clear_replica_id();
  int64_t replica_id() const;
  void set_replica_id(int64_t value);
  private:
  int64_t _internal_replica_id() const;
  void _internal_set_replica_id(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.TransferFromOutfeedRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::ShapeProto* shape_with_layout_;
    ::xla::DeviceHandle* device_handle_;
    int64_t replica_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class TransferFromOutfeedResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TransferFromOutfeedResponse) */ {
 public:
  inline TransferFromOutfeedResponse() : TransferFromOutfeedResponse(nullptr) {}
  ~TransferFromOutfeedResponse() override;
  explicit PROTOBUF_CONSTEXPR TransferFromOutfeedResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferFromOutfeedResponse(const TransferFromOutfeedResponse& from);
  TransferFromOutfeedResponse(TransferFromOutfeedResponse&& from) noexcept
    : TransferFromOutfeedResponse() {
    *this = ::std::move(from);
  }

  inline TransferFromOutfeedResponse& operator=(const TransferFromOutfeedResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferFromOutfeedResponse& operator=(TransferFromOutfeedResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferFromOutfeedResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferFromOutfeedResponse* internal_default_instance() {
    return reinterpret_cast<const TransferFromOutfeedResponse*>(
               &_TransferFromOutfeedResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(TransferFromOutfeedResponse& a, TransferFromOutfeedResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferFromOutfeedResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferFromOutfeedResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TransferFromOutfeedResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TransferFromOutfeedResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferFromOutfeedResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TransferFromOutfeedResponse& from) {
    TransferFromOutfeedResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferFromOutfeedResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TransferFromOutfeedResponse";
  }
  protected:
  explicit TransferFromOutfeedResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLiteralFieldNumber = 1,
  };
  // .xla.LiteralProto literal = 1;
  bool has_literal() const;
  private:
  bool _internal_has_literal() const;
  public:
  void clear_literal();
  const ::xla::LiteralProto& literal() const;
  PROTOBUF_NODISCARD ::xla::LiteralProto* release_literal();
  ::xla::LiteralProto* mutable_literal();
  void set_allocated_literal(::xla::LiteralProto* literal);
  private:
  const ::xla::LiteralProto& _internal_literal() const;
  ::xla::LiteralProto* _internal_mutable_literal();
  public:
  void unsafe_arena_set_allocated_literal(
      ::xla::LiteralProto* literal);
  ::xla::LiteralProto* unsafe_arena_release_literal();

  // @@protoc_insertion_point(class_scope:xla.TransferFromOutfeedResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::LiteralProto* literal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class ResetDeviceRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ResetDeviceRequest) */ {
 public:
  inline ResetDeviceRequest() : ResetDeviceRequest(nullptr) {}
  ~ResetDeviceRequest() override;
  explicit PROTOBUF_CONSTEXPR ResetDeviceRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetDeviceRequest(const ResetDeviceRequest& from);
  ResetDeviceRequest(ResetDeviceRequest&& from) noexcept
    : ResetDeviceRequest() {
    *this = ::std::move(from);
  }

  inline ResetDeviceRequest& operator=(const ResetDeviceRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetDeviceRequest& operator=(ResetDeviceRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetDeviceRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetDeviceRequest* internal_default_instance() {
    return reinterpret_cast<const ResetDeviceRequest*>(
               &_ResetDeviceRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ResetDeviceRequest& a, ResetDeviceRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetDeviceRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetDeviceRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetDeviceRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetDeviceRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ResetDeviceRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ResetDeviceRequest& from) {
    ResetDeviceRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ResetDeviceRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ResetDeviceRequest";
  }
  protected:
  explicit ResetDeviceRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceHandleFieldNumber = 1,
  };
  // .xla.DeviceHandle device_handle = 1;
  bool has_device_handle() const;
  private:
  bool _internal_has_device_handle() const;
  public:
  void clear_device_handle();
  const ::xla::DeviceHandle& device_handle() const;
  PROTOBUF_NODISCARD ::xla::DeviceHandle* release_device_handle();
  ::xla::DeviceHandle* mutable_device_handle();
  void set_allocated_device_handle(::xla::DeviceHandle* device_handle);
  private:
  const ::xla::DeviceHandle& _internal_device_handle() const;
  ::xla::DeviceHandle* _internal_mutable_device_handle();
  public:
  void unsafe_arena_set_allocated_device_handle(
      ::xla::DeviceHandle* device_handle);
  ::xla::DeviceHandle* unsafe_arena_release_device_handle();

  // @@protoc_insertion_point(class_scope:xla.ResetDeviceRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::DeviceHandle* device_handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class ResetDeviceResponse final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:xla.ResetDeviceResponse) */ {
 public:
  inline ResetDeviceResponse() : ResetDeviceResponse(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ResetDeviceResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ResetDeviceResponse(const ResetDeviceResponse& from);
  ResetDeviceResponse(ResetDeviceResponse&& from) noexcept
    : ResetDeviceResponse() {
    *this = ::std::move(from);
  }

  inline ResetDeviceResponse& operator=(const ResetDeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ResetDeviceResponse& operator=(ResetDeviceResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ResetDeviceResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ResetDeviceResponse* internal_default_instance() {
    return reinterpret_cast<const ResetDeviceResponse*>(
               &_ResetDeviceResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ResetDeviceResponse& a, ResetDeviceResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ResetDeviceResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ResetDeviceResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ResetDeviceResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ResetDeviceResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ResetDeviceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ResetDeviceResponse& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ResetDeviceResponse";
  }
  protected:
  explicit ResetDeviceResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:xla.ResetDeviceResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class ComputationGraphStatsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ComputationGraphStatsRequest) */ {
 public:
  inline ComputationGraphStatsRequest() : ComputationGraphStatsRequest(nullptr) {}
  ~ComputationGraphStatsRequest() override;
  explicit PROTOBUF_CONSTEXPR ComputationGraphStatsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputationGraphStatsRequest(const ComputationGraphStatsRequest& from);
  ComputationGraphStatsRequest(ComputationGraphStatsRequest&& from) noexcept
    : ComputationGraphStatsRequest() {
    *this = ::std::move(from);
  }

  inline ComputationGraphStatsRequest& operator=(const ComputationGraphStatsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputationGraphStatsRequest& operator=(ComputationGraphStatsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputationGraphStatsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputationGraphStatsRequest* internal_default_instance() {
    return reinterpret_cast<const ComputationGraphStatsRequest*>(
               &_ComputationGraphStatsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(ComputationGraphStatsRequest& a, ComputationGraphStatsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputationGraphStatsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputationGraphStatsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputationGraphStatsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputationGraphStatsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputationGraphStatsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComputationGraphStatsRequest& from) {
    ComputationGraphStatsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputationGraphStatsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ComputationGraphStatsRequest";
  }
  protected:
  explicit ComputationGraphStatsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kComputationFieldNumber = 1,
    kDebugOptionsFieldNumber = 2,
  };
  // .xla.HloModuleProto computation = 1;
  bool has_computation() const;
  private:
  bool _internal_has_computation() const;
  public:
  void clear_computation();
  const ::xla::HloModuleProto& computation() const;
  PROTOBUF_NODISCARD ::xla::HloModuleProto* release_computation();
  ::xla::HloModuleProto* mutable_computation();
  void set_allocated_computation(::xla::HloModuleProto* computation);
  private:
  const ::xla::HloModuleProto& _internal_computation() const;
  ::xla::HloModuleProto* _internal_mutable_computation();
  public:
  void unsafe_arena_set_allocated_computation(
      ::xla::HloModuleProto* computation);
  ::xla::HloModuleProto* unsafe_arena_release_computation();

  // .xla.DebugOptions debug_options = 2;
  bool has_debug_options() const;
  private:
  bool _internal_has_debug_options() const;
  public:
  void clear_debug_options();
  const ::xla::DebugOptions& debug_options() const;
  PROTOBUF_NODISCARD ::xla::DebugOptions* release_debug_options();
  ::xla::DebugOptions* mutable_debug_options();
  void set_allocated_debug_options(::xla::DebugOptions* debug_options);
  private:
  const ::xla::DebugOptions& _internal_debug_options() const;
  ::xla::DebugOptions* _internal_mutable_debug_options();
  public:
  void unsafe_arena_set_allocated_debug_options(
      ::xla::DebugOptions* debug_options);
  ::xla::DebugOptions* unsafe_arena_release_debug_options();

  // @@protoc_insertion_point(class_scope:xla.ComputationGraphStatsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::HloModuleProto* computation_;
    ::xla::DebugOptions* debug_options_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class ComputationStatsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ComputationStatsResponse) */ {
 public:
  inline ComputationStatsResponse() : ComputationStatsResponse(nullptr) {}
  ~ComputationStatsResponse() override;
  explicit PROTOBUF_CONSTEXPR ComputationStatsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputationStatsResponse(const ComputationStatsResponse& from);
  ComputationStatsResponse(ComputationStatsResponse&& from) noexcept
    : ComputationStatsResponse() {
    *this = ::std::move(from);
  }

  inline ComputationStatsResponse& operator=(const ComputationStatsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputationStatsResponse& operator=(ComputationStatsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputationStatsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputationStatsResponse* internal_default_instance() {
    return reinterpret_cast<const ComputationStatsResponse*>(
               &_ComputationStatsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ComputationStatsResponse& a, ComputationStatsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputationStatsResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputationStatsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputationStatsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputationStatsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputationStatsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComputationStatsResponse& from) {
    ComputationStatsResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputationStatsResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ComputationStatsResponse";
  }
  protected:
  explicit ComputationStatsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 1,
  };
  // .xla.ComputationStats stats = 1;
  bool has_stats() const;
  private:
  bool _internal_has_stats() const;
  public:
  void clear_stats();
  const ::xla::ComputationStats& stats() const;
  PROTOBUF_NODISCARD ::xla::ComputationStats* release_stats();
  ::xla::ComputationStats* mutable_stats();
  void set_allocated_stats(::xla::ComputationStats* stats);
  private:
  const ::xla::ComputationStats& _internal_stats() const;
  ::xla::ComputationStats* _internal_mutable_stats();
  public:
  void unsafe_arena_set_allocated_stats(
      ::xla::ComputationStats* stats);
  ::xla::ComputationStats* unsafe_arena_release_stats();

  // @@protoc_insertion_point(class_scope:xla.ComputationStatsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::xla::ComputationStats* stats_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class CreateChannelHandleRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.CreateChannelHandleRequest) */ {
 public:
  inline CreateChannelHandleRequest() : CreateChannelHandleRequest(nullptr) {}
  ~CreateChannelHandleRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateChannelHandleRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChannelHandleRequest(const CreateChannelHandleRequest& from);
  CreateChannelHandleRequest(CreateChannelHandleRequest&& from) noexcept
    : CreateChannelHandleRequest() {
    *this = ::std::move(from);
  }

  inline CreateChannelHandleRequest& operator=(const CreateChannelHandleRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChannelHandleRequest& operator=(CreateChannelHandleRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChannelHandleRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChannelHandleRequest* internal_default_instance() {
    return reinterpret_cast<const CreateChannelHandleRequest*>(
               &_CreateChannelHandleRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CreateChannelHandleRequest& a, CreateChannelHandleRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChannelHandleRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChannelHandleRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChannelHandleRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChannelHandleRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChannelHandleRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateChannelHandleRequest& from) {
    CreateChannelHandleRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateChannelHandleRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.CreateChannelHandleRequest";
  }
  protected:
  explicit CreateChannelHandleRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelTypeFieldNumber = 1,
  };
  // .xla.ChannelHandle.ChannelType channel_type = 1;
  void clear_channel_type();
  ::xla::ChannelHandle_ChannelType channel_type() const;
  void set_channel_type(::xla::ChannelHandle_ChannelType value);
  private:
  ::xla::ChannelHandle_ChannelType _internal_channel_type() const;
  void _internal_set_channel_type(::xla::ChannelHandle_ChannelType value);
  public:

  // @@protoc_insertion_point(class_scope:xla.CreateChannelHandleRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int channel_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_2eproto;
};
// -------------------------------------------------------------------

class CreateChannelHandleResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.CreateChannelHandleResponse) */ {
 public:
  inline CreateChannelHandleResponse() : CreateChannelHandleResponse(nullptr) {}
  ~CreateChannelHandleResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateChannelHandleResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateChannelHandleResponse(const CreateChannelHandleResponse& from);
  CreateChannelHandleResponse(CreateChannelHandleResponse&& from) noexcept
    : CreateChannelHandleResponse() {
    *this = ::std::move(from);
  }

  inline CreateChannelHandleResponse& operator=(const CreateChannelHandleResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateChannelHandleResponse& operator=(CreateChannelHandleResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateChannelHandleResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateChannelHandleResponse* internal_default_instance() {
    return reinterpret_cast<const CreateChannelHandleResponse*>(
               &_CreateChannelHandleResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CreateChannelHandleResponse& a, CreateChannelHandleResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateChannelHandleResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateChannelHandleResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateChannelHandleResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateChannelHandleResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateChannelHandleResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateChannelHandleResponse& from) {
    CreateChannelHandleResponse::MergeImpl(*this, from);
  }
  private:
  static