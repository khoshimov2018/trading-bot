// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tensorflow/compiler/xla/xla_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021009 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
namespace xla {
class ChannelHandle;
struct ChannelHandleDefaultTypeInternal;
extern ChannelHandleDefaultTypeInternal _ChannelHandle_default_instance_;
class CholeskyOptions;
struct CholeskyOptionsDefaultTypeInternal;
extern CholeskyOptionsDefaultTypeInternal _CholeskyOptions_default_instance_;
class ComputationStats;
struct ComputationStatsDefaultTypeInternal;
extern ComputationStatsDefaultTypeInternal _ComputationStats_default_instance_;
class ConvolutionDimensionNumbers;
struct ConvolutionDimensionNumbersDefaultTypeInternal;
extern ConvolutionDimensionNumbersDefaultTypeInternal _ConvolutionDimensionNumbers_default_instance_;
class DeviceAssignmentProto;
struct DeviceAssignmentProtoDefaultTypeInternal;
extern DeviceAssignmentProtoDefaultTypeInternal _DeviceAssignmentProto_default_instance_;
class DeviceAssignmentProto_ComputationDevice;
struct DeviceAssignmentProto_ComputationDeviceDefaultTypeInternal;
extern DeviceAssignmentProto_ComputationDeviceDefaultTypeInternal _DeviceAssignmentProto_ComputationDevice_default_instance_;
class DeviceHandle;
struct DeviceHandleDefaultTypeInternal;
extern DeviceHandleDefaultTypeInternal _DeviceHandle_default_instance_;
class DotDimensionNumbers;
struct DotDimensionNumbersDefaultTypeInternal;
extern DotDimensionNumbersDefaultTypeInternal _DotDimensionNumbers_default_instance_;
class ExecutionHandle;
struct ExecutionHandleDefaultTypeInternal;
extern ExecutionHandleDefaultTypeInternal _ExecutionHandle_default_instance_;
class ExecutionProfile;
struct ExecutionProfileDefaultTypeInternal;
extern ExecutionProfileDefaultTypeInternal _ExecutionProfile_default_instance_;
class FrontendAttributes;
struct FrontendAttributesDefaultTypeInternal;
extern FrontendAttributesDefaultTypeInternal _FrontendAttributes_default_instance_;
class FrontendAttributes_MapEntry_DoNotUse;
struct FrontendAttributes_MapEntry_DoNotUseDefaultTypeInternal;
extern FrontendAttributes_MapEntry_DoNotUseDefaultTypeInternal _FrontendAttributes_MapEntry_DoNotUse_default_instance_;
class GatherDimensionNumbers;
struct GatherDimensionNumbersDefaultTypeInternal;
extern GatherDimensionNumbersDefaultTypeInternal _GatherDimensionNumbers_default_instance_;
class GlobalDataHandle;
struct GlobalDataHandleDefaultTypeInternal;
extern GlobalDataHandleDefaultTypeInternal _GlobalDataHandle_default_instance_;
class LayoutProto;
struct LayoutProtoDefaultTypeInternal;
extern LayoutProtoDefaultTypeInternal _LayoutProto_default_instance_;
class LiteralProto;
struct LiteralProtoDefaultTypeInternal;
extern LiteralProtoDefaultTypeInternal _LiteralProto_default_instance_;
class OpMetadata;
struct OpMetadataDefaultTypeInternal;
extern OpMetadataDefaultTypeInternal _OpMetadata_default_instance_;
class OpMetadata_ProfileInfo;
struct OpMetadata_ProfileInfoDefaultTypeInternal;
extern OpMetadata_ProfileInfoDefaultTypeInternal _OpMetadata_ProfileInfo_default_instance_;
class OpSharding;
struct OpShardingDefaultTypeInternal;
extern OpShardingDefaultTypeInternal _OpSharding_default_instance_;
class OutputOperandAliasing;
struct OutputOperandAliasingDefaultTypeInternal;
extern OutputOperandAliasingDefaultTypeInternal _OutputOperandAliasing_default_instance_;
class PaddingConfig;
struct PaddingConfigDefaultTypeInternal;
extern PaddingConfigDefaultTypeInternal _PaddingConfig_default_instance_;
class PaddingConfig_PaddingConfigDimension;
struct PaddingConfig_PaddingConfigDimensionDefaultTypeInternal;
extern PaddingConfig_PaddingConfigDimensionDefaultTypeInternal _PaddingConfig_PaddingConfigDimension_default_instance_;
class ParameterReplication;
struct ParameterReplicationDefaultTypeInternal;
extern ParameterReplicationDefaultTypeInternal _ParameterReplication_default_instance_;
class PrecisionConfig;
struct PrecisionConfigDefaultTypeInternal;
extern PrecisionConfigDefaultTypeInternal _PrecisionConfig_default_instance_;
class ProgramShapeProto;
struct ProgramShapeProtoDefaultTypeInternal;
extern ProgramShapeProtoDefaultTypeInternal _ProgramShapeProto_default_instance_;
class ReplicaGroup;
struct ReplicaGroupDefaultTypeInternal;
extern ReplicaGroupDefaultTypeInternal _ReplicaGroup_default_instance_;
class ScatterDimensionNumbers;
struct ScatterDimensionNumbersDefaultTypeInternal;
extern ScatterDimensionNumbersDefaultTypeInternal _ScatterDimensionNumbers_default_instance_;
class ShapeProto;
struct ShapeProtoDefaultTypeInternal;
extern ShapeProtoDefaultTypeInternal _ShapeProto_default_instance_;
class SourceTarget;
struct SourceTargetDefaultTypeInternal;
extern SourceTargetDefaultTypeInternal _SourceTarget_default_instance_;
class TileProto;
struct TileProtoDefaultTypeInternal;
extern TileProtoDefaultTypeInternal _TileProto_default_instance_;
class TriangularSolveOptions;
struct TriangularSolveOptionsDefaultTypeInternal;
extern TriangularSolveOptionsDefaultTypeInternal _TriangularSolveOptions_default_instance_;
class WhileLoopBackendConfig;
struct WhileLoopBackendConfigDefaultTypeInternal;
extern WhileLoopBackendConfigDefaultTypeInternal _WhileLoopBackendConfig_default_instance_;
class WhileLoopBackendConfig_KnownTripCount;
struct WhileLoopBackendConfig_KnownTripCountDefaultTypeInternal;
extern WhileLoopBackendConfig_KnownTripCountDefaultTypeInternal _WhileLoopBackendConfig_KnownTripCount_default_instance_;
class Window;
struct WindowDefaultTypeInternal;
extern WindowDefaultTypeInternal _Window_default_instance_;
class WindowDimension;
struct WindowDimensionDefaultTypeInternal;
extern WindowDimensionDefaultTypeInternal _WindowDimension_default_instance_;
}  // namespace xla
PROTOBUF_NAMESPACE_OPEN
template<> ::xla::ChannelHandle* Arena::CreateMaybeMessage<::xla::ChannelHandle>(Arena*);
template<> ::xla::CholeskyOptions* Arena::CreateMaybeMessage<::xla::CholeskyOptions>(Arena*);
template<> ::xla::ComputationStats* Arena::CreateMaybeMessage<::xla::ComputationStats>(Arena*);
template<> ::xla::ConvolutionDimensionNumbers* Arena::CreateMaybeMessage<::xla::ConvolutionDimensionNumbers>(Arena*);
template<> ::xla::DeviceAssignmentProto* Arena::CreateMaybeMessage<::xla::DeviceAssignmentProto>(Arena*);
template<> ::xla::DeviceAssignmentProto_ComputationDevice* Arena::CreateMaybeMessage<::xla::DeviceAssignmentProto_ComputationDevice>(Arena*);
template<> ::xla::DeviceHandle* Arena::CreateMaybeMessage<::xla::DeviceHandle>(Arena*);
template<> ::xla::DotDimensionNumbers* Arena::CreateMaybeMessage<::xla::DotDimensionNumbers>(Arena*);
template<> ::xla::ExecutionHandle* Arena::CreateMaybeMessage<::xla::ExecutionHandle>(Arena*);
template<> ::xla::ExecutionProfile* Arena::CreateMaybeMessage<::xla::ExecutionProfile>(Arena*);
template<> ::xla::FrontendAttributes* Arena::CreateMaybeMessage<::xla::FrontendAttributes>(Arena*);
template<> ::xla::FrontendAttributes_MapEntry_DoNotUse* Arena::CreateMaybeMessage<::xla::FrontendAttributes_MapEntry_DoNotUse>(Arena*);
template<> ::xla::GatherDimensionNumbers* Arena::CreateMaybeMessage<::xla::GatherDimensionNumbers>(Arena*);
template<> ::xla::GlobalDataHandle* Arena::CreateMaybeMessage<::xla::GlobalDataHandle>(Arena*);
template<> ::xla::LayoutProto* Arena::CreateMaybeMessage<::xla::LayoutProto>(Arena*);
template<> ::xla::LiteralProto* Arena::CreateMaybeMessage<::xla::LiteralProto>(Arena*);
template<> ::xla::OpMetadata* Arena::CreateMaybeMessage<::xla::OpMetadata>(Arena*);
template<> ::xla::OpMetadata_ProfileInfo* Arena::CreateMaybeMessage<::xla::OpMetadata_ProfileInfo>(Arena*);
template<> ::xla::OpSharding* Arena::CreateMaybeMessage<::xla::OpSharding>(Arena*);
template<> ::xla::OutputOperandAliasing* Arena::CreateMaybeMessage<::xla::OutputOperandAliasing>(Arena*);
template<> ::xla::PaddingConfig* Arena::CreateMaybeMessage<::xla::PaddingConfig>(Arena*);
template<> ::xla::PaddingConfig_PaddingConfigDimension* Arena::CreateMaybeMessage<::xla::PaddingConfig_PaddingConfigDimension>(Arena*);
template<> ::xla::ParameterReplication* Arena::CreateMaybeMessage<::xla::ParameterReplication>(Arena*);
template<> ::xla::PrecisionConfig* Arena::CreateMaybeMessage<::xla::PrecisionConfig>(Arena*);
template<> ::xla::ProgramShapeProto* Arena::CreateMaybeMessage<::xla::ProgramShapeProto>(Arena*);
template<> ::xla::ReplicaGroup* Arena::CreateMaybeMessage<::xla::ReplicaGroup>(Arena*);
template<> ::xla::ScatterDimensionNumbers* Arena::CreateMaybeMessage<::xla::ScatterDimensionNumbers>(Arena*);
template<> ::xla::ShapeProto* Arena::CreateMaybeMessage<::xla::ShapeProto>(Arena*);
template<> ::xla::SourceTarget* Arena::CreateMaybeMessage<::xla::SourceTarget>(Arena*);
template<> ::xla::TileProto* Arena::CreateMaybeMessage<::xla::TileProto>(Arena*);
template<> ::xla::TriangularSolveOptions* Arena::CreateMaybeMessage<::xla::TriangularSolveOptions>(Arena*);
template<> ::xla::WhileLoopBackendConfig* Arena::CreateMaybeMessage<::xla::WhileLoopBackendConfig>(Arena*);
template<> ::xla::WhileLoopBackendConfig_KnownTripCount* Arena::CreateMaybeMessage<::xla::WhileLoopBackendConfig_KnownTripCount>(Arena*);
template<> ::xla::Window* Arena::CreateMaybeMessage<::xla::Window>(Arena*);
template<> ::xla::WindowDimension* Arena::CreateMaybeMessage<::xla::WindowDimension>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace xla {

enum ChannelHandle_ChannelType : int {
  ChannelHandle_ChannelType_CHANNEL_TYPE_INVALID = 0,
  ChannelHandle_ChannelType_DEVICE_TO_DEVICE = 1,
  ChannelHandle_ChannelType_DEVICE_TO_HOST = 2,
  ChannelHandle_ChannelType_HOST_TO_DEVICE = 3,
  ChannelHandle_ChannelType_ChannelHandle_ChannelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ChannelHandle_ChannelType_ChannelHandle_ChannelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ChannelHandle_ChannelType_IsValid(int value);
constexpr ChannelHandle_ChannelType ChannelHandle_ChannelType_ChannelType_MIN = ChannelHandle_ChannelType_CHANNEL_TYPE_INVALID;
constexpr ChannelHandle_ChannelType ChannelHandle_ChannelType_ChannelType_MAX = ChannelHandle_ChannelType_HOST_TO_DEVICE;
constexpr int ChannelHandle_ChannelType_ChannelType_ARRAYSIZE = ChannelHandle_ChannelType_ChannelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ChannelHandle_ChannelType_descriptor();
template<typename T>
inline const std::string& ChannelHandle_ChannelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ChannelHandle_ChannelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ChannelHandle_ChannelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ChannelHandle_ChannelType_descriptor(), enum_t_value);
}
inline bool ChannelHandle_ChannelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ChannelHandle_ChannelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ChannelHandle_ChannelType>(
    ChannelHandle_ChannelType_descriptor(), name, value);
}
enum TriangularSolveOptions_Transpose : int {
  TriangularSolveOptions_Transpose_TRANSPOSE_INVALID = 0,
  TriangularSolveOptions_Transpose_NO_TRANSPOSE = 1,
  TriangularSolveOptions_Transpose_TRANSPOSE = 2,
  TriangularSolveOptions_Transpose_ADJOINT = 3,
  TriangularSolveOptions_Transpose_TriangularSolveOptions_Transpose_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  TriangularSolveOptions_Transpose_TriangularSolveOptions_Transpose_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool TriangularSolveOptions_Transpose_IsValid(int value);
constexpr TriangularSolveOptions_Transpose TriangularSolveOptions_Transpose_Transpose_MIN = TriangularSolveOptions_Transpose_TRANSPOSE_INVALID;
constexpr TriangularSolveOptions_Transpose TriangularSolveOptions_Transpose_Transpose_MAX = TriangularSolveOptions_Transpose_ADJOINT;
constexpr int TriangularSolveOptions_Transpose_Transpose_ARRAYSIZE = TriangularSolveOptions_Transpose_Transpose_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TriangularSolveOptions_Transpose_descriptor();
template<typename T>
inline const std::string& TriangularSolveOptions_Transpose_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TriangularSolveOptions_Transpose>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TriangularSolveOptions_Transpose_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TriangularSolveOptions_Transpose_descriptor(), enum_t_value);
}
inline bool TriangularSolveOptions_Transpose_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TriangularSolveOptions_Transpose* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TriangularSolveOptions_Transpose>(
    TriangularSolveOptions_Transpose_descriptor(), name, value);
}
enum OpSharding_Type : int {
  OpSharding_Type_REPLICATED = 0,
  OpSharding_Type_MAXIMAL = 1,
  OpSharding_Type_TUPLE = 2,
  OpSharding_Type_OTHER = 3,
  OpSharding_Type_MANUAL = 4,
  OpSharding_Type_OpSharding_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  OpSharding_Type_OpSharding_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool OpSharding_Type_IsValid(int value);
constexpr OpSharding_Type OpSharding_Type_Type_MIN = OpSharding_Type_REPLICATED;
constexpr OpSharding_Type OpSharding_Type_Type_MAX = OpSharding_Type_MANUAL;
constexpr int OpSharding_Type_Type_ARRAYSIZE = OpSharding_Type_Type_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* OpSharding_Type_descriptor();
template<typename T>
inline const std::string& OpSharding_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, OpSharding_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function OpSharding_Type_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    OpSharding_Type_descriptor(), enum_t_value);
}
inline bool OpSharding_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, OpSharding_Type* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<OpSharding_Type>(
    OpSharding_Type_descriptor(), name, value);
}
enum PrecisionConfig_Precision : int {
  PrecisionConfig_Precision_DEFAULT = 0,
  PrecisionConfig_Precision_HIGH = 1,
  PrecisionConfig_Precision_HIGHEST = 2,
  PrecisionConfig_Precision_PACKED_NIBBLE = 3,
  PrecisionConfig_Precision_PrecisionConfig_Precision_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrecisionConfig_Precision_PrecisionConfig_Precision_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrecisionConfig_Precision_IsValid(int value);
constexpr PrecisionConfig_Precision PrecisionConfig_Precision_Precision_MIN = PrecisionConfig_Precision_DEFAULT;
constexpr PrecisionConfig_Precision PrecisionConfig_Precision_Precision_MAX = PrecisionConfig_Precision_PACKED_NIBBLE;
constexpr int PrecisionConfig_Precision_Precision_ARRAYSIZE = PrecisionConfig_Precision_Precision_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrecisionConfig_Precision_descriptor();
template<typename T>
inline const std::string& PrecisionConfig_Precision_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrecisionConfig_Precision>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrecisionConfig_Precision_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrecisionConfig_Precision_descriptor(), enum_t_value);
}
inline bool PrecisionConfig_Precision_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrecisionConfig_Precision* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrecisionConfig_Precision>(
    PrecisionConfig_Precision_descriptor(), name, value);
}
enum PrimitiveType : int {
  PRIMITIVE_TYPE_INVALID = 0,
  PRED = 1,
  S8 = 2,
  S16 = 3,
  S32 = 4,
  S64 = 5,
  U8 = 6,
  U16 = 7,
  U32 = 8,
  U64 = 9,
  F16 = 10,
  F32 = 11,
  BF16 = 16,
  F64 = 12,
  F8E5M2 = 19,
  F8E4M3FN = 20,
  C64 = 15,
  C128 = 18,
  TUPLE = 13,
  OPAQUE_TYPE = 14,
  TOKEN = 17,
  PrimitiveType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PrimitiveType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PrimitiveType_IsValid(int value);
constexpr PrimitiveType PrimitiveType_MIN = PRIMITIVE_TYPE_INVALID;
constexpr PrimitiveType PrimitiveType_MAX = F8E4M3FN;
constexpr int PrimitiveType_ARRAYSIZE = PrimitiveType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrimitiveType_descriptor();
template<typename T>
inline const std::string& PrimitiveType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PrimitiveType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PrimitiveType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PrimitiveType_descriptor(), enum_t_value);
}
inline bool PrimitiveType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PrimitiveType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PrimitiveType>(
    PrimitiveType_descriptor(), name, value);
}
enum DimLevelType : int {
  DIM_DENSE = 0,
  DIM_COMPRESSED = 1,
  DIM_SINGLETON = 2,
  DimLevelType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  DimLevelType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool DimLevelType_IsValid(int value);
constexpr DimLevelType DimLevelType_MIN = DIM_DENSE;
constexpr DimLevelType DimLevelType_MAX = DIM_SINGLETON;
constexpr int DimLevelType_ARRAYSIZE = DimLevelType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DimLevelType_descriptor();
template<typename T>
inline const std::string& DimLevelType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, DimLevelType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function DimLevelType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    DimLevelType_descriptor(), enum_t_value);
}
inline bool DimLevelType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, DimLevelType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<DimLevelType>(
    DimLevelType_descriptor(), name, value);
}
enum ProfileType : int {
  INVALID = 0,
  WINDOW = 1,
  FLAG = 2,
  INTEGER = 3,
  ProfileType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProfileType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProfileType_IsValid(int value);
constexpr ProfileType ProfileType_MIN = INVALID;
constexpr ProfileType ProfileType_MAX = INTEGER;
constexpr int ProfileType_ARRAYSIZE = ProfileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProfileType_descriptor();
template<typename T>
inline const std::string& ProfileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProfileType_descriptor(), enum_t_value);
}
inline bool ProfileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProfileType>(
    ProfileType_descriptor(), name, value);
}
enum ProfileSource : int {
  PROFILE_SOURCE_UNKNOWN_SOURCE = 0,
  PROFILE_SOURCE_EMBEDDED = 1,
  PROFILE_SOURCE_REMOTE = 2,
  ProfileSource_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ProfileSource_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ProfileSource_IsValid(int value);
constexpr ProfileSource ProfileSource_MIN = PROFILE_SOURCE_UNKNOWN_SOURCE;
constexpr ProfileSource ProfileSource_MAX = PROFILE_SOURCE_REMOTE;
constexpr int ProfileSource_ARRAYSIZE = ProfileSource_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ProfileSource_descriptor();
template<typename T>
inline const std::string& ProfileSource_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ProfileSource>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ProfileSource_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ProfileSource_descriptor(), enum_t_value);
}
inline bool ProfileSource_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ProfileSource* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ProfileSource>(
    ProfileSource_descriptor(), name, value);
}
enum CompilationEvent : int {
  COMPILATION_EVENT_UNKNOWN_EVENT = 0,
  COMPILATION_EVENT_FIRST_COMPILATION = 1,
  COMPILATION_EVENT_RECOMPILATION = 2,
  CompilationEvent_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CompilationEvent_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CompilationEvent_IsValid(int value);
constexpr CompilationEvent CompilationEvent_MIN = COMPILATION_EVENT_UNKNOWN_EVENT;
constexpr CompilationEvent CompilationEvent_MAX = COMPILATION_EVENT_RECOMPILATION;
constexpr int CompilationEvent_ARRAYSIZE = CompilationEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CompilationEvent_descriptor();
template<typename T>
inline const std::string& CompilationEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CompilationEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CompilationEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CompilationEvent_descriptor(), enum_t_value);
}
inline bool CompilationEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CompilationEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CompilationEvent>(
    CompilationEvent_descriptor(), name, value);
}
enum PaddingType : int {
  PADDING_INVALID = 0,
  PADDING_VALID = 1,
  PADDING_SAME = 2,
  PaddingType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PaddingType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PaddingType_IsValid(int value);
constexpr PaddingType PaddingType_MIN = PADDING_INVALID;
constexpr PaddingType PaddingType_MAX = PADDING_SAME;
constexpr int PaddingType_ARRAYSIZE = PaddingType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PaddingType_descriptor();
template<typename T>
inline const std::string& PaddingType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PaddingType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PaddingType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PaddingType_descriptor(), enum_t_value);
}
inline bool PaddingType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PaddingType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PaddingType>(
    PaddingType_descriptor(), name, value);
}
enum FftType : int {
  FFT = 0,
  IFFT = 1,
  RFFT = 2,
  IRFFT = 3,
  FftType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  FftType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool FftType_IsValid(int value);
constexpr FftType FftType_MIN = FFT;
constexpr FftType FftType_MAX = IRFFT;
constexpr int FftType_ARRAYSIZE = FftType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* FftType_descriptor();
template<typename T>
inline const std::string& FftType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, FftType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function FftType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    FftType_descriptor(), enum_t_value);
}
inline bool FftType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, FftType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<FftType>(
    FftType_descriptor(), name, value);
}
enum RandomDistribution : int {
  RNG_INVALID = 0,
  RNG_UNIFORM = 1,
  RNG_NORMAL = 2,
  RandomDistribution_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RandomDistribution_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RandomDistribution_IsValid(int value);
constexpr RandomDistribution RandomDistribution_MIN = RNG_INVALID;
constexpr RandomDistribution RandomDistribution_MAX = RNG_NORMAL;
constexpr int RandomDistribution_ARRAYSIZE = RandomDistribution_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RandomDistribution_descriptor();
template<typename T>
inline const std::string& RandomDistribution_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RandomDistribution>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RandomDistribution_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RandomDistribution_descriptor(), enum_t_value);
}
inline bool RandomDistribution_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RandomDistribution* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RandomDistribution>(
    RandomDistribution_descriptor(), name, value);
}
enum RandomAlgorithm : int {
  RNG_DEFAULT = 0,
  RNG_THREE_FRY = 1,
  RNG_PHILOX = 2,
  RandomAlgorithm_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  RandomAlgorithm_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool RandomAlgorithm_IsValid(int value);
constexpr RandomAlgorithm RandomAlgorithm_MIN = RNG_DEFAULT;
constexpr RandomAlgorithm RandomAlgorithm_MAX = RNG_PHILOX;
constexpr int RandomAlgorithm_ARRAYSIZE = RandomAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RandomAlgorithm_descriptor();
template<typename T>
inline const std::string& RandomAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, RandomAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function RandomAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    RandomAlgorithm_descriptor(), enum_t_value);
}
inline bool RandomAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, RandomAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<RandomAlgorithm>(
    RandomAlgorithm_descriptor(), name, value);
}
// ===================================================================

class PaddingConfig_PaddingConfigDimension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.PaddingConfig.PaddingConfigDimension) */ {
 public:
  inline PaddingConfig_PaddingConfigDimension() : PaddingConfig_PaddingConfigDimension(nullptr) {}
  ~PaddingConfig_PaddingConfigDimension() override;
  explicit PROTOBUF_CONSTEXPR PaddingConfig_PaddingConfigDimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaddingConfig_PaddingConfigDimension(const PaddingConfig_PaddingConfigDimension& from);
  PaddingConfig_PaddingConfigDimension(PaddingConfig_PaddingConfigDimension&& from) noexcept
    : PaddingConfig_PaddingConfigDimension() {
    *this = ::std::move(from);
  }

  inline PaddingConfig_PaddingConfigDimension& operator=(const PaddingConfig_PaddingConfigDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaddingConfig_PaddingConfigDimension& operator=(PaddingConfig_PaddingConfigDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaddingConfig_PaddingConfigDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaddingConfig_PaddingConfigDimension* internal_default_instance() {
    return reinterpret_cast<const PaddingConfig_PaddingConfigDimension*>(
               &_PaddingConfig_PaddingConfigDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PaddingConfig_PaddingConfigDimension& a, PaddingConfig_PaddingConfigDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(PaddingConfig_PaddingConfigDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaddingConfig_PaddingConfigDimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaddingConfig_PaddingConfigDimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaddingConfig_PaddingConfigDimension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaddingConfig_PaddingConfigDimension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaddingConfig_PaddingConfigDimension& from) {
    PaddingConfig_PaddingConfigDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaddingConfig_PaddingConfigDimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.PaddingConfig.PaddingConfigDimension";
  }
  protected:
  explicit PaddingConfig_PaddingConfigDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEdgePaddingLowFieldNumber = 1,
    kEdgePaddingHighFieldNumber = 2,
    kInteriorPaddingFieldNumber = 3,
  };
  // int64 edge_padding_low = 1;
  void clear_edge_padding_low();
  int64_t edge_padding_low() const;
  void set_edge_padding_low(int64_t value);
  private:
  int64_t _internal_edge_padding_low() const;
  void _internal_set_edge_padding_low(int64_t value);
  public:

  // int64 edge_padding_high = 2;
  void clear_edge_padding_high();
  int64_t edge_padding_high() const;
  void set_edge_padding_high(int64_t value);
  private:
  int64_t _internal_edge_padding_high() const;
  void _internal_set_edge_padding_high(int64_t value);
  public:

  // int64 interior_padding = 3;
  void clear_interior_padding();
  int64_t interior_padding() const;
  void set_interior_padding(int64_t value);
  private:
  int64_t _internal_interior_padding() const;
  void _internal_set_interior_padding(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.PaddingConfig.PaddingConfigDimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t edge_padding_low_;
    int64_t edge_padding_high_;
    int64_t interior_padding_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PaddingConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.PaddingConfig) */ {
 public:
  inline PaddingConfig() : PaddingConfig(nullptr) {}
  ~PaddingConfig() override;
  explicit PROTOBUF_CONSTEXPR PaddingConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaddingConfig(const PaddingConfig& from);
  PaddingConfig(PaddingConfig&& from) noexcept
    : PaddingConfig() {
    *this = ::std::move(from);
  }

  inline PaddingConfig& operator=(const PaddingConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaddingConfig& operator=(PaddingConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaddingConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaddingConfig* internal_default_instance() {
    return reinterpret_cast<const PaddingConfig*>(
               &_PaddingConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PaddingConfig& a, PaddingConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PaddingConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaddingConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaddingConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaddingConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaddingConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PaddingConfig& from) {
    PaddingConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaddingConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.PaddingConfig";
  }
  protected:
  explicit PaddingConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PaddingConfig_PaddingConfigDimension PaddingConfigDimension;

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 1,
  };
  // repeated .xla.PaddingConfig.PaddingConfigDimension dimensions = 1;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  ::xla::PaddingConfig_PaddingConfigDimension* mutable_dimensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::PaddingConfig_PaddingConfigDimension >*
      mutable_dimensions();
  private:
  const ::xla::PaddingConfig_PaddingConfigDimension& _internal_dimensions(int index) const;
  ::xla::PaddingConfig_PaddingConfigDimension* _internal_add_dimensions();
  public:
  const ::xla::PaddingConfig_PaddingConfigDimension& dimensions(int index) const;
  ::xla::PaddingConfig_PaddingConfigDimension* add_dimensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::PaddingConfig_PaddingConfigDimension >&
      dimensions() const;

  // @@protoc_insertion_point(class_scope:xla.PaddingConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::PaddingConfig_PaddingConfigDimension > dimensions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TileProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TileProto) */ {
 public:
  inline TileProto() : TileProto(nullptr) {}
  ~TileProto() override;
  explicit PROTOBUF_CONSTEXPR TileProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TileProto(const TileProto& from);
  TileProto(TileProto&& from) noexcept
    : TileProto() {
    *this = ::std::move(from);
  }

  inline TileProto& operator=(const TileProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline TileProto& operator=(TileProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TileProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const TileProto* internal_default_instance() {
    return reinterpret_cast<const TileProto*>(
               &_TileProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(TileProto& a, TileProto& b) {
    a.Swap(&b);
  }
  inline void Swap(TileProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TileProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TileProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TileProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TileProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TileProto& from) {
    TileProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TileProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TileProto";
  }
  protected:
  explicit TileProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 1,
  };
  // repeated int64 dimensions = 1;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  private:
  int64_t _internal_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dimensions() const;
  void _internal_add_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dimensions();
  public:
  int64_t dimensions(int index) const;
  void set_dimensions(int index, int64_t value);
  void add_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dimensions();

  // @@protoc_insertion_point(class_scope:xla.TileProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dimensions_;
    mutable std::atomic<int> _dimensions_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LayoutProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.LayoutProto) */ {
 public:
  inline LayoutProto() : LayoutProto(nullptr) {}
  ~LayoutProto() override;
  explicit PROTOBUF_CONSTEXPR LayoutProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LayoutProto(const LayoutProto& from);
  LayoutProto(LayoutProto&& from) noexcept
    : LayoutProto() {
    *this = ::std::move(from);
  }

  inline LayoutProto& operator=(const LayoutProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LayoutProto& operator=(LayoutProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LayoutProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LayoutProto* internal_default_instance() {
    return reinterpret_cast<const LayoutProto*>(
               &_LayoutProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(LayoutProto& a, LayoutProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LayoutProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LayoutProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LayoutProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LayoutProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LayoutProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LayoutProto& from) {
    LayoutProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LayoutProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.LayoutProto";
  }
  protected:
  explicit LayoutProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMinorToMajorFieldNumber = 1,
    kTilesFieldNumber = 6,
    kDimLevelTypesFieldNumber = 9,
    kDimUniqueFieldNumber = 13,
    kDimOrderedFieldNumber = 14,
    kPhysicalShapeFieldNumber = 10,
    kMemorySpaceFieldNumber = 8,
    kIndexPrimitiveTypeFieldNumber = 11,
    kPointerPrimitiveTypeFieldNumber = 12,
    kDynamicShapeMetadataPrefixBytesFieldNumber = 15,
  };
  // repeated int64 minor_to_major = 1;
  int minor_to_major_size() const;
  private:
  int _internal_minor_to_major_size() const;
  public:
  void clear_minor_to_major();
  private:
  int64_t _internal_minor_to_major(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_minor_to_major() const;
  void _internal_add_minor_to_major(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_minor_to_major();
  public:
  int64_t minor_to_major(int index) const;
  void set_minor_to_major(int index, int64_t value);
  void add_minor_to_major(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      minor_to_major() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_minor_to_major();

  // repeated .xla.TileProto tiles = 6;
  int tiles_size() const;
  private:
  int _internal_tiles_size() const;
  public:
  void clear_tiles();
  ::xla::TileProto* mutable_tiles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::TileProto >*
      mutable_tiles();
  private:
  const ::xla::TileProto& _internal_tiles(int index) const;
  ::xla::TileProto* _internal_add_tiles();
  public:
  const ::xla::TileProto& tiles(int index) const;
  ::xla::TileProto* add_tiles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::TileProto >&
      tiles() const;

  // repeated .xla.DimLevelType dim_level_types = 9;
  int dim_level_types_size() const;
  private:
  int _internal_dim_level_types_size() const;
  public:
  void clear_dim_level_types();
  private:
  ::xla::DimLevelType _internal_dim_level_types(int index) const;
  void _internal_add_dim_level_types(::xla::DimLevelType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_dim_level_types();
  public:
  ::xla::DimLevelType dim_level_types(int index) const;
  void set_dim_level_types(int index, ::xla::DimLevelType value);
  void add_dim_level_types(::xla::DimLevelType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& dim_level_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_dim_level_types();

  // repeated bool dim_unique = 13;
  int dim_unique_size() const;
  private:
  int _internal_dim_unique_size() const;
  public:
  void clear_dim_unique();
  private:
  bool _internal_dim_unique(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_dim_unique() const;
  void _internal_add_dim_unique(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_dim_unique();
  public:
  bool dim_unique(int index) const;
  void set_dim_unique(int index, bool value);
  void add_dim_unique(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      dim_unique() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_dim_unique();

  // repeated bool dim_ordered = 14;
  int dim_ordered_size() const;
  private:
  int _internal_dim_ordered_size() const;
  public:
  void clear_dim_ordered();
  private:
  bool _internal_dim_ordered(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_dim_ordered() const;
  void _internal_add_dim_ordered(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_dim_ordered();
  public:
  bool dim_ordered(int index) const;
  void set_dim_ordered(int index, bool value);
  void add_dim_ordered(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      dim_ordered() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_dim_ordered();

  // .xla.ShapeProto physical_shape = 10;
  bool has_physical_shape() const;
  private:
  bool _internal_has_physical_shape() const;
  public:
  void clear_physical_shape();
  const ::xla::ShapeProto& physical_shape() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_physical_shape();
  ::xla::ShapeProto* mutable_physical_shape();
  void set_allocated_physical_shape(::xla::ShapeProto* physical_shape);
  private:
  const ::xla::ShapeProto& _internal_physical_shape() const;
  ::xla::ShapeProto* _internal_mutable_physical_shape();
  public:
  void unsafe_arena_set_allocated_physical_shape(
      ::xla::ShapeProto* physical_shape);
  ::xla::ShapeProto* unsafe_arena_release_physical_shape();

  // int64 memory_space = 8;
  void clear_memory_space();
  int64_t memory_space() const;
  void set_memory_space(int64_t value);
  private:
  int64_t _internal_memory_space() const;
  void _internal_set_memory_space(int64_t value);
  public:

  // .xla.PrimitiveType index_primitive_type = 11;
  void clear_index_primitive_type();
  ::xla::PrimitiveType index_primitive_type() const;
  void set_index_primitive_type(::xla::PrimitiveType value);
  private:
  ::xla::PrimitiveType _internal_index_primitive_type() const;
  void _internal_set_index_primitive_type(::xla::PrimitiveType value);
  public:

  // .xla.PrimitiveType pointer_primitive_type = 12;
  void clear_pointer_primitive_type();
  ::xla::PrimitiveType pointer_primitive_type() const;
  void set_pointer_primitive_type(::xla::PrimitiveType value);
  private:
  ::xla::PrimitiveType _internal_pointer_primitive_type() const;
  void _internal_set_pointer_primitive_type(::xla::PrimitiveType value);
  public:

  // int64 dynamic_shape_metadata_prefix_bytes = 15;
  void clear_dynamic_shape_metadata_prefix_bytes();
  int64_t dynamic_shape_metadata_prefix_bytes() const;
  void set_dynamic_shape_metadata_prefix_bytes(int64_t value);
  private:
  int64_t _internal_dynamic_shape_metadata_prefix_bytes() const;
  void _internal_set_dynamic_shape_metadata_prefix_bytes(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.LayoutProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > minor_to_major_;
    mutable std::atomic<int> _minor_to_major_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::TileProto > tiles_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> dim_level_types_;
    mutable std::atomic<int> _dim_level_types_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > dim_unique_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > dim_ordered_;
    ::xla::ShapeProto* physical_shape_;
    int64_t memory_space_;
    int index_primitive_type_;
    int pointer_primitive_type_;
    int64_t dynamic_shape_metadata_prefix_bytes_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ShapeProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ShapeProto) */ {
 public:
  inline ShapeProto() : ShapeProto(nullptr) {}
  ~ShapeProto() override;
  explicit PROTOBUF_CONSTEXPR ShapeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ShapeProto(const ShapeProto& from);
  ShapeProto(ShapeProto&& from) noexcept
    : ShapeProto() {
    *this = ::std::move(from);
  }

  inline ShapeProto& operator=(const ShapeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ShapeProto& operator=(ShapeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ShapeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ShapeProto* internal_default_instance() {
    return reinterpret_cast<const ShapeProto*>(
               &_ShapeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ShapeProto& a, ShapeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ShapeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ShapeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ShapeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ShapeProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ShapeProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ShapeProto& from) {
    ShapeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ShapeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ShapeProto";
  }
  protected:
  explicit ShapeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 3,
    kTupleShapesFieldNumber = 4,
    kIsDynamicDimensionFieldNumber = 6,
    kLayoutFieldNumber = 5,
    kElementTypeFieldNumber = 2,
  };
  // repeated int64 dimensions = 3;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  private:
  int64_t _internal_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_dimensions() const;
  void _internal_add_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_dimensions();
  public:
  int64_t dimensions(int index) const;
  void set_dimensions(int index, int64_t value);
  void add_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_dimensions();

  // repeated .xla.ShapeProto tuple_shapes = 4;
  int tuple_shapes_size() const;
  private:
  int _internal_tuple_shapes_size() const;
  public:
  void clear_tuple_shapes();
  ::xla::ShapeProto* mutable_tuple_shapes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShapeProto >*
      mutable_tuple_shapes();
  private:
  const ::xla::ShapeProto& _internal_tuple_shapes(int index) const;
  ::xla::ShapeProto* _internal_add_tuple_shapes();
  public:
  const ::xla::ShapeProto& tuple_shapes(int index) const;
  ::xla::ShapeProto* add_tuple_shapes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShapeProto >&
      tuple_shapes() const;

  // repeated bool is_dynamic_dimension = 6;
  int is_dynamic_dimension_size() const;
  private:
  int _internal_is_dynamic_dimension_size() const;
  public:
  void clear_is_dynamic_dimension();
  private:
  bool _internal_is_dynamic_dimension(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_is_dynamic_dimension() const;
  void _internal_add_is_dynamic_dimension(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_is_dynamic_dimension();
  public:
  bool is_dynamic_dimension(int index) const;
  void set_is_dynamic_dimension(int index, bool value);
  void add_is_dynamic_dimension(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      is_dynamic_dimension() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_is_dynamic_dimension();

  // .xla.LayoutProto layout = 5;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const ::xla::LayoutProto& layout() const;
  PROTOBUF_NODISCARD ::xla::LayoutProto* release_layout();
  ::xla::LayoutProto* mutable_layout();
  void set_allocated_layout(::xla::LayoutProto* layout);
  private:
  const ::xla::LayoutProto& _internal_layout() const;
  ::xla::LayoutProto* _internal_mutable_layout();
  public:
  void unsafe_arena_set_allocated_layout(
      ::xla::LayoutProto* layout);
  ::xla::LayoutProto* unsafe_arena_release_layout();

  // .xla.PrimitiveType element_type = 2;
  void clear_element_type();
  ::xla::PrimitiveType element_type() const;
  void set_element_type(::xla::PrimitiveType value);
  private:
  ::xla::PrimitiveType _internal_element_type() const;
  void _internal_set_element_type(::xla::PrimitiveType value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ShapeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > dimensions_;
    mutable std::atomic<int> _dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShapeProto > tuple_shapes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > is_dynamic_dimension_;
    ::xla::LayoutProto* layout_;
    int element_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ProgramShapeProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ProgramShapeProto) */ {
 public:
  inline ProgramShapeProto() : ProgramShapeProto(nullptr) {}
  ~ProgramShapeProto() override;
  explicit PROTOBUF_CONSTEXPR ProgramShapeProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProgramShapeProto(const ProgramShapeProto& from);
  ProgramShapeProto(ProgramShapeProto&& from) noexcept
    : ProgramShapeProto() {
    *this = ::std::move(from);
  }

  inline ProgramShapeProto& operator=(const ProgramShapeProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProgramShapeProto& operator=(ProgramShapeProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProgramShapeProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProgramShapeProto* internal_default_instance() {
    return reinterpret_cast<const ProgramShapeProto*>(
               &_ProgramShapeProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ProgramShapeProto& a, ProgramShapeProto& b) {
    a.Swap(&b);
  }
  inline void Swap(ProgramShapeProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProgramShapeProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ProgramShapeProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ProgramShapeProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProgramShapeProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ProgramShapeProto& from) {
    ProgramShapeProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProgramShapeProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ProgramShapeProto";
  }
  protected:
  explicit ProgramShapeProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParametersFieldNumber = 1,
    kParameterNamesFieldNumber = 3,
    kResultFieldNumber = 2,
  };
  // repeated .xla.ShapeProto parameters = 1;
  int parameters_size() const;
  private:
  int _internal_parameters_size() const;
  public:
  void clear_parameters();
  ::xla::ShapeProto* mutable_parameters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShapeProto >*
      mutable_parameters();
  private:
  const ::xla::ShapeProto& _internal_parameters(int index) const;
  ::xla::ShapeProto* _internal_add_parameters();
  public:
  const ::xla::ShapeProto& parameters(int index) const;
  ::xla::ShapeProto* add_parameters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShapeProto >&
      parameters() const;

  // repeated string parameter_names = 3;
  int parameter_names_size() const;
  private:
  int _internal_parameter_names_size() const;
  public:
  void clear_parameter_names();
  const std::string& parameter_names(int index) const;
  std::string* mutable_parameter_names(int index);
  void set_parameter_names(int index, const std::string& value);
  void set_parameter_names(int index, std::string&& value);
  void set_parameter_names(int index, const char* value);
  void set_parameter_names(int index, const char* value, size_t size);
  std::string* add_parameter_names();
  void add_parameter_names(const std::string& value);
  void add_parameter_names(std::string&& value);
  void add_parameter_names(const char* value);
  void add_parameter_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& parameter_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_parameter_names();
  private:
  const std::string& _internal_parameter_names(int index) const;
  std::string* _internal_add_parameter_names();
  public:

  // .xla.ShapeProto result = 2;
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  const ::xla::ShapeProto& result() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_result();
  ::xla::ShapeProto* mutable_result();
  void set_allocated_result(::xla::ShapeProto* result);
  private:
  const ::xla::ShapeProto& _internal_result() const;
  ::xla::ShapeProto* _internal_mutable_result();
  public:
  void unsafe_arena_set_allocated_result(
      ::xla::ShapeProto* result);
  ::xla::ShapeProto* unsafe_arena_release_result();

  // @@protoc_insertion_point(class_scope:xla.ProgramShapeProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::ShapeProto > parameters_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> parameter_names_;
    ::xla::ShapeProto* result_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ComputationStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ComputationStats) */ {
 public:
  inline ComputationStats() : ComputationStats(nullptr) {}
  ~ComputationStats() override;
  explicit PROTOBUF_CONSTEXPR ComputationStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ComputationStats(const ComputationStats& from);
  ComputationStats(ComputationStats&& from) noexcept
    : ComputationStats() {
    *this = ::std::move(from);
  }

  inline ComputationStats& operator=(const ComputationStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline ComputationStats& operator=(ComputationStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ComputationStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const ComputationStats* internal_default_instance() {
    return reinterpret_cast<const ComputationStats*>(
               &_ComputationStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(ComputationStats& a, ComputationStats& b) {
    a.Swap(&b);
  }
  inline void Swap(ComputationStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ComputationStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ComputationStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ComputationStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ComputationStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ComputationStats& from) {
    ComputationStats::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ComputationStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ComputationStats";
  }
  protected:
  explicit ComputationStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlopCountFieldNumber = 1,
    kTranscendentalCountFieldNumber = 2,
  };
  // double flop_count = 1;
  void clear_flop_count();
  double flop_count() const;
  void set_flop_count(double value);
  private:
  double _internal_flop_count() const;
  void _internal_set_flop_count(double value);
  public:

  // double transcendental_count = 2;
  void clear_transcendental_count();
  double transcendental_count() const;
  void set_transcendental_count(double value);
  private:
  double _internal_transcendental_count() const;
  void _internal_set_transcendental_count(double value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ComputationStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    double flop_count_;
    double transcendental_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class OpMetadata_ProfileInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.OpMetadata.ProfileInfo) */ {
 public:
  inline OpMetadata_ProfileInfo() : OpMetadata_ProfileInfo(nullptr) {}
  ~OpMetadata_ProfileInfo() override;
  explicit PROTOBUF_CONSTEXPR OpMetadata_ProfileInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpMetadata_ProfileInfo(const OpMetadata_ProfileInfo& from);
  OpMetadata_ProfileInfo(OpMetadata_ProfileInfo&& from) noexcept
    : OpMetadata_ProfileInfo() {
    *this = ::std::move(from);
  }

  inline OpMetadata_ProfileInfo& operator=(const OpMetadata_ProfileInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpMetadata_ProfileInfo& operator=(OpMetadata_ProfileInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpMetadata_ProfileInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpMetadata_ProfileInfo* internal_default_instance() {
    return reinterpret_cast<const OpMetadata_ProfileInfo*>(
               &_OpMetadata_ProfileInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(OpMetadata_ProfileInfo& a, OpMetadata_ProfileInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OpMetadata_ProfileInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpMetadata_ProfileInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpMetadata_ProfileInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpMetadata_ProfileInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpMetadata_ProfileInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpMetadata_ProfileInfo& from) {
    OpMetadata_ProfileInfo::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpMetadata_ProfileInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.OpMetadata.ProfileInfo";
  }
  protected:
  explicit OpMetadata_ProfileInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProfileTypeFieldNumber = 1,
    kRelativeSpeedupFieldNumber = 2,
    kProfileSourceFieldNumber = 3,
    kCompilationEventFieldNumber = 4,
  };
  // repeated .xla.ProfileType profile_type = 1;
  int profile_type_size() const;
  private:
  int _internal_profile_type_size() const;
  public:
  void clear_profile_type();
  private:
  ::xla::ProfileType _internal_profile_type(int index) const;
  void _internal_add_profile_type(::xla::ProfileType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_profile_type();
  public:
  ::xla::ProfileType profile_type(int index) const;
  void set_profile_type(int index, ::xla::ProfileType value);
  void add_profile_type(::xla::ProfileType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& profile_type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_profile_type();

  // double relative_speedup = 2;
  void clear_relative_speedup();
  double relative_speedup() const;
  void set_relative_speedup(double value);
  private:
  double _internal_relative_speedup() const;
  void _internal_set_relative_speedup(double value);
  public:

  // .xla.ProfileSource profile_source = 3;
  void clear_profile_source();
  ::xla::ProfileSource profile_source() const;
  void set_profile_source(::xla::ProfileSource value);
  private:
  ::xla::ProfileSource _internal_profile_source() const;
  void _internal_set_profile_source(::xla::ProfileSource value);
  public:

  // .xla.CompilationEvent compilation_event = 4;
  void clear_compilation_event();
  ::xla::CompilationEvent compilation_event() const;
  void set_compilation_event(::xla::CompilationEvent value);
  private:
  ::xla::CompilationEvent _internal_compilation_event() const;
  void _internal_set_compilation_event(::xla::CompilationEvent value);
  public:

  // @@protoc_insertion_point(class_scope:xla.OpMetadata.ProfileInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> profile_type_;
    mutable std::atomic<int> _profile_type_cached_byte_size_;
    double relative_speedup_;
    int profile_source_;
    int compilation_event_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class OpMetadata final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.OpMetadata) */ {
 public:
  inline OpMetadata() : OpMetadata(nullptr) {}
  ~OpMetadata() override;
  explicit PROTOBUF_CONSTEXPR OpMetadata(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpMetadata(const OpMetadata& from);
  OpMetadata(OpMetadata&& from) noexcept
    : OpMetadata() {
    *this = ::std::move(from);
  }

  inline OpMetadata& operator=(const OpMetadata& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpMetadata& operator=(OpMetadata&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpMetadata& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpMetadata* internal_default_instance() {
    return reinterpret_cast<const OpMetadata*>(
               &_OpMetadata_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(OpMetadata& a, OpMetadata& b) {
    a.Swap(&b);
  }
  inline void Swap(OpMetadata* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpMetadata* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpMetadata* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpMetadata>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpMetadata& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpMetadata& from) {
    OpMetadata::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpMetadata* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.OpMetadata";
  }
  protected:
  explicit OpMetadata(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpMetadata_ProfileInfo ProfileInfo;

  // accessors -------------------------------------------------------

  enum : int {
    kProfileTypeFieldNumber = 5,
    kOpTypeFieldNumber = 1,
    kOpNameFieldNumber = 2,
    kSourceFileFieldNumber = 3,
    kProfileInfoFieldNumber = 10,
    kCreationPassIdFieldNumber = 6,
    kLogicalCreationPassIdFieldNumber = 7,
    kSizeOfGeneratedCodeInBytesFieldNumber = 8,
    kSizeOfMemoryWorkingSetInBytesFieldNumber = 9,
    kSourceLineFieldNumber = 4,
  };
  // repeated .xla.ProfileType profile_type = 5 [deprecated = true];
  PROTOBUF_DEPRECATED int profile_type_size() const;
  private:
  int _internal_profile_type_size() const;
  public:
  PROTOBUF_DEPRECATED void clear_profile_type();
  private:
  ::xla::ProfileType _internal_profile_type(int index) const;
  void _internal_add_profile_type(::xla::ProfileType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_profile_type();
  public:
  PROTOBUF_DEPRECATED ::xla::ProfileType profile_type(int index) const;
  PROTOBUF_DEPRECATED void set_profile_type(int index, ::xla::ProfileType value);
  PROTOBUF_DEPRECATED void add_profile_type(::xla::ProfileType value);
  PROTOBUF_DEPRECATED const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& profile_type() const;
  PROTOBUF_DEPRECATED ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_profile_type();

  // string op_type = 1;
  void clear_op_type();
  const std::string& op_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_type();
  PROTOBUF_NODISCARD std::string* release_op_type();
  void set_allocated_op_type(std::string* op_type);
  private:
  const std::string& _internal_op_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_type(const std::string& value);
  std::string* _internal_mutable_op_type();
  public:

  // string op_name = 2;
  void clear_op_name();
  const std::string& op_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_op_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_op_name();
  PROTOBUF_NODISCARD std::string* release_op_name();
  void set_allocated_op_name(std::string* op_name);
  private:
  const std::string& _internal_op_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_op_name(const std::string& value);
  std::string* _internal_mutable_op_name();
  public:

  // string source_file = 3;
  void clear_source_file();
  const std::string& source_file() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_source_file(ArgT0&& arg0, ArgT... args);
  std::string* mutable_source_file();
  PROTOBUF_NODISCARD std::string* release_source_file();
  void set_allocated_source_file(std::string* source_file);
  private:
  const std::string& _internal_source_file() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_source_file(const std::string& value);
  std::string* _internal_mutable_source_file();
  public:

  // .xla.OpMetadata.ProfileInfo profile_info = 10;
  bool has_profile_info() const;
  private:
  bool _internal_has_profile_info() const;
  public:
  void clear_profile_info();
  const ::xla::OpMetadata_ProfileInfo& profile_info() const;
  PROTOBUF_NODISCARD ::xla::OpMetadata_ProfileInfo* release_profile_info();
  ::xla::OpMetadata_ProfileInfo* mutable_profile_info();
  void set_allocated_profile_info(::xla::OpMetadata_ProfileInfo* profile_info);
  private:
  const ::xla::OpMetadata_ProfileInfo& _internal_profile_info() const;
  ::xla::OpMetadata_ProfileInfo* _internal_mutable_profile_info();
  public:
  void unsafe_arena_set_allocated_profile_info(
      ::xla::OpMetadata_ProfileInfo* profile_info);
  ::xla::OpMetadata_ProfileInfo* unsafe_arena_release_profile_info();

  // int64 creation_pass_id = 6;
  void clear_creation_pass_id();
  int64_t creation_pass_id() const;
  void set_creation_pass_id(int64_t value);
  private:
  int64_t _internal_creation_pass_id() const;
  void _internal_set_creation_pass_id(int64_t value);
  public:

  // int64 logical_creation_pass_id = 7;
  void clear_logical_creation_pass_id();
  int64_t logical_creation_pass_id() const;
  void set_logical_creation_pass_id(int64_t value);
  private:
  int64_t _internal_logical_creation_pass_id() const;
  void _internal_set_logical_creation_pass_id(int64_t value);
  public:

  // int64 size_of_generated_code_in_bytes = 8;
  void clear_size_of_generated_code_in_bytes();
  int64_t size_of_generated_code_in_bytes() const;
  void set_size_of_generated_code_in_bytes(int64_t value);
  private:
  int64_t _internal_size_of_generated_code_in_bytes() const;
  void _internal_set_size_of_generated_code_in_bytes(int64_t value);
  public:

  // int64 size_of_memory_working_set_in_bytes = 9;
  void clear_size_of_memory_working_set_in_bytes();
  int64_t size_of_memory_working_set_in_bytes() const;
  void set_size_of_memory_working_set_in_bytes(int64_t value);
  private:
  int64_t _internal_size_of_memory_working_set_in_bytes() const;
  void _internal_set_size_of_memory_working_set_in_bytes(int64_t value);
  public:

  // int32 source_line = 4;
  void clear_source_line();
  int32_t source_line() const;
  void set_source_line(int32_t value);
  private:
  int32_t _internal_source_line() const;
  void _internal_set_source_line(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.OpMetadata)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> profile_type_;
    mutable std::atomic<int> _profile_type_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr op_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr source_file_;
    ::xla::OpMetadata_ProfileInfo* profile_info_;
    int64_t creation_pass_id_;
    int64_t logical_creation_pass_id_;
    int64_t size_of_generated_code_in_bytes_;
    int64_t size_of_memory_working_set_in_bytes_;
    int32_t source_line_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ExecutionProfile final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ExecutionProfile) */ {
 public:
  inline ExecutionProfile() : ExecutionProfile(nullptr) {}
  ~ExecutionProfile() override;
  explicit PROTOBUF_CONSTEXPR ExecutionProfile(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionProfile(const ExecutionProfile& from);
  ExecutionProfile(ExecutionProfile&& from) noexcept
    : ExecutionProfile() {
    *this = ::std::move(from);
  }

  inline ExecutionProfile& operator=(const ExecutionProfile& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionProfile& operator=(ExecutionProfile&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionProfile& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionProfile* internal_default_instance() {
    return reinterpret_cast<const ExecutionProfile*>(
               &_ExecutionProfile_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(ExecutionProfile& a, ExecutionProfile& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionProfile* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionProfile* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionProfile* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionProfile>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionProfile& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionProfile& from) {
    ExecutionProfile::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionProfile* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ExecutionProfile";
  }
  protected:
  explicit ExecutionProfile(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCompileTimeMsFieldNumber = 2,
    kComputeCycleCountFieldNumber = 3,
    kComputeTimeNsFieldNumber = 4,
    kComputeAndTransferTimeNsFieldNumber = 5,
    kExecutableSizeInBytesFieldNumber = 6,
    kCompilationCacheHitFieldNumber = 1,
    kProfileCacheHitFieldNumber = 7,
  };
  // int64 compile_time_ms = 2;
  void clear_compile_time_ms();
  int64_t compile_time_ms() const;
  void set_compile_time_ms(int64_t value);
  private:
  int64_t _internal_compile_time_ms() const;
  void _internal_set_compile_time_ms(int64_t value);
  public:

  // int64 compute_cycle_count = 3;
  void clear_compute_cycle_count();
  int64_t compute_cycle_count() const;
  void set_compute_cycle_count(int64_t value);
  private:
  int64_t _internal_compute_cycle_count() const;
  void _internal_set_compute_cycle_count(int64_t value);
  public:

  // int64 compute_time_ns = 4;
  void clear_compute_time_ns();
  int64_t compute_time_ns() const;
  void set_compute_time_ns(int64_t value);
  private:
  int64_t _internal_compute_time_ns() const;
  void _internal_set_compute_time_ns(int64_t value);
  public:

  // int64 compute_and_transfer_time_ns = 5;
  void clear_compute_and_transfer_time_ns();
  int64_t compute_and_transfer_time_ns() const;
  void set_compute_and_transfer_time_ns(int64_t value);
  private:
  int64_t _internal_compute_and_transfer_time_ns() const;
  void _internal_set_compute_and_transfer_time_ns(int64_t value);
  public:

  // int64 executable_size_in_bytes = 6;
  void clear_executable_size_in_bytes();
  int64_t executable_size_in_bytes() const;
  void set_executable_size_in_bytes(int64_t value);
  private:
  int64_t _internal_executable_size_in_bytes() const;
  void _internal_set_executable_size_in_bytes(int64_t value);
  public:

  // bool compilation_cache_hit = 1;
  void clear_compilation_cache_hit();
  bool compilation_cache_hit() const;
  void set_compilation_cache_hit(bool value);
  private:
  bool _internal_compilation_cache_hit() const;
  void _internal_set_compilation_cache_hit(bool value);
  public:

  // bool profile_cache_hit = 7;
  void clear_profile_cache_hit();
  bool profile_cache_hit() const;
  void set_profile_cache_hit(bool value);
  private:
  bool _internal_profile_cache_hit() const;
  void _internal_set_profile_cache_hit(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ExecutionProfile)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t compile_time_ms_;
    int64_t compute_cycle_count_;
    int64_t compute_time_ns_;
    int64_t compute_and_transfer_time_ns_;
    int64_t executable_size_in_bytes_;
    bool compilation_cache_hit_;
    bool profile_cache_hit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ExecutionHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ExecutionHandle) */ {
 public:
  inline ExecutionHandle() : ExecutionHandle(nullptr) {}
  ~ExecutionHandle() override;
  explicit PROTOBUF_CONSTEXPR ExecutionHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionHandle(const ExecutionHandle& from);
  ExecutionHandle(ExecutionHandle&& from) noexcept
    : ExecutionHandle() {
    *this = ::std::move(from);
  }

  inline ExecutionHandle& operator=(const ExecutionHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionHandle& operator=(ExecutionHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionHandle* internal_default_instance() {
    return reinterpret_cast<const ExecutionHandle*>(
               &_ExecutionHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(ExecutionHandle& a, ExecutionHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ExecutionHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ExecutionHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ExecutionHandle& from) {
    ExecutionHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ExecutionHandle";
  }
  protected:
  explicit ExecutionHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // int64 handle = 1;
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ExecutionHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class GlobalDataHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.GlobalDataHandle) */ {
 public:
  inline GlobalDataHandle() : GlobalDataHandle(nullptr) {}
  ~GlobalDataHandle() override;
  explicit PROTOBUF_CONSTEXPR GlobalDataHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GlobalDataHandle(const GlobalDataHandle& from);
  GlobalDataHandle(GlobalDataHandle&& from) noexcept
    : GlobalDataHandle() {
    *this = ::std::move(from);
  }

  inline GlobalDataHandle& operator=(const GlobalDataHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline GlobalDataHandle& operator=(GlobalDataHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GlobalDataHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const GlobalDataHandle* internal_default_instance() {
    return reinterpret_cast<const GlobalDataHandle*>(
               &_GlobalDataHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GlobalDataHandle& a, GlobalDataHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(GlobalDataHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GlobalDataHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GlobalDataHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GlobalDataHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GlobalDataHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GlobalDataHandle& from) {
    GlobalDataHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GlobalDataHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.GlobalDataHandle";
  }
  protected:
  explicit GlobalDataHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
  };
  // int64 handle = 1;
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.GlobalDataHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DeviceHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.DeviceHandle) */ {
 public:
  inline DeviceHandle() : DeviceHandle(nullptr) {}
  ~DeviceHandle() override;
  explicit PROTOBUF_CONSTEXPR DeviceHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceHandle(const DeviceHandle& from);
  DeviceHandle(DeviceHandle&& from) noexcept
    : DeviceHandle() {
    *this = ::std::move(from);
  }

  inline DeviceHandle& operator=(const DeviceHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceHandle& operator=(DeviceHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceHandle* internal_default_instance() {
    return reinterpret_cast<const DeviceHandle*>(
               &_DeviceHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeviceHandle& a, DeviceHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceHandle& from) {
    DeviceHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.DeviceHandle";
  }
  protected:
  explicit DeviceHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kDeviceCountFieldNumber = 2,
  };
  // int64 handle = 1;
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // int64 device_count = 2;
  void clear_device_count();
  int64_t device_count() const;
  void set_device_count(int64_t value);
  private:
  int64_t _internal_device_count() const;
  void _internal_set_device_count(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.DeviceHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t handle_;
    int64_t device_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ChannelHandle final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ChannelHandle) */ {
 public:
  inline ChannelHandle() : ChannelHandle(nullptr) {}
  ~ChannelHandle() override;
  explicit PROTOBUF_CONSTEXPR ChannelHandle(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ChannelHandle(const ChannelHandle& from);
  ChannelHandle(ChannelHandle&& from) noexcept
    : ChannelHandle() {
    *this = ::std::move(from);
  }

  inline ChannelHandle& operator=(const ChannelHandle& from) {
    CopyFrom(from);
    return *this;
  }
  inline ChannelHandle& operator=(ChannelHandle&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ChannelHandle& default_instance() {
    return *internal_default_instance();
  }
  static inline const ChannelHandle* internal_default_instance() {
    return reinterpret_cast<const ChannelHandle*>(
               &_ChannelHandle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(ChannelHandle& a, ChannelHandle& b) {
    a.Swap(&b);
  }
  inline void Swap(ChannelHandle* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ChannelHandle* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ChannelHandle* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ChannelHandle>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ChannelHandle& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ChannelHandle& from) {
    ChannelHandle::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ChannelHandle* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ChannelHandle";
  }
  protected:
  explicit ChannelHandle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef ChannelHandle_ChannelType ChannelType;
  static constexpr ChannelType CHANNEL_TYPE_INVALID =
    ChannelHandle_ChannelType_CHANNEL_TYPE_INVALID;
  static constexpr ChannelType DEVICE_TO_DEVICE =
    ChannelHandle_ChannelType_DEVICE_TO_DEVICE;
  static constexpr ChannelType DEVICE_TO_HOST =
    ChannelHandle_ChannelType_DEVICE_TO_HOST;
  static constexpr ChannelType HOST_TO_DEVICE =
    ChannelHandle_ChannelType_HOST_TO_DEVICE;
  static inline bool ChannelType_IsValid(int value) {
    return ChannelHandle_ChannelType_IsValid(value);
  }
  static constexpr ChannelType ChannelType_MIN =
    ChannelHandle_ChannelType_ChannelType_MIN;
  static constexpr ChannelType ChannelType_MAX =
    ChannelHandle_ChannelType_ChannelType_MAX;
  static constexpr int ChannelType_ARRAYSIZE =
    ChannelHandle_ChannelType_ChannelType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  ChannelType_descriptor() {
    return ChannelHandle_ChannelType_descriptor();
  }
  template<typename T>
  static inline const std::string& ChannelType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, ChannelType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function ChannelType_Name.");
    return ChannelHandle_ChannelType_Name(enum_t_value);
  }
  static inline bool ChannelType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      ChannelType* value) {
    return ChannelHandle_ChannelType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kHandleFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // int64 handle = 1;
  void clear_handle();
  int64_t handle() const;
  void set_handle(int64_t value);
  private:
  int64_t _internal_handle() const;
  void _internal_set_handle(int64_t value);
  public:

  // .xla.ChannelHandle.ChannelType type = 2;
  void clear_type();
  ::xla::ChannelHandle_ChannelType type() const;
  void set_type(::xla::ChannelHandle_ChannelType value);
  private:
  ::xla::ChannelHandle_ChannelType _internal_type() const;
  void _internal_set_type(::xla::ChannelHandle_ChannelType value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ChannelHandle)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t handle_;
    int type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DeviceAssignmentProto_ComputationDevice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.DeviceAssignmentProto.ComputationDevice) */ {
 public:
  inline DeviceAssignmentProto_ComputationDevice() : DeviceAssignmentProto_ComputationDevice(nullptr) {}
  ~DeviceAssignmentProto_ComputationDevice() override;
  explicit PROTOBUF_CONSTEXPR DeviceAssignmentProto_ComputationDevice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAssignmentProto_ComputationDevice(const DeviceAssignmentProto_ComputationDevice& from);
  DeviceAssignmentProto_ComputationDevice(DeviceAssignmentProto_ComputationDevice&& from) noexcept
    : DeviceAssignmentProto_ComputationDevice() {
    *this = ::std::move(from);
  }

  inline DeviceAssignmentProto_ComputationDevice& operator=(const DeviceAssignmentProto_ComputationDevice& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAssignmentProto_ComputationDevice& operator=(DeviceAssignmentProto_ComputationDevice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceAssignmentProto_ComputationDevice& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAssignmentProto_ComputationDevice* internal_default_instance() {
    return reinterpret_cast<const DeviceAssignmentProto_ComputationDevice*>(
               &_DeviceAssignmentProto_ComputationDevice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(DeviceAssignmentProto_ComputationDevice& a, DeviceAssignmentProto_ComputationDevice& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAssignmentProto_ComputationDevice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAssignmentProto_ComputationDevice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAssignmentProto_ComputationDevice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAssignmentProto_ComputationDevice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceAssignmentProto_ComputationDevice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceAssignmentProto_ComputationDevice& from) {
    DeviceAssignmentProto_ComputationDevice::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceAssignmentProto_ComputationDevice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.DeviceAssignmentProto.ComputationDevice";
  }
  protected:
  explicit DeviceAssignmentProto_ComputationDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicaDeviceIdsFieldNumber = 1,
  };
  // repeated int32 replica_device_ids = 1;
  int replica_device_ids_size() const;
  private:
  int _internal_replica_device_ids_size() const;
  public:
  void clear_replica_device_ids();
  private:
  int32_t _internal_replica_device_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_replica_device_ids() const;
  void _internal_add_replica_device_ids(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_replica_device_ids();
  public:
  int32_t replica_device_ids(int index) const;
  void set_replica_device_ids(int index, int32_t value);
  void add_replica_device_ids(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      replica_device_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_replica_device_ids();

  // @@protoc_insertion_point(class_scope:xla.DeviceAssignmentProto.ComputationDevice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > replica_device_ids_;
    mutable std::atomic<int> _replica_device_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DeviceAssignmentProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.DeviceAssignmentProto) */ {
 public:
  inline DeviceAssignmentProto() : DeviceAssignmentProto(nullptr) {}
  ~DeviceAssignmentProto() override;
  explicit PROTOBUF_CONSTEXPR DeviceAssignmentProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeviceAssignmentProto(const DeviceAssignmentProto& from);
  DeviceAssignmentProto(DeviceAssignmentProto&& from) noexcept
    : DeviceAssignmentProto() {
    *this = ::std::move(from);
  }

  inline DeviceAssignmentProto& operator=(const DeviceAssignmentProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeviceAssignmentProto& operator=(DeviceAssignmentProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeviceAssignmentProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeviceAssignmentProto* internal_default_instance() {
    return reinterpret_cast<const DeviceAssignmentProto*>(
               &_DeviceAssignmentProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(DeviceAssignmentProto& a, DeviceAssignmentProto& b) {
    a.Swap(&b);
  }
  inline void Swap(DeviceAssignmentProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeviceAssignmentProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeviceAssignmentProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeviceAssignmentProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeviceAssignmentProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeviceAssignmentProto& from) {
    DeviceAssignmentProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeviceAssignmentProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.DeviceAssignmentProto";
  }
  protected:
  explicit DeviceAssignmentProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef DeviceAssignmentProto_ComputationDevice ComputationDevice;

  // accessors -------------------------------------------------------

  enum : int {
    kComputationDevicesFieldNumber = 3,
    kReplicaCountFieldNumber = 1,
    kComputationCountFieldNumber = 2,
  };
  // repeated .xla.DeviceAssignmentProto.ComputationDevice computation_devices = 3;
  int computation_devices_size() const;
  private:
  int _internal_computation_devices_size() const;
  public:
  void clear_computation_devices();
  ::xla::DeviceAssignmentProto_ComputationDevice* mutable_computation_devices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceAssignmentProto_ComputationDevice >*
      mutable_computation_devices();
  private:
  const ::xla::DeviceAssignmentProto_ComputationDevice& _internal_computation_devices(int index) const;
  ::xla::DeviceAssignmentProto_ComputationDevice* _internal_add_computation_devices();
  public:
  const ::xla::DeviceAssignmentProto_ComputationDevice& computation_devices(int index) const;
  ::xla::DeviceAssignmentProto_ComputationDevice* add_computation_devices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceAssignmentProto_ComputationDevice >&
      computation_devices() const;

  // int32 replica_count = 1;
  void clear_replica_count();
  int32_t replica_count() const;
  void set_replica_count(int32_t value);
  private:
  int32_t _internal_replica_count() const;
  void _internal_set_replica_count(int32_t value);
  public:

  // int32 computation_count = 2;
  void clear_computation_count();
  int32_t computation_count() const;
  void set_computation_count(int32_t value);
  private:
  int32_t _internal_computation_count() const;
  void _internal_set_computation_count(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.DeviceAssignmentProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::DeviceAssignmentProto_ComputationDevice > computation_devices_;
    int32_t replica_count_;
    int32_t computation_count_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class LiteralProto final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.LiteralProto) */ {
 public:
  inline LiteralProto() : LiteralProto(nullptr) {}
  ~LiteralProto() override;
  explicit PROTOBUF_CONSTEXPR LiteralProto(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LiteralProto(const LiteralProto& from);
  LiteralProto(LiteralProto&& from) noexcept
    : LiteralProto() {
    *this = ::std::move(from);
  }

  inline LiteralProto& operator=(const LiteralProto& from) {
    CopyFrom(from);
    return *this;
  }
  inline LiteralProto& operator=(LiteralProto&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LiteralProto& default_instance() {
    return *internal_default_instance();
  }
  static inline const LiteralProto* internal_default_instance() {
    return reinterpret_cast<const LiteralProto*>(
               &_LiteralProto_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LiteralProto& a, LiteralProto& b) {
    a.Swap(&b);
  }
  inline void Swap(LiteralProto* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LiteralProto* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LiteralProto* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LiteralProto>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LiteralProto& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LiteralProto& from) {
    LiteralProto::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LiteralProto* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.LiteralProto";
  }
  protected:
  explicit LiteralProto(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPredsFieldNumber = 2,
    kS32SFieldNumber = 4,
    kS64SFieldNumber = 5,
    kU32SFieldNumber = 6,
    kU64SFieldNumber = 7,
    kF32SFieldNumber = 8,
    kF64SFieldNumber = 9,
    kTupleLiteralsFieldNumber = 10,
    kC64SFieldNumber = 12,
    kSparseIndicesFieldNumber = 14,
    kC128SFieldNumber = 18,
    kU8SFieldNumber = 3,
    kF16SFieldNumber = 11,
    kBf16SFieldNumber = 13,
    kS8SFieldNumber = 15,
    kU16SFieldNumber = 16,
    kS16SFieldNumber = 17,
    kF8E5M2SFieldNumber = 19,
    kF8E4M3FnsFieldNumber = 20,
    kShapeFieldNumber = 1,
  };
  // repeated bool preds = 2;
  int preds_size() const;
  private:
  int _internal_preds_size() const;
  public:
  void clear_preds();
  private:
  bool _internal_preds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_preds() const;
  void _internal_add_preds(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_preds();
  public:
  bool preds(int index) const;
  void set_preds(int index, bool value);
  void add_preds(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      preds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_preds();

  // repeated int32 s32s = 4;
  int s32s_size() const;
  private:
  int _internal_s32s_size() const;
  public:
  void clear_s32s();
  private:
  int32_t _internal_s32s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_s32s() const;
  void _internal_add_s32s(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_s32s();
  public:
  int32_t s32s(int index) const;
  void set_s32s(int index, int32_t value);
  void add_s32s(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      s32s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_s32s();

  // repeated int64 s64s = 5;
  int s64s_size() const;
  private:
  int _internal_s64s_size() const;
  public:
  void clear_s64s();
  private:
  int64_t _internal_s64s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_s64s() const;
  void _internal_add_s64s(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_s64s();
  public:
  int64_t s64s(int index) const;
  void set_s64s(int index, int64_t value);
  void add_s64s(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      s64s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_s64s();

  // repeated uint32 u32s = 6;
  int u32s_size() const;
  private:
  int _internal_u32s_size() const;
  public:
  void clear_u32s();
  private:
  uint32_t _internal_u32s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_u32s() const;
  void _internal_add_u32s(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_u32s();
  public:
  uint32_t u32s(int index) const;
  void set_u32s(int index, uint32_t value);
  void add_u32s(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      u32s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_u32s();

  // repeated uint64 u64s = 7;
  int u64s_size() const;
  private:
  int _internal_u64s_size() const;
  public:
  void clear_u64s();
  private:
  uint64_t _internal_u64s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_u64s() const;
  void _internal_add_u64s(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_u64s();
  public:
  uint64_t u64s(int index) const;
  void set_u64s(int index, uint64_t value);
  void add_u64s(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      u64s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_u64s();

  // repeated float f32s = 8;
  int f32s_size() const;
  private:
  int _internal_f32s_size() const;
  public:
  void clear_f32s();
  private:
  float _internal_f32s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_f32s() const;
  void _internal_add_f32s(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_f32s();
  public:
  float f32s(int index) const;
  void set_f32s(int index, float value);
  void add_f32s(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      f32s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_f32s();

  // repeated double f64s = 9;
  int f64s_size() const;
  private:
  int _internal_f64s_size() const;
  public:
  void clear_f64s();
  private:
  double _internal_f64s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_f64s() const;
  void _internal_add_f64s(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_f64s();
  public:
  double f64s(int index) const;
  void set_f64s(int index, double value);
  void add_f64s(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      f64s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_f64s();

  // repeated .xla.LiteralProto tuple_literals = 10;
  int tuple_literals_size() const;
  private:
  int _internal_tuple_literals_size() const;
  public:
  void clear_tuple_literals();
  ::xla::LiteralProto* mutable_tuple_literals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LiteralProto >*
      mutable_tuple_literals();
  private:
  const ::xla::LiteralProto& _internal_tuple_literals(int index) const;
  ::xla::LiteralProto* _internal_add_tuple_literals();
  public:
  const ::xla::LiteralProto& tuple_literals(int index) const;
  ::xla::LiteralProto* add_tuple_literals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LiteralProto >&
      tuple_literals() const;

  // repeated float c64s = 12;
  int c64s_size() const;
  private:
  int _internal_c64s_size() const;
  public:
  void clear_c64s();
  private:
  float _internal_c64s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_c64s() const;
  void _internal_add_c64s(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_c64s();
  public:
  float c64s(int index) const;
  void set_c64s(int index, float value);
  void add_c64s(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      c64s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_c64s();

  // repeated int64 sparse_indices = 14;
  int sparse_indices_size() const;
  private:
  int _internal_sparse_indices_size() const;
  public:
  void clear_sparse_indices();
  private:
  int64_t _internal_sparse_indices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_sparse_indices() const;
  void _internal_add_sparse_indices(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_sparse_indices();
  public:
  int64_t sparse_indices(int index) const;
  void set_sparse_indices(int index, int64_t value);
  void add_sparse_indices(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      sparse_indices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_sparse_indices();

  // repeated double c128s = 18;
  int c128s_size() const;
  private:
  int _internal_c128s_size() const;
  public:
  void clear_c128s();
  private:
  double _internal_c128s(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      _internal_c128s() const;
  void _internal_add_c128s(double value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      _internal_mutable_c128s();
  public:
  double c128s(int index) const;
  void set_c128s(int index, double value);
  void add_c128s(double value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >&
      c128s() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< double >*
      mutable_c128s();

  // bytes u8s = 3;
  void clear_u8s();
  const std::string& u8s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u8s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u8s();
  PROTOBUF_NODISCARD std::string* release_u8s();
  void set_allocated_u8s(std::string* u8s);
  private:
  const std::string& _internal_u8s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u8s(const std::string& value);
  std::string* _internal_mutable_u8s();
  public:

  // bytes f16s = 11;
  void clear_f16s();
  const std::string& f16s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f16s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f16s();
  PROTOBUF_NODISCARD std::string* release_f16s();
  void set_allocated_f16s(std::string* f16s);
  private:
  const std::string& _internal_f16s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f16s(const std::string& value);
  std::string* _internal_mutable_f16s();
  public:

  // bytes bf16s = 13;
  void clear_bf16s();
  const std::string& bf16s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_bf16s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_bf16s();
  PROTOBUF_NODISCARD std::string* release_bf16s();
  void set_allocated_bf16s(std::string* bf16s);
  private:
  const std::string& _internal_bf16s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_bf16s(const std::string& value);
  std::string* _internal_mutable_bf16s();
  public:

  // bytes s8s = 15;
  void clear_s8s();
  const std::string& s8s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s8s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s8s();
  PROTOBUF_NODISCARD std::string* release_s8s();
  void set_allocated_s8s(std::string* s8s);
  private:
  const std::string& _internal_s8s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s8s(const std::string& value);
  std::string* _internal_mutable_s8s();
  public:

  // bytes u16s = 16;
  void clear_u16s();
  const std::string& u16s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_u16s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_u16s();
  PROTOBUF_NODISCARD std::string* release_u16s();
  void set_allocated_u16s(std::string* u16s);
  private:
  const std::string& _internal_u16s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_u16s(const std::string& value);
  std::string* _internal_mutable_u16s();
  public:

  // bytes s16s = 17;
  void clear_s16s();
  const std::string& s16s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s16s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s16s();
  PROTOBUF_NODISCARD std::string* release_s16s();
  void set_allocated_s16s(std::string* s16s);
  private:
  const std::string& _internal_s16s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s16s(const std::string& value);
  std::string* _internal_mutable_s16s();
  public:

  // bytes f8e5m2s = 19;
  void clear_f8e5m2s();
  const std::string& f8e5m2s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f8e5m2s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f8e5m2s();
  PROTOBUF_NODISCARD std::string* release_f8e5m2s();
  void set_allocated_f8e5m2s(std::string* f8e5m2s);
  private:
  const std::string& _internal_f8e5m2s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f8e5m2s(const std::string& value);
  std::string* _internal_mutable_f8e5m2s();
  public:

  // bytes f8e4m3fns = 20;
  void clear_f8e4m3fns();
  const std::string& f8e4m3fns() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_f8e4m3fns(ArgT0&& arg0, ArgT... args);
  std::string* mutable_f8e4m3fns();
  PROTOBUF_NODISCARD std::string* release_f8e4m3fns();
  void set_allocated_f8e4m3fns(std::string* f8e4m3fns);
  private:
  const std::string& _internal_f8e4m3fns() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_f8e4m3fns(const std::string& value);
  std::string* _internal_mutable_f8e4m3fns();
  public:

  // .xla.ShapeProto shape = 1;
  bool has_shape() const;
  private:
  bool _internal_has_shape() const;
  public:
  void clear_shape();
  const ::xla::ShapeProto& shape() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_shape();
  ::xla::ShapeProto* mutable_shape();
  void set_allocated_shape(::xla::ShapeProto* shape);
  private:
  const ::xla::ShapeProto& _internal_shape() const;
  ::xla::ShapeProto* _internal_mutable_shape();
  public:
  void unsafe_arena_set_allocated_shape(
      ::xla::ShapeProto* shape);
  ::xla::ShapeProto* unsafe_arena_release_shape();

  // @@protoc_insertion_point(class_scope:xla.LiteralProto)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > preds_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > s32s_;
    mutable std::atomic<int> _s32s_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > s64s_;
    mutable std::atomic<int> _s64s_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > u32s_;
    mutable std::atomic<int> _u32s_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > u64s_;
    mutable std::atomic<int> _u64s_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > f32s_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > f64s_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::LiteralProto > tuple_literals_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > c64s_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > sparse_indices_;
    mutable std::atomic<int> _sparse_indices_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< double > c128s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u8s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f16s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr bf16s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s8s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr u16s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s16s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f8e5m2s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr f8e4m3fns_;
    ::xla::ShapeProto* shape_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class WindowDimension final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.WindowDimension) */ {
 public:
  inline WindowDimension() : WindowDimension(nullptr) {}
  ~WindowDimension() override;
  explicit PROTOBUF_CONSTEXPR WindowDimension(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WindowDimension(const WindowDimension& from);
  WindowDimension(WindowDimension&& from) noexcept
    : WindowDimension() {
    *this = ::std::move(from);
  }

  inline WindowDimension& operator=(const WindowDimension& from) {
    CopyFrom(from);
    return *this;
  }
  inline WindowDimension& operator=(WindowDimension&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WindowDimension& default_instance() {
    return *internal_default_instance();
  }
  static inline const WindowDimension* internal_default_instance() {
    return reinterpret_cast<const WindowDimension*>(
               &_WindowDimension_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WindowDimension& a, WindowDimension& b) {
    a.Swap(&b);
  }
  inline void Swap(WindowDimension* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WindowDimension* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WindowDimension* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WindowDimension>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WindowDimension& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WindowDimension& from) {
    WindowDimension::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WindowDimension* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.WindowDimension";
  }
  protected:
  explicit WindowDimension(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kStrideFieldNumber = 2,
    kPaddingLowFieldNumber = 3,
    kPaddingHighFieldNumber = 4,
    kWindowDilationFieldNumber = 5,
    kBaseDilationFieldNumber = 6,
    kWindowReversalFieldNumber = 7,
  };
  // int64 size = 1;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // int64 stride = 2;
  void clear_stride();
  int64_t stride() const;
  void set_stride(int64_t value);
  private:
  int64_t _internal_stride() const;
  void _internal_set_stride(int64_t value);
  public:

  // int64 padding_low = 3;
  void clear_padding_low();
  int64_t padding_low() const;
  void set_padding_low(int64_t value);
  private:
  int64_t _internal_padding_low() const;
  void _internal_set_padding_low(int64_t value);
  public:

  // int64 padding_high = 4;
  void clear_padding_high();
  int64_t padding_high() const;
  void set_padding_high(int64_t value);
  private:
  int64_t _internal_padding_high() const;
  void _internal_set_padding_high(int64_t value);
  public:

  // int64 window_dilation = 5;
  void clear_window_dilation();
  int64_t window_dilation() const;
  void set_window_dilation(int64_t value);
  private:
  int64_t _internal_window_dilation() const;
  void _internal_set_window_dilation(int64_t value);
  public:

  // int64 base_dilation = 6;
  void clear_base_dilation();
  int64_t base_dilation() const;
  void set_base_dilation(int64_t value);
  private:
  int64_t _internal_base_dilation() const;
  void _internal_set_base_dilation(int64_t value);
  public:

  // bool window_reversal = 7;
  void clear_window_reversal();
  bool window_reversal() const;
  void set_window_reversal(bool value);
  private:
  bool _internal_window_reversal() const;
  void _internal_set_window_reversal(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xla.WindowDimension)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t size_;
    int64_t stride_;
    int64_t padding_low_;
    int64_t padding_high_;
    int64_t window_dilation_;
    int64_t base_dilation_;
    bool window_reversal_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class Window final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.Window) */ {
 public:
  inline Window() : Window(nullptr) {}
  ~Window() override;
  explicit PROTOBUF_CONSTEXPR Window(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Window(const Window& from);
  Window(Window&& from) noexcept
    : Window() {
    *this = ::std::move(from);
  }

  inline Window& operator=(const Window& from) {
    CopyFrom(from);
    return *this;
  }
  inline Window& operator=(Window&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Window& default_instance() {
    return *internal_default_instance();
  }
  static inline const Window* internal_default_instance() {
    return reinterpret_cast<const Window*>(
               &_Window_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(Window& a, Window& b) {
    a.Swap(&b);
  }
  inline void Swap(Window* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Window* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Window* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Window>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Window& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Window& from) {
    Window::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Window* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.Window";
  }
  protected:
  explicit Window(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimensionsFieldNumber = 1,
  };
  // repeated .xla.WindowDimension dimensions = 1;
  int dimensions_size() const;
  private:
  int _internal_dimensions_size() const;
  public:
  void clear_dimensions();
  ::xla::WindowDimension* mutable_dimensions(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::WindowDimension >*
      mutable_dimensions();
  private:
  const ::xla::WindowDimension& _internal_dimensions(int index) const;
  ::xla::WindowDimension* _internal_add_dimensions();
  public:
  const ::xla::WindowDimension& dimensions(int index) const;
  ::xla::WindowDimension* add_dimensions();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::WindowDimension >&
      dimensions() const;

  // @@protoc_insertion_point(class_scope:xla.Window)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::WindowDimension > dimensions_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class GatherDimensionNumbers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.GatherDimensionNumbers) */ {
 public:
  inline GatherDimensionNumbers() : GatherDimensionNumbers(nullptr) {}
  ~GatherDimensionNumbers() override;
  explicit PROTOBUF_CONSTEXPR GatherDimensionNumbers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GatherDimensionNumbers(const GatherDimensionNumbers& from);
  GatherDimensionNumbers(GatherDimensionNumbers&& from) noexcept
    : GatherDimensionNumbers() {
    *this = ::std::move(from);
  }

  inline GatherDimensionNumbers& operator=(const GatherDimensionNumbers& from) {
    CopyFrom(from);
    return *this;
  }
  inline GatherDimensionNumbers& operator=(GatherDimensionNumbers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GatherDimensionNumbers& default_instance() {
    return *internal_default_instance();
  }
  static inline const GatherDimensionNumbers* internal_default_instance() {
    return reinterpret_cast<const GatherDimensionNumbers*>(
               &_GatherDimensionNumbers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GatherDimensionNumbers& a, GatherDimensionNumbers& b) {
    a.Swap(&b);
  }
  inline void Swap(GatherDimensionNumbers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GatherDimensionNumbers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GatherDimensionNumbers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GatherDimensionNumbers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GatherDimensionNumbers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GatherDimensionNumbers& from) {
    GatherDimensionNumbers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GatherDimensionNumbers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.GatherDimensionNumbers";
  }
  protected:
  explicit GatherDimensionNumbers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOffsetDimsFieldNumber = 1,
    kCollapsedSliceDimsFieldNumber = 2,
    kStartIndexMapFieldNumber = 3,
    kIndexVectorDimFieldNumber = 4,
  };
  // repeated int64 offset_dims = 1;
  int offset_dims_size() const;
  private:
  int _internal_offset_dims_size() const;
  public:
  void clear_offset_dims();
  private:
  int64_t _internal_offset_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_offset_dims() const;
  void _internal_add_offset_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_offset_dims();
  public:
  int64_t offset_dims(int index) const;
  void set_offset_dims(int index, int64_t value);
  void add_offset_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      offset_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_offset_dims();

  // repeated int64 collapsed_slice_dims = 2;
  int collapsed_slice_dims_size() const;
  private:
  int _internal_collapsed_slice_dims_size() const;
  public:
  void clear_collapsed_slice_dims();
  private:
  int64_t _internal_collapsed_slice_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_collapsed_slice_dims() const;
  void _internal_add_collapsed_slice_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_collapsed_slice_dims();
  public:
  int64_t collapsed_slice_dims(int index) const;
  void set_collapsed_slice_dims(int index, int64_t value);
  void add_collapsed_slice_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      collapsed_slice_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_collapsed_slice_dims();

  // repeated int64 start_index_map = 3;
  int start_index_map_size() const;
  private:
  int _internal_start_index_map_size() const;
  public:
  void clear_start_index_map();
  private:
  int64_t _internal_start_index_map(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_start_index_map() const;
  void _internal_add_start_index_map(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_start_index_map();
  public:
  int64_t start_index_map(int index) const;
  void set_start_index_map(int index, int64_t value);
  void add_start_index_map(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      start_index_map() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_start_index_map();

  // int64 index_vector_dim = 4;
  void clear_index_vector_dim();
  int64_t index_vector_dim() const;
  void set_index_vector_dim(int64_t value);
  private:
  int64_t _internal_index_vector_dim() const;
  void _internal_set_index_vector_dim(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.GatherDimensionNumbers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > offset_dims_;
    mutable std::atomic<int> _offset_dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > collapsed_slice_dims_;
    mutable std::atomic<int> _collapsed_slice_dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > start_index_map_;
    mutable std::atomic<int> _start_index_map_cached_byte_size_;
    int64_t index_vector_dim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ScatterDimensionNumbers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ScatterDimensionNumbers) */ {
 public:
  inline ScatterDimensionNumbers() : ScatterDimensionNumbers(nullptr) {}
  ~ScatterDimensionNumbers() override;
  explicit PROTOBUF_CONSTEXPR ScatterDimensionNumbers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ScatterDimensionNumbers(const ScatterDimensionNumbers& from);
  ScatterDimensionNumbers(ScatterDimensionNumbers&& from) noexcept
    : ScatterDimensionNumbers() {
    *this = ::std::move(from);
  }

  inline ScatterDimensionNumbers& operator=(const ScatterDimensionNumbers& from) {
    CopyFrom(from);
    return *this;
  }
  inline ScatterDimensionNumbers& operator=(ScatterDimensionNumbers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ScatterDimensionNumbers& default_instance() {
    return *internal_default_instance();
  }
  static inline const ScatterDimensionNumbers* internal_default_instance() {
    return reinterpret_cast<const ScatterDimensionNumbers*>(
               &_ScatterDimensionNumbers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ScatterDimensionNumbers& a, ScatterDimensionNumbers& b) {
    a.Swap(&b);
  }
  inline void Swap(ScatterDimensionNumbers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ScatterDimensionNumbers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ScatterDimensionNumbers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ScatterDimensionNumbers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ScatterDimensionNumbers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ScatterDimensionNumbers& from) {
    ScatterDimensionNumbers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ScatterDimensionNumbers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ScatterDimensionNumbers";
  }
  protected:
  explicit ScatterDimensionNumbers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUpdateWindowDimsFieldNumber = 1,
    kInsertedWindowDimsFieldNumber = 2,
    kScatterDimsToOperandDimsFieldNumber = 3,
    kIndexVectorDimFieldNumber = 4,
  };
  // repeated int64 update_window_dims = 1;
  int update_window_dims_size() const;
  private:
  int _internal_update_window_dims_size() const;
  public:
  void clear_update_window_dims();
  private:
  int64_t _internal_update_window_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_update_window_dims() const;
  void _internal_add_update_window_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_update_window_dims();
  public:
  int64_t update_window_dims(int index) const;
  void set_update_window_dims(int index, int64_t value);
  void add_update_window_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      update_window_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_update_window_dims();

  // repeated int64 inserted_window_dims = 2;
  int inserted_window_dims_size() const;
  private:
  int _internal_inserted_window_dims_size() const;
  public:
  void clear_inserted_window_dims();
  private:
  int64_t _internal_inserted_window_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_inserted_window_dims() const;
  void _internal_add_inserted_window_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_inserted_window_dims();
  public:
  int64_t inserted_window_dims(int index) const;
  void set_inserted_window_dims(int index, int64_t value);
  void add_inserted_window_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      inserted_window_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_inserted_window_dims();

  // repeated int64 scatter_dims_to_operand_dims = 3;
  int scatter_dims_to_operand_dims_size() const;
  private:
  int _internal_scatter_dims_to_operand_dims_size() const;
  public:
  void clear_scatter_dims_to_operand_dims();
  private:
  int64_t _internal_scatter_dims_to_operand_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_scatter_dims_to_operand_dims() const;
  void _internal_add_scatter_dims_to_operand_dims(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_scatter_dims_to_operand_dims();
  public:
  int64_t scatter_dims_to_operand_dims(int index) const;
  void set_scatter_dims_to_operand_dims(int index, int64_t value);
  void add_scatter_dims_to_operand_dims(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      scatter_dims_to_operand_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_scatter_dims_to_operand_dims();

  // int64 index_vector_dim = 4;
  void clear_index_vector_dim();
  int64_t index_vector_dim() const;
  void set_index_vector_dim(int64_t value);
  private:
  int64_t _internal_index_vector_dim() const;
  void _internal_set_index_vector_dim(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ScatterDimensionNumbers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > update_window_dims_;
    mutable std::atomic<int> _update_window_dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > inserted_window_dims_;
    mutable std::atomic<int> _inserted_window_dims_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > scatter_dims_to_operand_dims_;
    mutable std::atomic<int> _scatter_dims_to_operand_dims_cached_byte_size_;
    int64_t index_vector_dim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ConvolutionDimensionNumbers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ConvolutionDimensionNumbers) */ {
 public:
  inline ConvolutionDimensionNumbers() : ConvolutionDimensionNumbers(nullptr) {}
  ~ConvolutionDimensionNumbers() override;
  explicit PROTOBUF_CONSTEXPR ConvolutionDimensionNumbers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ConvolutionDimensionNumbers(const ConvolutionDimensionNumbers& from);
  ConvolutionDimensionNumbers(ConvolutionDimensionNumbers&& from) noexcept
    : ConvolutionDimensionNumbers() {
    *this = ::std::move(from);
  }

  inline ConvolutionDimensionNumbers& operator=(const ConvolutionDimensionNumbers& from) {
    CopyFrom(from);
    return *this;
  }
  inline ConvolutionDimensionNumbers& operator=(ConvolutionDimensionNumbers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ConvolutionDimensionNumbers& default_instance() {
    return *internal_default_instance();
  }
  static inline const ConvolutionDimensionNumbers* internal_default_instance() {
    return reinterpret_cast<const ConvolutionDimensionNumbers*>(
               &_ConvolutionDimensionNumbers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ConvolutionDimensionNumbers& a, ConvolutionDimensionNumbers& b) {
    a.Swap(&b);
  }
  inline void Swap(ConvolutionDimensionNumbers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ConvolutionDimensionNumbers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ConvolutionDimensionNumbers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ConvolutionDimensionNumbers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ConvolutionDimensionNumbers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ConvolutionDimensionNumbers& from) {
    ConvolutionDimensionNumbers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ConvolutionDimensionNumbers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ConvolutionDimensionNumbers";
  }
  protected:
  explicit ConvolutionDimensionNumbers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKernelSpatialDimensionsFieldNumber = 6,
    kInputSpatialDimensionsFieldNumber = 11,
    kOutputSpatialDimensionsFieldNumber = 12,
    kKernelInputFeatureDimensionFieldNumber = 3,
    kKernelOutputFeatureDimensionFieldNumber = 4,
    kInputBatchDimensionFieldNumber = 7,
    kInputFeatureDimensionFieldNumber = 8,
    kOutputBatchDimensionFieldNumber = 9,
    kOutputFeatureDimensionFieldNumber = 10,
  };
  // repeated int64 kernel_spatial_dimensions = 6;
  int kernel_spatial_dimensions_size() const;
  private:
  int _internal_kernel_spatial_dimensions_size() const;
  public:
  void clear_kernel_spatial_dimensions();
  private:
  int64_t _internal_kernel_spatial_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_kernel_spatial_dimensions() const;
  void _internal_add_kernel_spatial_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_kernel_spatial_dimensions();
  public:
  int64_t kernel_spatial_dimensions(int index) const;
  void set_kernel_spatial_dimensions(int index, int64_t value);
  void add_kernel_spatial_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      kernel_spatial_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_kernel_spatial_dimensions();

  // repeated int64 input_spatial_dimensions = 11;
  int input_spatial_dimensions_size() const;
  private:
  int _internal_input_spatial_dimensions_size() const;
  public:
  void clear_input_spatial_dimensions();
  private:
  int64_t _internal_input_spatial_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_input_spatial_dimensions() const;
  void _internal_add_input_spatial_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_input_spatial_dimensions();
  public:
  int64_t input_spatial_dimensions(int index) const;
  void set_input_spatial_dimensions(int index, int64_t value);
  void add_input_spatial_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      input_spatial_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_input_spatial_dimensions();

  // repeated int64 output_spatial_dimensions = 12;
  int output_spatial_dimensions_size() const;
  private:
  int _internal_output_spatial_dimensions_size() const;
  public:
  void clear_output_spatial_dimensions();
  private:
  int64_t _internal_output_spatial_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_output_spatial_dimensions() const;
  void _internal_add_output_spatial_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_output_spatial_dimensions();
  public:
  int64_t output_spatial_dimensions(int index) const;
  void set_output_spatial_dimensions(int index, int64_t value);
  void add_output_spatial_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      output_spatial_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_output_spatial_dimensions();

  // int64 kernel_input_feature_dimension = 3;
  void clear_kernel_input_feature_dimension();
  int64_t kernel_input_feature_dimension() const;
  void set_kernel_input_feature_dimension(int64_t value);
  private:
  int64_t _internal_kernel_input_feature_dimension() const;
  void _internal_set_kernel_input_feature_dimension(int64_t value);
  public:

  // int64 kernel_output_feature_dimension = 4;
  void clear_kernel_output_feature_dimension();
  int64_t kernel_output_feature_dimension() const;
  void set_kernel_output_feature_dimension(int64_t value);
  private:
  int64_t _internal_kernel_output_feature_dimension() const;
  void _internal_set_kernel_output_feature_dimension(int64_t value);
  public:

  // int64 input_batch_dimension = 7;
  void clear_input_batch_dimension();
  int64_t input_batch_dimension() const;
  void set_input_batch_dimension(int64_t value);
  private:
  int64_t _internal_input_batch_dimension() const;
  void _internal_set_input_batch_dimension(int64_t value);
  public:

  // int64 input_feature_dimension = 8;
  void clear_input_feature_dimension();
  int64_t input_feature_dimension() const;
  void set_input_feature_dimension(int64_t value);
  private:
  int64_t _internal_input_feature_dimension() const;
  void _internal_set_input_feature_dimension(int64_t value);
  public:

  // int64 output_batch_dimension = 9;
  void clear_output_batch_dimension();
  int64_t output_batch_dimension() const;
  void set_output_batch_dimension(int64_t value);
  private:
  int64_t _internal_output_batch_dimension() const;
  void _internal_set_output_batch_dimension(int64_t value);
  public:

  // int64 output_feature_dimension = 10;
  void clear_output_feature_dimension();
  int64_t output_feature_dimension() const;
  void set_output_feature_dimension(int64_t value);
  private:
  int64_t _internal_output_feature_dimension() const;
  void _internal_set_output_feature_dimension(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.ConvolutionDimensionNumbers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > kernel_spatial_dimensions_;
    mutable std::atomic<int> _kernel_spatial_dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > input_spatial_dimensions_;
    mutable std::atomic<int> _input_spatial_dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > output_spatial_dimensions_;
    mutable std::atomic<int> _output_spatial_dimensions_cached_byte_size_;
    int64_t kernel_input_feature_dimension_;
    int64_t kernel_output_feature_dimension_;
    int64_t input_batch_dimension_;
    int64_t input_feature_dimension_;
    int64_t output_batch_dimension_;
    int64_t output_feature_dimension_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class DotDimensionNumbers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.DotDimensionNumbers) */ {
 public:
  inline DotDimensionNumbers() : DotDimensionNumbers(nullptr) {}
  ~DotDimensionNumbers() override;
  explicit PROTOBUF_CONSTEXPR DotDimensionNumbers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DotDimensionNumbers(const DotDimensionNumbers& from);
  DotDimensionNumbers(DotDimensionNumbers&& from) noexcept
    : DotDimensionNumbers() {
    *this = ::std::move(from);
  }

  inline DotDimensionNumbers& operator=(const DotDimensionNumbers& from) {
    CopyFrom(from);
    return *this;
  }
  inline DotDimensionNumbers& operator=(DotDimensionNumbers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DotDimensionNumbers& default_instance() {
    return *internal_default_instance();
  }
  static inline const DotDimensionNumbers* internal_default_instance() {
    return reinterpret_cast<const DotDimensionNumbers*>(
               &_DotDimensionNumbers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DotDimensionNumbers& a, DotDimensionNumbers& b) {
    a.Swap(&b);
  }
  inline void Swap(DotDimensionNumbers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DotDimensionNumbers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DotDimensionNumbers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DotDimensionNumbers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DotDimensionNumbers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DotDimensionNumbers& from) {
    DotDimensionNumbers::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DotDimensionNumbers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.DotDimensionNumbers";
  }
  protected:
  explicit DotDimensionNumbers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLhsContractingDimensionsFieldNumber = 1,
    kRhsContractingDimensionsFieldNumber = 2,
    kLhsBatchDimensionsFieldNumber = 3,
    kRhsBatchDimensionsFieldNumber = 4,
  };
  // repeated int64 lhs_contracting_dimensions = 1;
  int lhs_contracting_dimensions_size() const;
  private:
  int _internal_lhs_contracting_dimensions_size() const;
  public:
  void clear_lhs_contracting_dimensions();
  private:
  int64_t _internal_lhs_contracting_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_lhs_contracting_dimensions() const;
  void _internal_add_lhs_contracting_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_lhs_contracting_dimensions();
  public:
  int64_t lhs_contracting_dimensions(int index) const;
  void set_lhs_contracting_dimensions(int index, int64_t value);
  void add_lhs_contracting_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      lhs_contracting_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_lhs_contracting_dimensions();

  // repeated int64 rhs_contracting_dimensions = 2;
  int rhs_contracting_dimensions_size() const;
  private:
  int _internal_rhs_contracting_dimensions_size() const;
  public:
  void clear_rhs_contracting_dimensions();
  private:
  int64_t _internal_rhs_contracting_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_rhs_contracting_dimensions() const;
  void _internal_add_rhs_contracting_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_rhs_contracting_dimensions();
  public:
  int64_t rhs_contracting_dimensions(int index) const;
  void set_rhs_contracting_dimensions(int index, int64_t value);
  void add_rhs_contracting_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      rhs_contracting_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_rhs_contracting_dimensions();

  // repeated int64 lhs_batch_dimensions = 3;
  int lhs_batch_dimensions_size() const;
  private:
  int _internal_lhs_batch_dimensions_size() const;
  public:
  void clear_lhs_batch_dimensions();
  private:
  int64_t _internal_lhs_batch_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_lhs_batch_dimensions() const;
  void _internal_add_lhs_batch_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_lhs_batch_dimensions();
  public:
  int64_t lhs_batch_dimensions(int index) const;
  void set_lhs_batch_dimensions(int index, int64_t value);
  void add_lhs_batch_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      lhs_batch_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_lhs_batch_dimensions();

  // repeated int64 rhs_batch_dimensions = 4;
  int rhs_batch_dimensions_size() const;
  private:
  int _internal_rhs_batch_dimensions_size() const;
  public:
  void clear_rhs_batch_dimensions();
  private:
  int64_t _internal_rhs_batch_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_rhs_batch_dimensions() const;
  void _internal_add_rhs_batch_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_rhs_batch_dimensions();
  public:
  int64_t rhs_batch_dimensions(int index) const;
  void set_rhs_batch_dimensions(int index, int64_t value);
  void add_rhs_batch_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      rhs_batch_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_rhs_batch_dimensions();

  // @@protoc_insertion_point(class_scope:xla.DotDimensionNumbers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > lhs_contracting_dimensions_;
    mutable std::atomic<int> _lhs_contracting_dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > rhs_contracting_dimensions_;
    mutable std::atomic<int> _rhs_contracting_dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > lhs_batch_dimensions_;
    mutable std::atomic<int> _lhs_batch_dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > rhs_batch_dimensions_;
    mutable std::atomic<int> _rhs_batch_dimensions_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class TriangularSolveOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.TriangularSolveOptions) */ {
 public:
  inline TriangularSolveOptions() : TriangularSolveOptions(nullptr) {}
  ~TriangularSolveOptions() override;
  explicit PROTOBUF_CONSTEXPR TriangularSolveOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TriangularSolveOptions(const TriangularSolveOptions& from);
  TriangularSolveOptions(TriangularSolveOptions&& from) noexcept
    : TriangularSolveOptions() {
    *this = ::std::move(from);
  }

  inline TriangularSolveOptions& operator=(const TriangularSolveOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline TriangularSolveOptions& operator=(TriangularSolveOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TriangularSolveOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const TriangularSolveOptions* internal_default_instance() {
    return reinterpret_cast<const TriangularSolveOptions*>(
               &_TriangularSolveOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(TriangularSolveOptions& a, TriangularSolveOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(TriangularSolveOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TriangularSolveOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TriangularSolveOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TriangularSolveOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TriangularSolveOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const TriangularSolveOptions& from) {
    TriangularSolveOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TriangularSolveOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.TriangularSolveOptions";
  }
  protected:
  explicit TriangularSolveOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef TriangularSolveOptions_Transpose Transpose;
  static constexpr Transpose TRANSPOSE_INVALID =
    TriangularSolveOptions_Transpose_TRANSPOSE_INVALID;
  static constexpr Transpose NO_TRANSPOSE =
    TriangularSolveOptions_Transpose_NO_TRANSPOSE;
  static constexpr Transpose TRANSPOSE =
    TriangularSolveOptions_Transpose_TRANSPOSE;
  static constexpr Transpose ADJOINT =
    TriangularSolveOptions_Transpose_ADJOINT;
  static inline bool Transpose_IsValid(int value) {
    return TriangularSolveOptions_Transpose_IsValid(value);
  }
  static constexpr Transpose Transpose_MIN =
    TriangularSolveOptions_Transpose_Transpose_MIN;
  static constexpr Transpose Transpose_MAX =
    TriangularSolveOptions_Transpose_Transpose_MAX;
  static constexpr int Transpose_ARRAYSIZE =
    TriangularSolveOptions_Transpose_Transpose_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Transpose_descriptor() {
    return TriangularSolveOptions_Transpose_descriptor();
  }
  template<typename T>
  static inline const std::string& Transpose_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Transpose>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Transpose_Name.");
    return TriangularSolveOptions_Transpose_Name(enum_t_value);
  }
  static inline bool Transpose_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Transpose* value) {
    return TriangularSolveOptions_Transpose_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kLeftSideFieldNumber = 1,
    kLowerFieldNumber = 2,
    kUnitDiagonalFieldNumber = 3,
    kTransposeAFieldNumber = 4,
  };
  // bool left_side = 1;
  void clear_left_side();
  bool left_side() const;
  void set_left_side(bool value);
  private:
  bool _internal_left_side() const;
  void _internal_set_left_side(bool value);
  public:

  // bool lower = 2;
  void clear_lower();
  bool lower() const;
  void set_lower(bool value);
  private:
  bool _internal_lower() const;
  void _internal_set_lower(bool value);
  public:

  // bool unit_diagonal = 3;
  void clear_unit_diagonal();
  bool unit_diagonal() const;
  void set_unit_diagonal(bool value);
  private:
  bool _internal_unit_diagonal() const;
  void _internal_set_unit_diagonal(bool value);
  public:

  // .xla.TriangularSolveOptions.Transpose transpose_a = 4;
  void clear_transpose_a();
  ::xla::TriangularSolveOptions_Transpose transpose_a() const;
  void set_transpose_a(::xla::TriangularSolveOptions_Transpose value);
  private:
  ::xla::TriangularSolveOptions_Transpose _internal_transpose_a() const;
  void _internal_set_transpose_a(::xla::TriangularSolveOptions_Transpose value);
  public:

  // @@protoc_insertion_point(class_scope:xla.TriangularSolveOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool left_side_;
    bool lower_;
    bool unit_diagonal_;
    int transpose_a_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class CholeskyOptions final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.CholeskyOptions) */ {
 public:
  inline CholeskyOptions() : CholeskyOptions(nullptr) {}
  ~CholeskyOptions() override;
  explicit PROTOBUF_CONSTEXPR CholeskyOptions(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CholeskyOptions(const CholeskyOptions& from);
  CholeskyOptions(CholeskyOptions&& from) noexcept
    : CholeskyOptions() {
    *this = ::std::move(from);
  }

  inline CholeskyOptions& operator=(const CholeskyOptions& from) {
    CopyFrom(from);
    return *this;
  }
  inline CholeskyOptions& operator=(CholeskyOptions&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CholeskyOptions& default_instance() {
    return *internal_default_instance();
  }
  static inline const CholeskyOptions* internal_default_instance() {
    return reinterpret_cast<const CholeskyOptions*>(
               &_CholeskyOptions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CholeskyOptions& a, CholeskyOptions& b) {
    a.Swap(&b);
  }
  inline void Swap(CholeskyOptions* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CholeskyOptions* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CholeskyOptions* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CholeskyOptions>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CholeskyOptions& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CholeskyOptions& from) {
    CholeskyOptions::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CholeskyOptions* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.CholeskyOptions";
  }
  protected:
  explicit CholeskyOptions(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLowerFieldNumber = 1,
  };
  // bool lower = 1;
  void clear_lower();
  bool lower() const;
  void set_lower(bool value);
  private:
  bool _internal_lower() const;
  void _internal_set_lower(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xla.CholeskyOptions)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool lower_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class FrontendAttributes_MapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrontendAttributes_MapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<FrontendAttributes_MapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> SuperType;
  FrontendAttributes_MapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR FrontendAttributes_MapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit FrontendAttributes_MapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const FrontendAttributes_MapEntry_DoNotUse& other);
  static const FrontendAttributes_MapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const FrontendAttributes_MapEntry_DoNotUse*>(&_FrontendAttributes_MapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xla.FrontendAttributes.MapEntry.key");
 }
  static bool ValidateValue(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "xla.FrontendAttributes.MapEntry.value");
 }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};

// -------------------------------------------------------------------

class FrontendAttributes final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.FrontendAttributes) */ {
 public:
  inline FrontendAttributes() : FrontendAttributes(nullptr) {}
  ~FrontendAttributes() override;
  explicit PROTOBUF_CONSTEXPR FrontendAttributes(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FrontendAttributes(const FrontendAttributes& from);
  FrontendAttributes(FrontendAttributes&& from) noexcept
    : FrontendAttributes() {
    *this = ::std::move(from);
  }

  inline FrontendAttributes& operator=(const FrontendAttributes& from) {
    CopyFrom(from);
    return *this;
  }
  inline FrontendAttributes& operator=(FrontendAttributes&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FrontendAttributes& default_instance() {
    return *internal_default_instance();
  }
  static inline const FrontendAttributes* internal_default_instance() {
    return reinterpret_cast<const FrontendAttributes*>(
               &_FrontendAttributes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(FrontendAttributes& a, FrontendAttributes& b) {
    a.Swap(&b);
  }
  inline void Swap(FrontendAttributes* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FrontendAttributes* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FrontendAttributes* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FrontendAttributes>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FrontendAttributes& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FrontendAttributes& from) {
    FrontendAttributes::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FrontendAttributes* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.FrontendAttributes";
  }
  protected:
  explicit FrontendAttributes(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kMapFieldNumber = 1,
  };
  // map<string, string> map = 1;
  int map_size() const;
  private:
  int _internal_map_size() const;
  public:
  void clear_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_map();

  // @@protoc_insertion_point(class_scope:xla.FrontendAttributes)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        FrontendAttributes_MapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING> map_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class OpSharding final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.OpSharding) */ {
 public:
  inline OpSharding() : OpSharding(nullptr) {}
  ~OpSharding() override;
  explicit PROTOBUF_CONSTEXPR OpSharding(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpSharding(const OpSharding& from);
  OpSharding(OpSharding&& from) noexcept
    : OpSharding() {
    *this = ::std::move(from);
  }

  inline OpSharding& operator=(const OpSharding& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpSharding& operator=(OpSharding&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpSharding& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpSharding* internal_default_instance() {
    return reinterpret_cast<const OpSharding*>(
               &_OpSharding_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(OpSharding& a, OpSharding& b) {
    a.Swap(&b);
  }
  inline void Swap(OpSharding* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpSharding* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OpSharding* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OpSharding>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpSharding& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OpSharding& from) {
    OpSharding::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpSharding* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.OpSharding";
  }
  protected:
  explicit OpSharding(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef OpSharding_Type Type;
  static constexpr Type REPLICATED =
    OpSharding_Type_REPLICATED;
  static constexpr Type MAXIMAL =
    OpSharding_Type_MAXIMAL;
  static constexpr Type TUPLE =
    OpSharding_Type_TUPLE;
  static constexpr Type OTHER =
    OpSharding_Type_OTHER;
  static constexpr Type MANUAL =
    OpSharding_Type_MANUAL;
  static inline bool Type_IsValid(int value) {
    return OpSharding_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    OpSharding_Type_Type_MIN;
  static constexpr Type Type_MAX =
    OpSharding_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    OpSharding_Type_Type_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Type_descriptor() {
    return OpSharding_Type_descriptor();
  }
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return OpSharding_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return OpSharding_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTileAssignmentDimensionsFieldNumber = 3,
    kTileAssignmentDevicesFieldNumber = 4,
    kTupleShardingsFieldNumber = 5,
    kMetadataFieldNumber = 7,
    kLastTileDimsFieldNumber = 8,
    kTileShapeFieldNumber = 2,
    kTypeFieldNumber = 1,
    kReplicateOnLastTileDimFieldNumber = 6,
  };
  // repeated int64 tile_assignment_dimensions = 3;
  int tile_assignment_dimensions_size() const;
  private:
  int _internal_tile_assignment_dimensions_size() const;
  public:
  void clear_tile_assignment_dimensions();
  private:
  int64_t _internal_tile_assignment_dimensions(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_tile_assignment_dimensions() const;
  void _internal_add_tile_assignment_dimensions(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_tile_assignment_dimensions();
  public:
  int64_t tile_assignment_dimensions(int index) const;
  void set_tile_assignment_dimensions(int index, int64_t value);
  void add_tile_assignment_dimensions(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      tile_assignment_dimensions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_tile_assignment_dimensions();

  // repeated int64 tile_assignment_devices = 4;
  int tile_assignment_devices_size() const;
  private:
  int _internal_tile_assignment_devices_size() const;
  public:
  void clear_tile_assignment_devices();
  private:
  int64_t _internal_tile_assignment_devices(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_tile_assignment_devices() const;
  void _internal_add_tile_assignment_devices(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_tile_assignment_devices();
  public:
  int64_t tile_assignment_devices(int index) const;
  void set_tile_assignment_devices(int index, int64_t value);
  void add_tile_assignment_devices(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      tile_assignment_devices() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_tile_assignment_devices();

  // repeated .xla.OpSharding tuple_shardings = 5;
  int tuple_shardings_size() const;
  private:
  int _internal_tuple_shardings_size() const;
  public:
  void clear_tuple_shardings();
  ::xla::OpSharding* mutable_tuple_shardings(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::OpSharding >*
      mutable_tuple_shardings();
  private:
  const ::xla::OpSharding& _internal_tuple_shardings(int index) const;
  ::xla::OpSharding* _internal_add_tuple_shardings();
  public:
  const ::xla::OpSharding& tuple_shardings(int index) const;
  ::xla::OpSharding* add_tuple_shardings();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::OpSharding >&
      tuple_shardings() const;

  // repeated .xla.OpMetadata metadata = 7;
  int metadata_size() const;
  private:
  int _internal_metadata_size() const;
  public:
  void clear_metadata();
  ::xla::OpMetadata* mutable_metadata(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::OpMetadata >*
      mutable_metadata();
  private:
  const ::xla::OpMetadata& _internal_metadata(int index) const;
  ::xla::OpMetadata* _internal_add_metadata();
  public:
  const ::xla::OpMetadata& metadata(int index) const;
  ::xla::OpMetadata* add_metadata();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::OpMetadata >&
      metadata() const;

  // repeated .xla.OpSharding.Type last_tile_dims = 8;
  int last_tile_dims_size() const;
  private:
  int _internal_last_tile_dims_size() const;
  public:
  void clear_last_tile_dims();
  private:
  ::xla::OpSharding_Type _internal_last_tile_dims(int index) const;
  void _internal_add_last_tile_dims(::xla::OpSharding_Type value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_last_tile_dims();
  public:
  ::xla::OpSharding_Type last_tile_dims(int index) const;
  void set_last_tile_dims(int index, ::xla::OpSharding_Type value);
  void add_last_tile_dims(::xla::OpSharding_Type value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& last_tile_dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_last_tile_dims();

  // .xla.ShapeProto tile_shape = 2;
  bool has_tile_shape() const;
  private:
  bool _internal_has_tile_shape() const;
  public:
  void clear_tile_shape();
  const ::xla::ShapeProto& tile_shape() const;
  PROTOBUF_NODISCARD ::xla::ShapeProto* release_tile_shape();
  ::xla::ShapeProto* mutable_tile_shape();
  void set_allocated_tile_shape(::xla::ShapeProto* tile_shape);
  private:
  const ::xla::ShapeProto& _internal_tile_shape() const;
  ::xla::ShapeProto* _internal_mutable_tile_shape();
  public:
  void unsafe_arena_set_allocated_tile_shape(
      ::xla::ShapeProto* tile_shape);
  ::xla::ShapeProto* unsafe_arena_release_tile_shape();

  // .xla.OpSharding.Type type = 1;
  void clear_type();
  ::xla::OpSharding_Type type() const;
  void set_type(::xla::OpSharding_Type value);
  private:
  ::xla::OpSharding_Type _internal_type() const;
  void _internal_set_type(::xla::OpSharding_Type value);
  public:

  // bool replicate_on_last_tile_dim = 6;
  void clear_replicate_on_last_tile_dim();
  bool replicate_on_last_tile_dim() const;
  void set_replicate_on_last_tile_dim(bool value);
  private:
  bool _internal_replicate_on_last_tile_dim() const;
  void _internal_set_replicate_on_last_tile_dim(bool value);
  public:

  // @@protoc_insertion_point(class_scope:xla.OpSharding)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > tile_assignment_dimensions_;
    mutable std::atomic<int> _tile_assignment_dimensions_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > tile_assignment_devices_;
    mutable std::atomic<int> _tile_assignment_devices_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::OpSharding > tuple_shardings_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::xla::OpMetadata > metadata_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> last_tile_dims_;
    mutable std::atomic<int> _last_tile_dims_cached_byte_size_;
    ::xla::ShapeProto* tile_shape_;
    int type_;
    bool replicate_on_last_tile_dim_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ReplicaGroup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ReplicaGroup) */ {
 public:
  inline ReplicaGroup() : ReplicaGroup(nullptr) {}
  ~ReplicaGroup() override;
  explicit PROTOBUF_CONSTEXPR ReplicaGroup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReplicaGroup(const ReplicaGroup& from);
  ReplicaGroup(ReplicaGroup&& from) noexcept
    : ReplicaGroup() {
    *this = ::std::move(from);
  }

  inline ReplicaGroup& operator=(const ReplicaGroup& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReplicaGroup& operator=(ReplicaGroup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReplicaGroup& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReplicaGroup* internal_default_instance() {
    return reinterpret_cast<const ReplicaGroup*>(
               &_ReplicaGroup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(ReplicaGroup& a, ReplicaGroup& b) {
    a.Swap(&b);
  }
  inline void Swap(ReplicaGroup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReplicaGroup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReplicaGroup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReplicaGroup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReplicaGroup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReplicaGroup& from) {
    ReplicaGroup::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReplicaGroup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.ReplicaGroup";
  }
  protected:
  explicit ReplicaGroup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplicaIdsFieldNumber = 1,
  };
  // repeated int64 replica_ids = 1;
  int replica_ids_size() const;
  private:
  int _internal_replica_ids_size() const;
  public:
  void clear_replica_ids();
  private:
  int64_t _internal_replica_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_replica_ids() const;
  void _internal_add_replica_ids(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_replica_ids();
  public:
  int64_t replica_ids(int index) const;
  void set_replica_ids(int index, int64_t value);
  void add_replica_ids(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      replica_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_replica_ids();

  // @@protoc_insertion_point(class_scope:xla.ReplicaGroup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > replica_ids_;
    mutable std::atomic<int> _replica_ids_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class SourceTarget final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.SourceTarget) */ {
 public:
  inline SourceTarget() : SourceTarget(nullptr) {}
  ~SourceTarget() override;
  explicit PROTOBUF_CONSTEXPR SourceTarget(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SourceTarget(const SourceTarget& from);
  SourceTarget(SourceTarget&& from) noexcept
    : SourceTarget() {
    *this = ::std::move(from);
  }

  inline SourceTarget& operator=(const SourceTarget& from) {
    CopyFrom(from);
    return *this;
  }
  inline SourceTarget& operator=(SourceTarget&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SourceTarget& default_instance() {
    return *internal_default_instance();
  }
  static inline const SourceTarget* internal_default_instance() {
    return reinterpret_cast<const SourceTarget*>(
               &_SourceTarget_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(SourceTarget& a, SourceTarget& b) {
    a.Swap(&b);
  }
  inline void Swap(SourceTarget* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SourceTarget* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SourceTarget* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SourceTarget>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SourceTarget& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SourceTarget& from) {
    SourceTarget::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SourceTarget* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.SourceTarget";
  }
  protected:
  explicit SourceTarget(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSourceFieldNumber = 1,
    kTargetFieldNumber = 2,
  };
  // int64 source = 1;
  void clear_source();
  int64_t source() const;
  void set_source(int64_t value);
  private:
  int64_t _internal_source() const;
  void _internal_set_source(int64_t value);
  public:

  // int64 target = 2;
  void clear_target();
  int64_t target() const;
  void set_target(int64_t value);
  private:
  int64_t _internal_target() const;
  void _internal_set_target(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:xla.SourceTarget)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t source_;
    int64_t target_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PrecisionConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.PrecisionConfig) */ {
 public:
  inline PrecisionConfig() : PrecisionConfig(nullptr) {}
  ~PrecisionConfig() override;
  explicit PROTOBUF_CONSTEXPR PrecisionConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PrecisionConfig(const PrecisionConfig& from);
  PrecisionConfig(PrecisionConfig&& from) noexcept
    : PrecisionConfig() {
    *this = ::std::move(from);
  }

  inline PrecisionConfig& operator=(const PrecisionConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline PrecisionConfig& operator=(PrecisionConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PrecisionConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const PrecisionConfig* internal_default_instance() {
    return reinterpret_cast<const PrecisionConfig*>(
               &_PrecisionConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(PrecisionConfig& a, PrecisionConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(PrecisionConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PrecisionConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PrecisionConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PrecisionConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PrecisionConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PrecisionConfig& from) {
    PrecisionConfig::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PrecisionConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "xla.PrecisionConfig";
  }
  protected:
  explicit PrecisionConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PrecisionConfig_Precision Precision;
  static constexpr Precision DEFAULT =
    PrecisionConfig_Precision_DEFAULT;
  static constexpr Precision HIGH =
    PrecisionConfig_Precision_HIGH;
  static constexpr Precision HIGHEST =
    PrecisionConfig_Precision_HIGHEST;
  static constexpr Precision PACKED_NIBBLE =
    PrecisionConfig_Precision_PACKED_NIBBLE;
  static inline bool Precision_IsValid(int value) {
    return PrecisionConfig_Precision_IsValid(value);
  }
  static constexpr Precision Precision_MIN =
    PrecisionConfig_Precision_Precision_MIN;
  static constexpr Precision Precision_MAX =
    PrecisionConfig_Precision_Precision_MAX;
  static constexpr int Precision_ARRAYSIZE =
    PrecisionConfig_Precision_Precision_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Precision_descriptor() {
    return PrecisionConfig_Precision_descriptor();
  }
  template<typename T>
  static inline const std::string& Precision_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Precision>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Precision_Name.");
    return PrecisionConfig_Precision_Name(enum_t_value);
  }
  static inline bool Precision_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Precision* value) {
    return PrecisionConfig_Precision_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kOperandPrecisionFieldNumber = 1,
  };
  // repeated .xla.PrecisionConfig.Precision operand_precision = 1;
  int operand_precision_size() const;
  private:
  int _internal_operand_precision_size() const;
  public:
  void clear_operand_precision();
  private:
  ::xla::PrecisionConfig_Precision _internal_operand_precision(int index) const;
  void _internal_add_operand_precision(::xla::PrecisionConfig_Precision value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_operand_precision();
  public:
  ::xla::PrecisionConfig_Precision operand_precision(int index) const;
  void set_operand_precision(int index, ::xla::PrecisionConfig_Precision value);
  void add_operand_precision(::xla::PrecisionConfig_Precision value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& operand_precision() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_operand_precision();

  // @@protoc_insertion_point(class_scope:xla.PrecisionConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> operand_precision_;
    mutable std::atomic<int> _operand_precision_cached_byte_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_tensorflow_2fcompiler_2fxla_2fxla_5fdata_2eproto;
};
// -------------------------------------------------------------------

class ParameterReplication final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:xla.ParameterReplication) */ {
 public:
  inline ParameterReplication() : ParameterReplication(nullptr) {}
  ~ParameterReplication() override;
  explicit PROTOBUF_CONSTEXPR ParameterReplication(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ParameterReplication(const ParameterReplication& from);
  ParameterReplication(ParameterReplication&& from) noexcept
    : ParameterReplication() {
    *this = ::std::move(from);
  }

  inline ParameterReplication& operator=(const ParameterReplication& from) {
    CopyFrom(from);
    return *this;
  }
  inline ParameterReplication& operator=(ParameterReplication&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ParameterReplication& default_instance() {
    return *internal_default_instance();
  }
  static inline const ParameterReplication* internal_default_instance() {
    return reinterpret_cast<const ParameterReplication*>(
               &_ParameterReplication_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ParameterReplication& a, ParameterReplication& b) {
    a.Swap(&b);
  }
  inline void Swap(ParameterReplication* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID